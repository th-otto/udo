

screen( "Copyright" )
LIB.HLP wurde Åbersetzt am 20.MÑrz 1993.

(c) 1990 Borland International, Inc.
\end

screen( "Index" )
Index der verfÅgbaren SchlÅsselwîrter:

     \#A..\#       \#B..\#       \#C..\#      \#D..\#

     \#E..\#       \#F..\#       \#G..\#      \#H..\#

     \#I..\#       \#J..\#       \#K..\#      \#L..\#

     \#M..\#       \#N..\#       \#O..\#      \#P..\#

     \#Q..\#       \#R..\#       \#S..\#      \#T..\#

     \#U..\#       \#V..\#       \#W..\#      \#X..\#

     \#Y..\#       \#Z..\#

     \#Sonstiges\#
\end

screen( capsensitive("OBJECT"),
		capsensitive("ob_height"),
		capsensitive("ob_next"),
		capsensitive("ob_spec"),
		capsensitive("ob_state"),
		capsensitive("ob_tail"),
		capsensitive("ob_head"),
		capsensitive("ob_type"),
		capsensitive("ob_width"),
		capsensitive("ob_x"),
		capsensitive("ob_flags"),
		capsensitive("ob_y") )
Die Objektstruktur:
===================

OBJECT ist in AES.H wie folgt definiert:

typedef struct
{
        int             ob_next;   /* das nÑchste Objekt            */
        int             ob_head;   /* erstes Kind                   */
        int             ob_tail;   /* letztes Kind                  */
        unsigned int    ob_type;   /* \#Objektart\#                     */
        unsigned int    ob_flags;  /* \#Manipulationsflags\#            */
        unsigned int    ob_state;  /* \#Objektstatus\#                  */
        \#OBSPEC\#          ob_spec;   /* mehr unter \#Objektart\#          */
        int             ob_x;      /* x-Koordinate des Objekts      */
        int             ob_y;      /* y-Koordinate des Objekts      */
        int             ob_width;  /* Breite des Objekts            */
        int             ob_height; /* Hîhe des Objekts              */
} OBJECT;
\end

screen( capsensitive("te_thickness"),
		capsensitive("TEDINFO"),
		capsensitive("te_txtlen"),
		capsensitive("te_tmplen"),
		capsensitive("te_color"),
		capsensitive("te_font"),
		capsensitive("te_junk1"),
		capsensitive("te_junk2"),
		capsensitive("te_just"),
		capsensitive("te_ptext"),
		capsensitive("te_pvalid"),
		capsensitive("te_ptmplt") )
Die Tedinfostruktur:
====================

Die TEDINFO-Struktur ist wie die Objektstruktur eine C-Datenstruktur,
die benutzt wird, um ein Textobjekt nÑher zu beschreiben.

Hier die C-Deklaration in AES.H:

typedef struct
{
    char    *te_ptext;         /* Zeiger auf einen String          */
    char    *te_ptmplt;        /* Zeiger auf die Stringmaske       */
    char    *te_pvalid;        /* Zeiger auf den GÅltigkeitsstring */
    int     te_font;           /* Zeichensatz                      */
    int     te_junk1;
    int     te_just;           /* Justierung des Texts             */
    int     te_color;          /* Farbe                            */
    int     te_junk2;
    int     te_thickness;      /* Rahmenbreite                     */
    int     te_txtlen;         /* Maximale LÑnge des Textes        */
    int     te_tmplen;         /* LÑnge der Stringmaske            */
} TEDINFO;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("bi_pdata"),
		capsensitive("bi_wb"),
		capsensitive("bi_x"),
		capsensitive("BITBLK"),
		capsensitive("bi_y"),
		capsensitive("bi_color"),
		capsensitive("bi_hl") )
Die Bitblkstruktur:
===================

Die BITBLK-Struktur ist wie die Objektstruktur eine C-Datenstruktur,
die benutzt wird, um ein Bildobjekt nÑher zu beschreiben.

Hier die C-Deklaration in AES.H:

typedef struct
{
        int     *bi_pdata;         /* Zeiger auf die Grafikdaten    */
        int     bi_wb;             /* Breite des Bildes in Bytes    */
        int     bi_hl;             /* Hîhe in Linien                */
        int     bi_x;              /* x-Position                    */
        int     bi_y;              /* y-Position                    */
        int     bi_color;          /* Vordergrundfarbe              */
} BITBLK;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("ib_pdata"),
		capsensitive("ib_wtext"),
		capsensitive("ib_wicon"),
		capsensitive("ib_ptext"),
		capsensitive("ib_pmask"),
		capsensitive("ib_xicon"),
		capsensitive("ib_xtext"),
		capsensitive("ib_char"),
		capsensitive("ib_ychar"),
		capsensitive("ICONBLK"),
		capsensitive("ib_hicon"),
		capsensitive("ib_xchar"),
		capsensitive("ib_yicon"),
		capsensitive("ib_ytext"),
		capsensitive("ib_htext") )
Die Iconblkstruktur:
====================

Die ICONBLK-Struktur ist wie die Objektstruktur eine C-Datenstruktur,
die benutzt wird, um ein Icon nÑher zu beschreiben.

Hier die C-Deklaration in AES.H:

typedef struct
{
        int     *ib_pmask;         /* Zeiger auf die Maske          */
        int     *ib_pdata;         /* Zeiger auf das Icon-Bild      */
        char    *ib_ptext;         /* Zeiger auf einen String       */
        int     ib_char;           /* In den unteren 8 Bit das dar- */
                                   /* zustellende Zeichen, in den   */
                                   /* oberen 8 Bit die Farbe des    */
                                   /* gesetzten (obere 4 Bit) und   */
                                   /* des gelîschten (untere 8 Bit) */
                                   /* Bits des Bitmuster IB_PDATA   */
        int     ib_xchar;          /* x-Koordinate des Buchstabens  */
        int     ib_ychar;          /* y-Koordinate des Buchstabens  */
        int     ib_xicon;          /* x-Koordinate des Icons        */
        int     ib_yicon;          /* y-Koordinate des Icons        */
        int     ib_wicon;          /* Breite des Icons              */
        int     ib_hicon;          /* Hîhe des Icons                */
        int     ib_xtext;          /* x-Koordinate des Textes       */
        int     ib_ytext;          /* y-Koordinate des Textes       */
        int     ib_wtext;          /* Breite des Textes             */
        int     ib_htext;          /* Hîhe des Textes               */
} ICONBLK;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("ub_code"),
		capsensitive("USERBLK"),
		capsensitive("ub_parm") )
Die Userblockstruktur:
======================

Die USERBLK-Struktur ist eine C-Datenstruktur, die benutzerdefinierte
Objekte nÑher kennzeichnet.

C-Deklaration in AES.H:

typedef struct
{
        int \link("%%GLOBAL%%")cdecl\# (*ub_code)(\#PARMBLK\# *parmblock);
                                   /* Zeiger auf eine Funktion */
        long ub_parm;              /* optionaler Parameter     */
} USERBLK;

Dabei wird die Funktion ub_code bei jedem \#objc_draw\# und \#objc_change\#
Aufruf fÅr das entsprechende Objekt aufgerufen. Dabei wird ein Zeiger
auf eine \#PARMBLK\#-struktur Åbergeben.

Querverweis: \#OBJECT\#
\end

screen( capsensitive("pb_prevstate"),
		capsensitive("pb_wc"),
		capsensitive("pb_x"),
		capsensitive("PARMBLK"),
		capsensitive("pb_currstate"),
		capsensitive("pb_h"),
		capsensitive("pb_xc"),
		capsensitive("pb_y"),
		capsensitive("pb_yc"),
		capsensitive("pb_w"),
		capsensitive("pb_tree"),
		capsensitive("pb_obj"),
		capsensitive("pb_hc"),
		capsensitive("pb_parm") )
Die Paramblkstruktur:
=====================

Ein Zeiger auf eine PARMBLK-Struktur wird bei einem
benutzerdefinierten Objekten bei jedem \#objc_draw\# und
\#objc_change\# Aufruf als Parameter Åbergeben.

C-Deklaration in AES.H:

typedef struct
{
        \#OBJECT\#  *pb_tree;          /* Zeiger auf den Objektbaum     */
        int     pb_obj;            /* Nummer des Objekts            */
        int     pb_prevstate;      /* vorheriger Objektstatus       */
        int     pb_currstate;      /* neuer Objektstatus            */
        int     pb_x, pb_y, pb_w, pb_h;      /* Objektkoordinaten   */
        int     pb_xc, pb_yc, pb_wc, pb_hc;  /* Clipping-Koordinate */
        long    pb_parm;           /* der optionale Parameter aus der*/
} PARMBLK;                         /* \#USERBLK\#-struktur               */

Die Clipping-Koordinaten sind die, bei einem \#objc_draw\# und
\#objc_change\# Aufruf als Parameter Åbergebenen Koordinaten.
\end

screen( capsensitive("mf_yhot"),
		capsensitive("mf_data"),
		capsensitive("mf_bg"),
		capsensitive("MFORM"),
		capsensitive("mf_fg"),
		capsensitive("mf_mask"),
		capsensitive("mf_xhot"),
		capsensitive("mf_nplanes") )
Die Struktur MFORM legt das Aussehen des Mauszeigers fest.

typedef struct mfstr
{
    int  mf_xhot;
    int  mf_yhot;
    int  mf_nplanes;
    int  mf_fg;
    int  mf_bg;
    int  mf_mask[16];
    int  mf_data[16];
} MFORM;

Querverweis    \#graf_mouse\#
\end

screen( capsensitive("MFDB") )
Der Memory Form Definition Block ist eine Datenstruktur, die vom
VDI fÅr die Rasteroperationen benutzt wird, um die Ziel- und
Quellspeicherbereiche zu beschreiben.

C-Deklaration in VDI.H:

typedef struct mfdb
{
        void *fd_addr;               /* Zeiger auf den Beginn des*/
                                     /* Speicherbereichs, z. B.  */
                                     /* Bildspeicherbasisadresse */
        int  fd_w;                   /* Blockbreite in Pixeln    */
        int  fd_h;                   /* Hîhe des Blocks in Pixeln*/
        int  fd_wdwidth;             /* Blockbreite in Integern  */
        int  fd_stand;               /* 0 = gerÑteabhÑngiges Format
                                        1 = Standardformat       */
        int  fd_nplanes;             /* Anzahl der Farbebenen    */
        int  fd_r1, fd_r2, fd_r3;    /* reserviert               */
} MFDB;

Querverweis: \#vro_cpyfm\#, \#vrt_cpyfm\#, \#vr_trnfm\#
\end

screen( capsensitive("global"),
		capsensitive("intout"),
		capsensitive("ptsout"),
		capsensitive("intin"),
		capsensitive("addrout"),
		capsensitive("contrl"),
		capsensitive("ptsin"),
		capsensitive("_GemParBlk"),
		capsensitive("addrin"),
		capsensitive("GEMPARBLK") )
Name            Gemparameterblockpointer

Deklaration:    extern  GEMPARBLK _GemParBlk;
Deklaration in  aes.h

Beschreibung:   Zeigt auf den Gemparameterblock der Applikation. öber
                diese Struktur werden dem GEM die Parameter Åbergeben.
                Sie mÅssen also nicht, die Arrays selbst definieren.
                Der Gemparameterblock hat folgende Struktur:

typedef struct
{
    int    contrl[15];
    int    global[80];
    int    intin[128];
    int    intout[45];
    int    ptsout[128];
    void   *addrin[128];
    void   *addrout[6];
    int    ptsin[128];
} GEMPARBLK;
\end

screen( capsensitive("MOBLK") )
MOBLK ist in aes.h wie folgt definiert:

typedef struct
{
        int             m_out;
        int             m_x;
        int             m_y;
        int             m_w;
        int             m_h;
} MOBLK;
\end

screen( capsensitive("ORECT") )
ORECT ist in aes.h wie folgt definiert:

typedef struct orect
{
        struct  orect   *o_link;
        int     o_x;
        int     o_y;
        int     o_w;
        int     o_h;
} ORECT;
\end

screen( capsensitive("GRECT"),
		capsensitive("g_h"),
		capsensitive("g_w"),
		capsensitive("g_y"),
		capsensitive("g_x") )
GRECT ist in aes.h wie folgt definiert:

typedef struct
{
        int     g_x;    /* x, obere linke Ecke des Rechtecks */
        int     g_y;    /* y, obere linke Ecke des Rechtecks */
        int     g_w;    /* Breite des Rechtecks              */
        int     g_h;    /* Hîhe des Rechtecks                */
} GRECT;
\end

screen( capsensitive("framecol"),
		capsensitive("fillpattern"),
		capsensitive("bfobspec"),
		capsensitive("character"),
		capsensitive("textcol"),
		capsensitive("textmode"),
		capsensitive("interiorcol"),
		capsensitive("framesize") )
bfobspec ist in aes.h wie folgt definiert:

typedef struct
{
    unsigned character   :    8;
    signed   framesize   :    8;
    unsigned framecol    :    4;
    unsigned textcol     :    4;
    unsigned textmode    :    1;
    unsigned fillpattern :    3;
    unsigned interiorcol :    4;
} bfobspec;

Querverweis: \#OBSPEC\#
\end

screen( capsensitive("userblk"),
		capsensitive("free_string"),
		capsensitive("index"),
		capsensitive("indirect"),
		capsensitive("OBSPEC"),
		capsensitive("iconblk"),
		capsensitive("bitblk"),
		capsensitive("tedinfo"),
		capsensitive("obspec") )
Da ob_spec je nach Typ des Objekts verschiede Bedeutungen und Datentypen
haben kann, erhielt es den TYP OBSPEC.

OBSPEC ist in aes.h wie folgt definiert:

typedef \link("%%GLOBAL%%")union\# obspecptr
{
    long     index;                 /* fÅr das RSC-C-output */
    union obspecptr *indirect;      /* Zeiger uaf ob_spec   */
    \#bfobspec\# obspec;                /* Bitfield             */
    \#TEDINFO\#  *tedinfo;              /* Zeiger auf TEDINFO   */
    \#ICONBLK\#  *iconblk;              /* Zeiger auf ICONBLK   */
    \#BITBLK\#   *bitblk;               /* Zeiger auf BITBLK    */
    \#USERBLK\#  *userblk;              /* Zeiger auf USERBLK   */
    char     *free_string;          /* zeiger auf String    */
} OBSPEC;

Wollen Sie zum Beispiel auf ob_spec als zeiger auf eine TEDINFO-struktur
zugreifen, so muûten Sie bisher ob_spec zum gewÅnschten Typ casten:

(\#TEDINFO\# *) objectAdr[index].\#ob_spec\#->\#te_ptext\#;
    |        |        |
casting      |        |
             |        |
Baumaddresse mit      |
\#rsrc_gaddr\# ermittelt  |
                      |
index vom RCS---------+       

Dies ist nun nicht mehr notwendig. Schreiben Sie nun einfach:

objectAdr[index].ob_spec.tedinfo->te_ptext;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("RSHDR") )
RSHDR ist in aes.h wie folgt definiert:

typedef struct rshdr
{
        unsigned     rsh_vrsn;
        unsigned     rsh_object;
        unsigned     rsh_tedinfo;
        unsigned     rsh_iconblk;    /* list of ICONBLKS */
        unsigned     rsh_bitblk;
        unsigned     rsh_frstr;
        unsigned     rsh_string;
        unsigned     rsh_imdata;     /* image data */
        unsigned     rsh_frimg;
        unsigned     rsh_trindex;
        unsigned     rsh_nobs;       /* counts of various structs */
        unsigned     rsh_ntree;
        unsigned     rsh_nted;
        unsigned     rsh_nib;
        unsigned     rsh_nbb;
        unsigned     rsh_nstring;
        unsigned     rsh_nimages;
        unsigned     rsh_rssize;     /* total bytes in resource */
} RSHDR;

Mit dieser Structur wird der Header eines Resourcefiles beschrieben.
\end

screen( capsensitive("ffblk"),
		capsensitive("ff_name"),
		capsensitive("ff_ftime"),
		capsensitive("ff_fsize"),
		capsensitive("ff_attrib"),
		capsensitive("ff_fdate") )
ffblk ist in ext.h wie folgt definiert:

struct ffblk
{
    char ff_reserved[21];               /* Reserved by TOS */
    char ff_attrib;                     /* Attribute found */
    int  ff_ftime;                      /* File time */
    int  ff_fdate;                      /* File date */
    long ff_fsize;                      /* File size */
    char ff_name[13];                   /* File name found */
};

Querverweis: \#findfirst\#, \#findnext\#
\end

screen( capsensitive("date"),
		capsensitive("da_day"),
		capsensitive("da_mon"),
		capsensitive("da_year") )
date ist in ext.h wie folgt definiert:

struct date
{
    int    da_year;                     /* Current year */
    char   da_day;                      /* Day of the month */
    char   da_mon;                      /* Month ( 1 = Jan ) */
};

Querverweis: \#getdate\#, \#setdate\#
\end

screen( "time, struct time",
		capsensitive("ti_sec"),
		capsensitive("ti_hour"),
		capsensitive("ti_hund"),
		capsensitive("ti_min") )
time ist in ext.h wie folgt definiert:

struct time
{
    unsigned char   ti_min;             /* Minutes */
    unsigned char   ti_hour;            /* Hours */
    unsigned char   ti_hund;            /* Hundredths of seconds */
    unsigned char   ti_sec;             /* Seconds */
};

Querverweis: \#gettime\#, \#settime\#
\end

screen( capsensitive("df_sclus"),
		capsensitive("df_avail"),
		capsensitive("df_bsec"),
		capsensitive("df_total"),
		capsensitive("dfree") )
dfree ist in ext.h wie folgt definiert:

struct dfree
{
        unsigned df_avail;
        unsigned df_total;
        unsigned df_bsec;
        unsigned df_sclus;
};

Querverweis: \#getdfree\#
\end

screen( capsensitive("ft_min"),
		capsensitive("ft_day"),
		capsensitive("ft_hour"),
		capsensitive("ftime"),
		capsensitive("ft_year"),
		capsensitive("ft_month"),
		capsensitive("ft_tsec") )
ftime ist in ext.h wie folgt definiert:

struct ftime
{
    unsigned ft_tsec:   5;
    unsigned ft_min:    6;
    unsigned ft_hour:   5;
    unsigned ft_year:   7;
    unsigned ft_month:  4;
    unsigned ft_day:    5;
};

Querverweis: \#getftime\#, \#setftime\#
\end

screen( capsensitive("st_dev"),
		capsensitive("st_mode"),
		capsensitive("st_ctime"),
		capsensitive("st_atime"),
		capsensitive("st_size"),
		capsensitive("st_ino"),
		capsensitive("st_rdev"),
		capsensitive("st_gid"),
		capsensitive("st_uid"),
		capsensitive("stat, struct stat"),
		capsensitive("st_mtime"),
		capsensitive("st_nlink") )
stat ist in ext.h wie folgt definiert:

struct stat
{
    int    st_dev;           /* Laufwerk, das die Datei enthÑlt    */
    int    st_ino;
    int    st_mode;          /* Bit-Maske mit \link("findfirst")Dateiattributen\#      */
    int    st_nlink;         /* immer 1                            */
    int    st_uid;
    int    st_gid;
    int    st_rdev;          /* wie st_dev                         */
    size_t st_size;          /* Dateigrîûe in Bytes                */
    long   st_atime;         /* Zeit der letzten DateiÑnderung     */
    long   st_mtime;         /* wie st_atime                       */
    long   st_ctime;         /* wie st_atime                       */
};

Querverweis: \#stat\#, \#fstat\#
\end

screen( capsensitive("exception"),
		capsensitive("arg1"),
		capsensitive("name"),
		capsensitive("type"),
		capsensitive("arg2"),
		capsensitive("retval") )
exception ist in math.h wie folgt definiert:

struct exception
{
    mexcep      type;   /* Fehlerart ist in math.h definiert.       */
    char        *name;  /* name ist ein Zeiger auf einen nulltermi- */
                        /* nierten String der den Namen der fehler- */
                        /* auslîsenden Funktion enthÑlt.            */
    double      arg1;   /* arg1 und arg2 enthalten die Werte der    */
                        /* Argumente, die der Funktion Åbergeben    */
    double      arg2;   /* wurden.                                  */
    double      retval; /* retval enhÑlt das fehlerhafte Ergebnis.  */
};

Querverweis   \#setmatherr\#
\end

screen( capsensitive("size_t") )
size_t ist in mehreren Headerfiles wie folgt definiert:

typedef unsigned long   size_t;
\end

screen( capsensitive("clock_t") )
clock_t ist in time.h wie folgt definiert:

typedef long   clock_t;

Querverweis: \#clock\#
\end

screen( capsensitive("CLK_TCK") )
CLK_TCK ist in time.h wie folgt definiert:

\link("%%GLOBAL%%")#define\# CLK_TCK 200

Achtung auf anderen Systemen kann diese Konstante auch eine 
Flieûkommazahl sein.

Querverweis: \#clock\#
\end

screen( capsensitive("fpos_t") )
fpos_t ist in stdio.h wie folgt definiert:

typedef unsigned long   fpos_t;

Querverweis: \#fgetpos\#, \#fsetpos\#
\end

screen( capsensitive("ptrdiff_t") )
ptrdiff_t ist in stddef.h wie folgt definiert:

typedef long   ptrdiff_t;

prtdiff ist der Typ einer Differenz zweier Pointer.
\end

screen( capsensitive("time_t") )
time_t ist in time.h wie folgt definiert:

typedef long  time_t;

Querverweis: \#ctime\#, \#gmtime\#, \#localtime\#, \#time\#, \#mktime\#, \#difftime\#
\end

screen( capsensitive("div_t"),
		capsensitive("quot"),
		capsensitive("rem") )
div_t ist in stdlib.h wie folgt definiert:

typedef struct
{
    int    quot; /* Quotient */
    int    rem;  /* Rest */
} div_t;

Querverweis: \#ldiv_t\#
\end

screen( capsensitive("LINE"),
		capsensitive("actuallen"),
		capsensitive("maxlen"),
		capsensitive("buffer") )
LINE ist in tos.h wie folgt definiert:

typedef struct
{
    unsigned char   maxlen;
    unsigned char   actuallen;
    char            buffer[255];
} LINE;

Querverweis: \#Cconrs\#
\end

screen( capsensitive("d_attrib"),
		capsensitive("d_time"),
		capsensitive("d_fname"),
		capsensitive("DTA"),
		capsensitive("d_date"),
		capsensitive("d_length") )
DTA ist in tos.h wie folgt definiert:

typedef struct
{
    char            d_reserved[21];
    unsigned char   d_attrib;
    unsigned int    d_time;
    unsigned int    d_date;
    unsigned long   d_length;
    char            d_fname[14];
} DTA;

Querverweis    \#Fsetdta\#   \#Fgetdta\#
\end

screen( capsensitive("b_secsiz"),
		capsensitive("b_clsiz"),
		capsensitive("b_total"),
		capsensitive("b_free"),
		capsensitive("DISKINFO") )
DISKINFO ist in tos.h wie folgt definiert:

typedef struct
{
    unsigned long   b_free;
    unsigned long   b_total;
    unsigned long   b_secsiz;
    unsigned long   b_clsiz;
} DISKINFO;

Querverweis    \#Dfree\#
\end

screen( capsensitive("ibuflow"),
		capsensitive("ibuftl"),
		capsensitive("IOREC"),
		capsensitive("ibufsiz"),
		capsensitive("ibufhd"),
		capsensitive("ibuf"),
		capsensitive("ibufhi") )
IOREC ist in tos.h wie folgt definiert:

typedef struct
{
        void    *ibuf;          /* Zeiger auf den Buffer   */
        int     ibufsiz;        /* Grîûe des Buffers       */
        int     ibufhd;         /* nÑchste Schreibposition */
        int     ibuftl;         /* nÑchste Leseposition    */
        int     ibuflow;        /* Marke fÅr Xon           */
        int     ibufhi;         /* Marke fÅr Xoff          */
} IOREC;

Querverweis    \#Iorec\#
\end

screen( capsensitive("kb_joyvec"),
		capsensitive("kb_statvec"),
		capsensitive("kb_clockvec"),
		capsensitive("kb_mousevec"),
		capsensitive("kb_midivec"),
		capsensitive("kb_midisys"),
		capsensitive("KBDVBASE"),
		capsensitive("kb_vkbderr"),
		capsensitive("kb_vmiderr"),
		capsensitive("kb_kbdsys") )
KBDVBASE ist in tos.h wie folgt definiert:

typedef struct
{
    void  (*kb_midivec)();   /* MIDI Interrupt-Vektor */
    void  (*kb_vkbderr)();   /* Tastatur Fehler-Vektor */
    void  (*kb_vmiderr)();   /* MIDI Fehler-Vektor */
    void  (*kb_statvec)();   /* Tastatur-Status */
    void  (*kb_mousevec)();  /* Tastatur-Maus-Status */
    void  (*kb_clockvec)();  /* Tastatur-Zeitgeber */
    void  (*kb_joyvec)();    /* Tastatur-Joystick-Status */
    void  (*kb_midisys)();   /* System-Midi-Vektor */
    void  (*kb_kbdsys)();    /* Tastatur-Vektor */
} KBDVBASE ;

Querverweis    \#Kbdvbase\#
\end

screen( capsensitive("p_stdfh"),
		capsensitive("p_resrvd0"),
		capsensitive("p_tlen"),
		capsensitive("p_curdrv"),
		capsensitive("BASPAG"),
		capsensitive("p_dlen"),
		capsensitive("p_bbase"),
		capsensitive("p_dbase"),
		capsensitive("p_blen"),
		capsensitive("p_cmdlin"),
		capsensitive("p_parent"),
		capsensitive("_BasPag"),
		capsensitive("p_dta"),
		capsensitive("p_env"),
		capsensitive("p_lowtpa"),
		capsensitive("p_tbase"),
		capsensitive("p_hitpa") )
Name            Basepagepointer

Deklaration:    extern BASPAG *_BasPag;
Deklaration in  tos.h

Beschreibung:   Zeigt auf die Basepage der Applikation. Die Basepage
                hat folgende Struktur:

typedef struct baspag
{
        void    *p_lowtpa;          /* Start der TPA              */
        void    *p_hitpa;           /* Ende der TPA               */
        void    *p_tbase;           /* Start des Textsegments     */
        long    p_tlen;             /* LÑnge des Textsegments     */
        void    *p_dbase;           /* Start des Datasegments     */
        long    p_dlen;             /* LÑnge des Datasegments     */
        void    *p_bbase;           /* Start des BSS              */
        long    p_blen;             /* LÑnge des BSS              */
        DTA     *p_dta;             /* Start der \#DTA\#              */
        struct baspag *p_parent;    /* Start des aufrufenden Prg. */
        long    p_resrvd0;          /* reserviert                 */
        char    *p_env;             /* Start des Environments     */
        char    p_stdfh[6];         /* Standardhandles            */
        char    p_resrvd1;          /* reserviert                 */
        char    p_curdrv;           /* aktuelles Laufwerk         */
        long    p_resrvd2[18];      /* reserviert                 */
        char    p_cmdlin[128];      /* Kommandozeile              */
} BASPAG;

Querverweis: \#Pexec\#
\end

screen( capsensitive("recsiz"),
		capsensitive("fatrec"),
		capsensitive("clsiz"),
		capsensitive("datrec"),
		capsensitive("BPB"),
		capsensitive("rdlen"),
		capsensitive("bflags"),
		capsensitive("clsizb"),
		capsensitive("fsiz"),
		capsensitive("numcl") )
BPB ist in tos.h wie folgt definiert:

typedef struct
{
        int   recsiz;       /* Bytes pro Sektor      */
        int   clsiz;        /* Sektoren pro Cluster  */
        int   clsizb;       /* Bytes pro Cluster     */
        int   rdlen;        /* VerzeichnislÑnge      */
        int   fsiz;         /* LÑnge der FAT         */
        int   fatrec;       /* Start der 2. FAT      */
        int   datrec;       /* 1. freier Sektor      */
        int   numcl;        /* Gesamtzahl an Cluster */
        int   bflags;       /* Flags                 */
} BPB ;

Querverweis: \#Getbpb\#
\end

screen( "date (DOSTIME)",
		"time (DOSTIME)",
		capsensitive("DOSTIME") )
DOSTIME ist in tos.h wie folgt definiert;

typedef struct
{
        unsigned int     time;
        unsigned int     date;
} DOSTIME;

               Die Struktur der beiden Integer-Werte gliedert sich wie
               folgt:

Bit            time
0-4            Sekunden in Zweierschritten (0-29)
5-10           Minuten (0-59)
11-15          Stunden (0-23)

Bit            date
0-4            Tag im Monat (1-31)
5-8            Monat (1-12)
9-15           Jahr (0-119, 0=1980)

Querverweis: \#Fdatime\#
\end

screen( capsensitive("command_tail"),
		capsensitive("length"),
		capsensitive("COMMAND") )
COMMAND ist in tos.h wie folgt definiert:

typedef struct
{
        unsigned char   length;
        char            command_tail[128];
} COMMAND;

Querverweis: \#Pexec\#
\end

screen( capsensitive("y_max"),
		capsensitive("x_start"),
		capsensitive("topmode"),
		capsensitive("buttons"),
		capsensitive("y_start"),
		capsensitive("y_scale"),
		capsensitive("x_max"),
		capsensitive("MOUSE"),
		capsensitive("x_scale") )
typedef struct
{
        char    topmode;
        char    buttons;
        char    x_scale;
        char    y_scale;
        int     x_max;
        int     y_max;
        int     x_start;
        int     y_start;
} MOUSE;

Querverweis: \#Initmouse\#
\end

screen( capsensitive("KEYTAB") )
KEYTAB ist in tos.h wie folgt definiert:

typedef struct
{
        char *unshift;
        char *shift;
        char *capslock;
} KEYTAB;

Querverweis: \#Keytbl\#
\end

screen( capsensitive("MD") )
MD ist in tos.h wie folgt definiert:

typedef struct __md
{
        struct __md *m_link;
        void        *m_start;
        long        m_length;
        BASPAG      *m_own;
} MD;

Querverweis: \#Getmpb\#, \#MPB\#
\end

screen( capsensitive("MPB") )
MPB ist int tos.h wie folgt definiert:

typedef struct          /* used by Getmpb */
{
        \#MD\# *mp_mfl;
        \#MD\# *mp_mal;
        \#MD\# *mp_rover;
} MPB;

Querverweis: \#Getmpb\#
\end

screen( capsensitive("MAPTAB"),
		capsensitive("bconout"),
		capsensitive("bconin"),
		capsensitive("bconstat"),
		capsensitive("iorec"),
		capsensitive("rsconf"),
		capsensitive("bcostat") )
MAPTAB ist in tos.h wie folgt definiert:

typedef struct
{
        int   (*bconstat) ();    /* Zeiger auf \#Bconstat\# */
        long  (*bconin) ();      /* Zeiger auf \#Bconin\#   */
        int   (*bcostat) ();     /* Zeiger auf \#Bcostat\#  */
        void  (*bconout) ();     /* Zeiger auf \#Bconout\#  */
        long  (*rsconf) ();      /* Zeiger auf \#Rsconf\#   */
        \#IOREC\# *iorec;
} MAPTAB;

Querverweis: \#Bconmap\#, \#BCONMAP\#
\end

screen( capsensitive("maptabsize"),
		capsensitive("maptab"),
		capsensitive("BCONMAP") )
BCONMAP ist in tos.h wie folgt definiert:
        
typedef struct
{
        \#MAPTAB\# *maptab;     /* Liste der seriellen Schnittstellen */
        int    maptabsize;  /* Anzahl der Schnittstellentreiber   */ 
} BCONMAP;

Querverweis: \#Bconmap\#
\end

screen( capsensitive("SYSHDR") )
SYSHDR ist in tos.h wie folgt definiert:

typedef struct _syshdr         
{
    unsigned   os_entry;   /* $00 BRA to reset handler             */     
    unsigned   os_version; /* $02 TOS version number               */
    void       *os_start;  /* $04 -> reset handler                 */ 
    struct _syshdr *os_base;   /* $08 -> baseof OS                     */     
    void       *os_membot; /* $0c -> end BIOS/GEMDOS/VDI ram usage */     
    void       *os_rsv1;   /* $10 << unused,reserved >>            */     
    long       *os_magic;  /* $14 -> GEM memoryusage parm. block   */     
    long       os_gendat;  /* $18 Date of system build($MMDDYYYY)  */     
    int        os_palmode; /* $1c OS configuration bits            */     
    int        os_gendatg; /* $1e DOS-format date of systembuild   */
/* 
    The next three fields are only available in TOS versions 1.2 and
    greater 
*/     
    void      *_root;     /* $20 -> base of OS pool               */     
    long      *kbshift;   /* $24 -> keyboard shift state variable */ 
    BASPAG    **_run;     /* $28 -> GEMDOS PID of current process */     
    void      *p_rsv2;    /* $2c << unused, reserved >>           */ 
} SYSHDR;

Ab Adresse 0x4F2L liegt ein Zeiger auf eine solche Struktur.
\end

screen( capsensitive("PBDEF") )
PBDEF ist in tos.h wie folgt definiert:

typedef struct
{
        void    *pb_scrptr;
        int     pb_offset;
        int     pb_width;
        int     pb_height;
        int     pb_left;
        int     pb_right;
        int     pb_screz;
        int     pb_prrez;
        void    *pb_colptr;
        int     pb_prtype;
        int     pb_prport;
        void    *pb_mask;
} PBDEF;

Querverweis    \#Prtblk\#
\end

screen( capsensitive("tm_isdst"),
		capsensitive("tm_wday"),
		capsensitive("tm_mday"),
		capsensitive("tm"),
		capsensitive("tm_year"),
		capsensitive("tm_min"),
		capsensitive("tm_yday"),
		capsensitive("tm_mon"),
		capsensitive("tm_sec"),
		capsensitive("tm_hour") )
tm ist in time.h wie folgt definiert:

struct    tm
{
      int    tm_sec;     /* Sekunden                            */
      int    tm_min;     /* Minuten                             */
      int    tm_hour;    /* Stunden (0..23)                     */
      int    tm_mday;    /* Tag im Monat (1..31)                */
      int    tm_mon;     /* Monat (0..11)                       */
      int    tm_year;    /* Jahr                                */
      int    tm_wday;    /* Wochentag (0..6) -> (So..Sa)        */
      int    tm_yday;    /* Tag im Jahr (0..365)                */
      int    tm_isdst;   /* ungleich Null entspricht Sommerzeit */
};

Querverweis: \#ctime\#
\end

screen( capsensitive("SIG_DFL"),
		capsensitive("SIG_SYS"),
		capsensitive("SIG_IGN"),
		capsensitive("SIG_ERR"),
		capsensitive("sigfunc_t") )
typedef void (*sigfunc_t)( int );

 SIG_SYS  =>   (sigfunc_t)0L
 SIG_DFL  =>   (sigfunc_t)-1L
 SIG_IGN  =>   (sigfunc_t)-2L
 SIG_ERR  =>   (sigfunc_t)-3L

Querverweis: \#raise\#, \#signal\#
\end

screen( capsensitive("FILE") )
Die FILE-Struktur in stdio.h beinhaltet die zur internen
Dateiverwaltung notwendigen Daten.
\end

screen( capsensitive("ldiv_t") )
Die Struktur ldiv_t ist in STDLIB.H definiert:

typedef struct
{
    long   quot; /* Quotient */
    long   rem;  /* Rest */
} ldiv_t;

Querverweis: \#div_t\#
\end

screen( capsensitive("fsm_component_t"),
		capsensitive("fsm_data_fpoint_t"),
		capsensitive("fsm_int"),
		capsensitive("fsm_fpoint_t") )
Die Strukturen fsm_int, fsm_fpoint_t, fsm_data_fpoint_t und
fsm_component_t sind in VDI.H definiert:

typedef struct
{
    int    value;
    int    remainder;

}   fsm_int;

typedef struct
{
    fsm_int    x;
    fsm_int    y;

}   fsm_fpoint_t;

typedef struct
{
    fsm_fpoint_t     pt;
    fsm_fpoint_t     cpt;
    fsm_int          sharp;

}   fsm_data_fpoint_t;

typedef struct fsm_component_t
{
    int                       resevered1;
    struct fsm_component_t    *nextComponent;
    unsigned char             numPoints;
    unsigned char             numCurves;
    unsigned char             numContours;
    unsigned char             reserved2[13];
    fsm_data_fpoint_f         *points;
    unsigned char             *startPts;

}   fsm_component_t;
\end

screen( capsensitive("Libraries") )
Die Bibliotheken im öberblick
----------------------------------------------------------------------

Der Programm-Code dieser Bibliotheksroutinen ist in den folgenden sieben
Bibliotheks-Dateien gespeichert:

˘ PCFLTLIB.LIB \#Gleitkomma-Befehle\#
  \#PC881LIB.LIB\#
˘ PCSTDLIB.LIB \#Standard-Funktionen\#
˘ PCEXTLIB.LIB \#Pure-C-Spezialfunktionen\#
˘ PCTOSLIB.LIB \#GEMDOS\#, \#BIOS\# und \#XBIOS\#
˘ PCGEMLIB.LIB \#GEM\#-Funktionen bestehend aus \#VDI\# und \#AES\#
˘ PCBGILIB.LIB \#BGI\#-Routinen

Querverweis:   \link("%%GLOBAL%%")ParameterÅbergabe\#  \#Startup\#
\end

screen( "PC881LIB.LIB" )
PC881LIB.LIB
----------------------------------------------------------------------

Die Bibliothek PC881LIB.LIB sollten Sie statt PCFLTLIB.LIB in Ihrer
Projektdatei angeben, wenn Sie zum öbersetzen Ihrer Programme in
den \link("%%GLOBAL%%")Compileroptionen\# den Schalter -8  Åbersetzen.
Dies macht jedoch nur Sinn, wenn Sie auf Ihrem Rechner eine FPU vom
Typ MC68881 oder MC68882 installiert haben und fÅr diese Code er-
zeugen wollen. Beachten Sie, da· dies nicht fÅr die Coprozessor-Karte
SFP004 von Atari gilt, da diese nicht Åber den Line-F-Emulator
angesteuert wird.
\end

screen( "Betriebssystem" )
TOS - Das Betriebssystem
----------------------------------------------------------------------

Das Atari-Betriebssystem ist in verschiedene Bereiche aufgeteilt. Zum
einen gibt es die grafische BenutzeroberflÑche \#GEM\#, mit \#AES\# und \#VDI\#,
zum andern aber auch die ØreinenÆ Betriebssystemfunktionen.
Diese Betriebssystemfunktionen sind wiederum in drei Bereiche aufge-
gliedert:

˘  \#GEMDOS\#
˘  \#XBIOS\#
˘  \#BIOS\#

\#GEMDOS\# ist der Kern des Betriebssystems. Es werden unter anderem
Funktionen zur Ein-/Ausgabe, Datei- und Speicherverwaltung bereitge-
stellt.
Im Grunde genommen gibt es fÅr einen Pure-C-Programmierer jedoch kaum
GrÅnde, auf diese Funktionen zurÅckzugreifen, da man nahezu alle
Funktionen auch unter Pure C zur VerfÅgung hat.
Im \#BIOS\# (Øbasic input output systemÆ) und \#XBIOS\# (Øextended basic input
output systemÆ) sind die hardware-abhÑngigen Funktionen enthalten.
WÑhrend die \#BIOS\#-Funktionen in erster Linie die zeichenweise Ausgabe
unterstÅtzen, sind im \#XBIOS\# vor allem die Funktionen fÅr die speziellen
GerÑte am Atari ST vom Diskettenlaufwerk bis hin zur MIDI-Schnittstelle
zusammengefaût.
\end

screen( "Startup",
		sensitive("PCXSTART"),
		sensitive("PCSTART") )
pcstart.o ist der Standard Startup Code. Es werden folgende Schritte
ausgefÅhrt:

1. Initialisierung der globalen Variablen \#_app\#, \#_BasPag\# und \#_PgmSize\#.
2. Freigeben des ÅberflÅssigen Speichers.
3. Testen, ob eine Coprozessorerweiterung installiert ist.
4. Initialisierung des \link("%%GLOBAL%%")envp\#-arrays, des \link("%%GLOBAL%%")argv\#-arrays und von \link("%%GLOBAL%%")argc\#.
5. Aufruf von \link("%%GLOBAL%%")main\#.
6. Deinitialisierung.
7. Programmende.

pcxstart.o ist eine Erweiterung des Standard Startup Codes.
ZusÑtzlich zu den oben genannten Schritten wird die Parameterliste
nach EintrÑgen, die mit den Zeichen < oder > beginnen durchsucht.
Bei einem Programm, das mit einem Parameter der Form <DATEINAME
aufgerufen wird, wird der Standardeingabekanal stdin zur Datei
DATEINAME umgeleitet. Wenn ein Parameter der Form >DATEINAME
erscheint, wird der Standardausgabekanal stdout zur Datei DATEINAME
umgeleitet.
\end

screen( capsensitive("_app") )
Name            Applikationflag

Deklaration:    extern int _app;
Deklaration in  aes.h

Beschreibung:   Diese Variable wird auf 0 gesetzt, wenn die
                Applikation als Deskaccessory gestartet wurde. Ein
                Wert ungleich 0 signalisiert, daû die Applikation als
                Programm gestartet wurde.
\end

screen( capsensitive("_PgmSize") )
Name            Programsize

Deklaration:    extern long _PgmSize;
Deklaration in  tos.h

Beschreibung:   Diese Variable enthÑlt die Grîûe der Applikation im
                Speicher. Sie benîtigen diesen Wert, wenn Sie z.B Ihr
                Programm resident im Speicher halten wollen. Rufen
                Sie dazu \#Ptermres\# mit diesem Wert auf.
\end

screen( capsensitive("BGI") )
Borland Graphics Interface

Die rund 70 Funktionen des Grafikpakets lassen sich in sieben
Kategorien unterteilen:

       \#Kontrolle\# (Laden von Grafiktreibern und ZeichensÑtzen,
                  Aktivierung)

       \#Zeichnen und FlÑchenfÅllung\#

       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildspeicher und Zeichenfenster\#

       \#grafische Textausgabe\#

       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#

       \#Fehlerbehandlung\#
\end

screen( capsensitive("Kontrolle") )
Kontrollfunktionen

Das Grafikpaket stellt die folgenden Funktionen zur
Initialisierung sowie der Aktivierung von Grafiktreibern und
ZeichensÑtzen zur VerfÅgung:

\#registerbgidriver\#       ØregistriertÆ einen als .O-Datei
                        eingebundenen Grafiktreiber
\#registerbgifont\#         ØregistriertÆ einen als .O-Datei
                        eingebundenen Vektor-Zeichensatz
\#installuserdriver\#       erlaubt die ØInstallationÆ von Grafiktreibern,
                        die nicht direkt von Borland erstellt wurden
\#installuserfont\#         erlaubt die ØInstallationÆ von Vektor-
                        ZeichensÑtzen, die nicht direkt von Borland
                        erstellt wurden
\#setgraphbufsize\#         setzt die Grî·e des internen Grafikpuffers

\#_graphgetmem\#            wird von allen Routinen des Grafikpakets benutzt,
                        die Speicherplatz auf dem Heap belegen, und kann
                        durch eine eigene Routine ersetzt werden
\#_graphfreemem\#           wird von allen Routinen des Grafikpakets benutzt,
                        die Speicherplatz auf dem Heap freigeben,
                        und kann durch eine eigene Routine ersetzt werden

\#detectgraph\#             prÅft die Hardware des Computers und legt fest,
                        welcher Grafiktreiber geladen bzw. welcher
                        Grafikmodus gesetzt werden soll
\#getmoderange\#            ermittelt, welche Grafikmodi fÅr einen gegebenen
                        Treiber verwendet werden kînnen
\#getmaxmode\#              ermittelt die Kennziffer des hîchsten Grafikmodus
                        fÅr Grafiktreiber, die nicht direkt von Borland
                        erstellt wurden
\#getmaxx\#                 liefert  die  maximal mîgliche X-Koordinate
                        des Bildschirms
\#getmaxy\#                 liefert  die  maximal mîgliche Y-Koordinate
                        des Bildschirms
\#getdrivername\#           liefert den Namen eines Grafiktreibers als
                        String zurÅck
\#getmodename\#             liefert den Namen eines Grafikmodus als String
                        zurÅck

\#initgraph\#               prÅft Åber einen Aufruf von detectgraph,
                        welcher Grafiktreiber geladen werden soll
                        bzw. verifiziert eine Vorgabe Åber getmoderange,
                        lÑdt den Grafiktreiber, schaltet in den
                        Grafikmodus um und initialisiert das Grafikpaket
                        via graphdefaults
\#graphdefaults\#           setzt alle Parameter des Grafikpakets wieder auf
                        ihre Standardvorgaben zurÅck
\#graphresult\#             liefert  den  Fehlerstatus  der letzten
                        Grafikoperation zurÅck
\#setgraphmode\#            setzt einen Grafikmodus
\#getgraphmode\#            ermittelt den momentan gesetzten Grafikmodus
\#restorecrtmode\#          schaltet von ØGrafikÆ auf ØTextÆ um
\#closegraph\#              gibt die fÅr Treiber, ZeichensÑtze und Puffer
                        belegten Bereiche auf dem Heap wieder frei und
                        schaltet danach via restorecrtmode wieder in den
                        Textmodus um
\end

screen( capsensitive("Zeichnen und FlÑchenfÅllung") )
Zeichnen und FlÑchenfÅllung

Das Grafikpaket definiert die folgenden Funktionen zum Zeichnen
grafischer Objekte und zur AusfÅllung von FlÑchen:

\#arc\#                     zeichnet ein KreisbogenstÅck
\#circle\#                  zeichnet einen Kreis
\#drawpoly\#                zeichnet den Umri· eines Polygons
\#ellipse\#                 zeichnet ein elliptisches KreisbogenstÅck
\#getarccoords\#            liefert die Koordinaten des letzten Aufrufs
                        von arc oder ellipse zurÅck und ermîglicht so
                        die Fortsetzung eines Kreisbogens mit anderen
                        geometrischen Elementen
\#getaspectratio\#          liefert einen Korrekturfaktor fÅr das physikalische
                        Hîhen-/SeitenverhÑltnis des Bildschirms, wird
                        fÅr Kreise automatisch benutzt
\#setaspectratio\#          erlaubt das direkte Setzen eines Korrekturfaktors
\#getlinesettings\#         liefert die momentane Linienart, das verwendete
                        Muster und die Dicke
\#line\#                    zeichnet eine Linie zwischen zwei angegebenen
                        Punkten
\#lineto\#                  zeichnet eine Linie von der momentanen Position
                        des Grafik-Cursors zu einem angegebenen Punkt
\#linerel\#                 zeichnet eine Linie relativ zur momentanen
                        Position des Grafik-Cursors
\#moveto\#                  setzt den Grafik-Cursor auf einen angegebenen Punkt
\#moverel\#                 bewegt den Grafik-Cursor relativ zu seiner
                        momentanen Position
\#rectangle\#               zeichnet ein Rechteck
\#setlinestyle\#           legt die Linienart, das Muster und die Dicke fest
\#setwritemode\#            legt fest, ob Linien den vorigen Inhalt des
                        Bildspeichers direkt Åberschreiben, oder ob eine
                        XOR-Funktion zum Linienzeichnen verwendet wird
\#bar\#                     zeichnet einen ausgefÅllten Balken
\#bar3d\#                   zeichnet einen ausgefÅllten, dreidimensionalen
                        Balken
\#fillellipse\#             zeichnet einen ausgefÅllten elliptischen Kreis
\#fillpoly\#                zeichnet ein ausgefÅlltes Polygon
\#floodfill\#              fÅllt eine umschlossene FlÑche
\#getfillpattern\#          liefert ein benutzerdefiniertes Muster zur
                        FlÑchenfÅllung zurÅck
\#getfillsettings\#         liefert die momentanen Parameter fÅr
                        FlÑchenfÅllungen zurÅck
\#pieslice\#                zeichnet ein ausgefÅlltes ØKuchenstÅckÆ
\#sector\#                  zeichnet ein ausgefÅlltes elliptisches ØKuchenstÅckÆ
\#setfillpattern\#          erlaubt beliebige Definitionen von FÅll-Mustern
\#setfillstyle\#            legt die Parameter fÅr FlÑchenfÅllungen fest

Alle Funktionen des Grafikpakets, die Linien zeichnen, verwenden die
durch setlinestyle vorgegebenen Parameter; alle Funktionen, die FlÑchen
ausfÅllen, benutzen die durch setfillstyle und setfillpattern
vorgegebenen Werte.
\end

screen( capsensitive("Zugriffe auf Bs u. Zf") )
Zugriffe auf den Bildspeicher und Zeichenfenster

Die folgenden Funktionen des Grafikpakets ermîglichen die direkte
Manipulation des Grafik-Bildspeichers:

\#cleardevice\#             lîscht den gesamten Grafikbildschirm unabhÑngig
                        von einem eventuell gesetzten Zeichenfenster
\#setactivepage\#           legt bei Video-Adaptern mit mehreren Bildspeicher-
                        Seiten fest, welche Seite durch folgende Aufrufe
                        von Grafikfunktionen bearbeitet wird, und
                        ermîglicht so Grafik-Operationen Øim HintergrundÆ
\#setvisualpage\#           wÑhlt bei Video-Adaptern mit mehreren Bildspeicher-
                        Seiten eine Speicherseite zur Anzeige auf dem
                        Bildschirm aus
\#clearviewport\#           lîscht den Inhalt des momentan gesetzten
                        Zeichenfensters und lÑ·t den restlichen
                        Grafikbildschirm unverÑndert
\#getviewsettings\#         liefert die absoluten Koordinaten des momentan
                        gesetzten Zeichenfensters zurÅck
\#setviewport\#             definiert einen rechteckigen Bereich des
                        Grafikbildschirms als Zeichenfenster
\#getimage\#                kopiert den Inhalt eines rechteckigen
                        Bildausschnitts in eine C-Puffervariable
\#imagesize\#               berechnet den Platzbedarf fÅr die Speicherung
                        von Bildausschnitten mit getimage
\#putimage\#                schreibt einen zuvor mit getimage gespeicherten
                        Bildausschnitt in den Grafik-Bildspeicher zurÅck,
                        wobei VerknÅpfungen mit dem momentanen Inhalt
                        des entsprechenden Bereichs mîglich sind
\#getpixel\#                liefert die Farbe eines Bildpunktes an den
                        angegebenen Koordinaten
\#putpixel\#                zeichnet einen einzelnen Bildpunkt an den
                        angegebenen Koordinaten in der angegebenen Farbe
\#getx\#                    liefert die  X-Koordinate des Grafik-Cursors
\#gety\#                    liefert die  Y-Koordinate des Grafik-Cursors
\end

screen( capsensitive("grafische Textausgabe") )
Funktionen zur Ausgabe von Text

Das Grafikpaket definiert die folgenden Funktionen zur Textausgabe:

\#gettextsettings\#         liefert die momentan gesetzten Parameter zurÅck
                        (Textart, Schreibrichtung, Vergrî·erungsfaktor
                        und Justierung)
\#outtext\#                 gibt einen String ab der momentanen Position
                        des Grafik-Cursors aus und verwendet dabei die
                        durch settextstyle gesetzten Parameter
\#outtextxy\#               gibt einen String ab dem angegebenen Punkt aus
\#settextjustify\#          setzt linksbÅndige, rechtsbÅndige oder zentrierte
                        Formatierung fÅr folgende Ausgaben mit outtext
                        und outtextxy
\#settextstyle\#            lÑdt einen Zeichensatz auf den Heap bzw.
                        aktiviert einen mit registerbgifont ØregistriertenÆ
                        Zeichensatz, legt die Schreibrichtung und den
                        Vergrî·erungsfaktor fest
\#setusercharsize\#         erlaubt die Skalierung von Textausgaben mit
                        voneinander unabhÑngigen Werten fÅr Hîhe und Breite
\#textheight\#              liefert den vertikalen Platzbedarf eines
                        Textstrings in Pixeln zurÅck
\#textwidth\#               liefert den horizontalen Platzbedarf eines
                        Textstrings zurÅck
Wenn die ØClipÆ-Funktion aktiviert ist (d.h. der fÅnfte Parameter von
setviewport einen Wert != 0 hat), dann schneiden outtext und outtextxy
Ausgaben an den Grenzen des Zeichenfensters ab. Bei nicht aktivierter
ØClipÆ-Funktion werden Ausgaben mit dem Standard-Zeichensatz vollstÑndig
unterdrÅckt, wenn sie die Grenzen des Zeichenfensters Åberschreiten;
Ausgaben mit Vektor-ZeichensÑtzen enden an den Grenzen des Bildschirms.
\end

screen( "Farbmanipulation und Farb-Pal" )
Bildschirmfarben

Das Grafikpaket definiert die folgenden Funktionen zur Festlegung von
Bildschirmfarben:

\#getbkcolor\#              liefert die momentan gesetzte Hintergrundfarbe
                        zurÅck
\#getcolor\#                liefert die momentan gesetzte Zeichenfarbe zurÅck
\#getmaxcolor\#             liefert die Øhîchste FarbnummerÆ fÅr den
                        momentan geladenen Grafiktreiber und den gesetzten
                        Modus
\#getpalette\#              liefert die EintrÑge der momentan gesetzten
                        Farb-Palette
\#getdefaultpalette\#       liefert einen Zeiger auf die Standard-
                        Farbpalette  fÅr   den  momentan  gesetzten
                        Grafikmodus zurÅck
\#getpalettesize\#          liefert die Grî·e der momentan gesetzten
                        Farb-Palette  zurÅck (d.h.  die Anzahl der
                        EintrÑge)
\#setallpalette\#           setzt sÑmtliche EintrÑge einer Farb-Palette neu
\#setbkcolor\#              setzt die Hintergrundfarbe
\#setcolor\#                setzt die Zeichenfarbe
\#setpalette\#              setzt einzelne EintrÑge einer Farb-Palette
\#setrgbpalette\#           setzt einzelne EintrÑge der Farb-Palette fÅr
                        den Grafik-Adapter 8514 von IBM
\end

screen( capsensitive("Fehlerbehandlung") )
Fehlerbehandlung

Das Grafikpaket definiert einen eigenen Statuscode, der durch
FlÑchenfÅllungen, Diskettenoperationen, die PrÅfung von Grafiktreibern,
ZeichensÑtzen und erlaubten Grafikmodi gesetzt wird. Die Funktion
graphresult liefert den momentanen Status zurÅck (und setzt den intern
gespeicherten Wert dabei automatisch auf 0), die Funktion grapherrormsg
liefert den zu einem Statuscode gehîrigen Text in Form eines Strings
zurÅck. PrÅfungen und die Ausgabe (englischer) Fehlermeldungen gestalten
sich deshalb recht einfach:

#include <graphics.h>
#include <stdio.h>
main()
{
    int graphdriver = DETECT, graphmode;
    initgraph(&graphdriver, &graphmode, "");
    if (graphdriver < 0)    /* Fehler! */
    { 
      puts(grapherrormsg(graphresult()));  /* Ausgabe der Meldung */
      exit(1);
    }
  /*   ..... */
}
\end

screen( capsensitive("arc") )
Name         ØarcÆ - zeichnet einen Kreisbogen.

Definition   void arc(int x, int y, int stangle, int endangle,
                      int radius);

Prototyp in  graphics.h

Beschreibung arc  zeichnet   einen  Kreisbogen  in  der  momentan
             gesetzten Zeichenfarbe  mit dem  Mittelpunkt  (x,y),
             wobei  stangle   den  Startpunkt  und  endangle  den
             Endpunkt des  mit radius gezogenen Bogens festlegen.
             Die Angabe  beider Winkel  erfolgt  in  Grad,  wobei
             entgegen dem  Uhrzeigersinn gezÑhlt  wird (0  Grad =
             horizontal  rechts  des  Mittelpunktes,  90  Grad  =
             senkrecht Åber dem Mittelpunkt usw).
Ergebnis     arc hat kein direktes Ergebnis.

Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
               int graphdriver = DETECT,   /* automatische */
                    graphmode;              /* Erkennung */
                struct arccoordstype arcinfo;
                int xasp,yasp;
                int centerx,centery,rsize;
                long ylong;

                initgraph(&graphdriver,&graphmode,"");

                centerx = getmaxx() / 2;  /* Mittelpunkte */
                centery = getmaxy() / 2;
                rsize = centery - 10;     /* Kreisradien */

                /* Ein KreisbogenstÅck mit
                   eingezeichneter Sehne */
                arc(centerx, centery, 0, 90, rsize);
                getarccoords(&arcinfo);
                line(arcinfo.xstart, arcinfo.ystart,
                     arcinfo.xend, arcinfo.yend);

                /* Ein Kreis und eine Ellipse */
                circle(centerx, centery, 100);
                ellipse(centerx, centery, 0, 360, 100, 50);

                /* Ein Kreis aus drei verschiedenfarbigen
                   KuchenstÅcken */
                setcolor(WHITE);
                setfillstyle(SOLID_FILL, LIGHTRED);
                pieslice(100, 100, 0, 135, 49);
                setfillstyle(SOLID_FILL, LIGHTBLUE);
                pieslice(100, 100, 135, 225, 49);
                setfillstyle(SOLID_FILL, WHITE);
                pieslice(100, 100, 225, 360, 49);

                getaspectratio(&xasp, &yasp);
                /* Ein Quadrat mit der Breite centerx
                   (halbe Breite des Bildschirms) */
                ylong = (long)centerx * (long)xasp / (long)yasp;
                rectangle(centerx / 2, centery - (int)ylong/2,
                          centerx + centerx / 2, centery +
                          (int)ylong/2);
                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#circle\#, \#ellipse\#, \#fillellipse\#,  \#pieslice\#, \#sector\#,
             \#getarccoords\#, \#getaspectratio\#, \#setaspectratio\#
\end

screen( capsensitive("bar") )
Name         ØbarÆ - zeichnet einen ausgefÅllten Balken.

Definition   void bar(int left, int top, int right, int bottom);

Prototyp in  graphics.h

Beschreibung bar zeichnet  ein gefÅlltes  Rechteck, dessen  obere
             linke Ecke  durch die  Koordinaten (left,  top)  und
             dessen untere  rechte  Ecke  durch  die  Koordinaten
             (right, bottom)  festgelegt ist.  Verwendet wird die
             momentan  gesetzte  Zeichenfarbe,  sowie  das  durch
             \#setfillstyle\#    bzw.   \#setfillpattern\#    definierte
             FÅllmuster. Einen  Umri· zeichnet  \#bar\# nicht  - dazu
             konnen Sie \#bar3d\# mit depth = 0 verwenden.
Ergebnis     bar  hat   kein  direktes   Funktionsergebnis.   Ein
             eventuell   aufgetretener    Fehler   kann   mittels
             \#graphresult\# erfragt werden.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  
                int graphdriver = DETECT, /* automatische */
                               graphmode;  /* Erkennung */
                int i, width = 20;  /* Breite */

                initgraph(&graphdriver,&graphmode,"");

                 /* Eine absteigende Treppe */
                 for (i = 1; i < 10; i++)
                   bar(i*width,i*10,(i+1)*(width+1), 200);
                getch(); clearviewport();
                setfillstyle(LTSLASH_FILL,LIGHTRED);
                bar3d(10,10,60,60,12,1);  /* mit "Deckel" */
                bar3d(10,80,180,130,40,1);
                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#rectangle\#, \#setcolor\#, \#setfillstyle\#, \#bar3d\#
\end

screen( capsensitive("bar3d") )
Name         Øbar     3-dimensionalÆ     -     zeichnet     einen
             dreidimensionalen, ausgefÅllten Balken.

Definition   void bar3d(int left, int top, int right, int bottom,
                        int depth, int topflag);

Prototyp in  graphics.h

Beschreibung Balken,  die   mit  bar3d  gezeichnet  wurden,  sind
             ØdreidimensionalÆ und  bestehen aus  einem gefÅllten
             Rechteck, dessen  Ecken durch  die  Koordinatenpaare
             (left, top)  und (right,  bottom) festgelegt werden.
             bar3d zeichnet  zuerst die  Umri·linien in der durch
             \#setcolor\# gesetzten  Farbe und  der mit  \#setlinestyle\#
             festgelegten Linienart,  danach fÅllt  die  Funktion
             die umschlossene  FlÑche (wie  \#bar\#) mit dem momentan
             gÅltigen FÅll-muster aus.
             öber den  Parameter depth  lÑ·t sich die rÑumliche
             Tiefe (in  Pixel) bestimmen,  die typischerweise bei
             rund 25% der Breite liegt:
             bar3d(left, top, right, bottom, (right-left) / 4,
             1);
             Der Parameter  topflag legt  fest,  ob  bar3d  einen
             oberen Abschlu·  des  Balkens  zeichnet  (topflag=1)
             oder nicht  (topflag=0) -  im letzteren  Fall lassen
             sich mehrere Balken Åbereinanderstapeln.
Ergebnis     bar3d  hat   kein  direktes  Funktionsergebnis.  Ein
             eventuell   aufgetretener    Fehler   kann   mittels
             \#graphresult\# erfragt werden.
Beispiel     siehe bar
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#rectangle\#, \#setcolor\#, \#setfillstyle\#, \#bar\#
\end

screen( capsensitive("circle") )
Name         ØcircleÆ - zeichnet einen Kreis.
Definition   void circle(int x, int y, int radius);

Prototyp in  graphics.h

Beschreibung circle  zeichnet   einen  Kreis   in  der   momentan
             gesetzten  Zeichenfarbe   mit   dem   durch   radius
             gegebenen   Radius   um   den   Mittelpunkt   (x,y),
             entspricht also  \#arc\# mit  stangle = 0 und endangle =
             360.
Ergebnis     circle hat kein Ergebnis.
Beispiel     siehe \#arc\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#circle\#, \#ellipse\#,   \#fillellipse\#,  \#pieslice\#,  \#sector\#,
             \#getarccoords\#
\end

screen( capsensitive("cleardevice") )
Name         Øclear deviceÆ - lîscht den Grafikbildschirm.
Definition   void cleardevice(void);

Prototyp in  graphics.h

Beschreibung cleardevice lîscht den gesamten Grafikbildschirm.
             Danach wird  der Grafik-Cursor auf den (relativen)
             Ursprung (0,0),  d.h. in  die linke  obere Ecke  des
             Bildschirms gesetzt.
Ergebnis     cleardevice liefert keinen Wert zurÅck.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setviewport\#, \#clearviewport\#
\end

screen( capsensitive("clearviewport") )
Name         Øclear viewportÆ  - lîscht  den Inhalt  des momentan
             gesetzten Zeichenfensters.

Definition   void clearviewport(void);

Prototyp in  graphics.h

Beschreibung clearviewport  lîscht   den  Inhalt   des   momentan
             gesetzten Zeichenfensters.
             Hinweis:  Das   Zeichenfenster  selbst   (gesetzte
             Grenzen und Clip-Funktion) bleibt unverÑndert.
Ergebnis     clearviewport liefern keinen Wert zurÅck.
PortabilitÑt Die Funktion  ist lauffÑhig  auf allen Systemen, die
             BGI unterstÅzten.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setviewport\#, \#cleardevice\#
\end

screen( capsensitive("closegraph") )
Name         Øclose graphicsÆ - beendet die Grafikausgabe.

Definition   void closegraph(void);

Prototyp in  graphics.h

Beschreibung closegraph  beendet die Ausgabe von Graphik mittels
             des BGI.
PortabilitÑt Auf allen  Systemen, die BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#
\end

screen( capsensitive("detectgraph") )
Name         Ødetect graphics  adapterÆ -  prÅft die Hardware des
             Computers  und   bestimmt,   welcher   Grafiktreiber
             geladen und welcher Grafikmodus gesetzt werden soll.

Definition   void detectgraph(int *graphdriver, int *graphmode);

Prototyp in  graphics.h

Beschreibung Nachdem es  unter TOS  nur einen Grafiktreiber gibt,
             bleibt  der   Wert  fÅr   den  Grafiktreiber   immer
             konstant.  Der   Grafikmodus,  der  von  detectgraph
             gesetzt    werden     soll,    hÑngt     von     der
             Hardwareausstattung   ab.   Bei   einem   Monochrom-
             Bildschirm   wird   die   hohe   Bildschirmauflîsung
             unterstÅtzt,  bei  einem  Farbmonitor  gibt  es  die
             Auswahl zwischen  der niedrigen  und  der  mittleren
             Bildschirmauflîsung.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#
\end

screen( capsensitive("drawpoly") )
Name         Ødraw polygonÆ - zeichnet einen Polygonzug.

Definition   void drawpoly(int numpoints, int *polypoints);

Prototyp in  graphics.h

Beschreibung drawpoly zeichnet  einen  Polygonzug  mit  numpoints
             Eckpunkten in der momentan gesetzten Linienart und -
             farbe. Der  als polypoints Åbergebene Zeiger mu· auf
             eine Folge  von Koordinatenpaaren  zeigen (ein Array
             mit numpoints * 2 Elementen, siehe ØBeispielÆ).
             Hinweis:   drawpoly   beginnt   mit   dem   ersten
             angegebenen Punkt  und zieht von dort aus eine Linie
             zum zweiten,  von da  zum dritten  usw. Zum Zeichnen
             einer  geschlossenen  Figur  mit  n  Eckpunkten  mu·
             polypoints n+1 Koordinatenpaare enthalten, wobei das
             letzte Paar dieselben Werte wie das erste Paar hat.
Ergebnis     drawpoly liefern keinen Wert zurÅck.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
                int graphdriver = DETECT,    /* automatische */
                                 graphmode;  /* Erkennung */

                /* Dreieck (1. = letzter Eckpunkt) */
                int triangle[] = { 50, 100, 100, 100, 150, 150,
                                   50, 100 };

                initgraph(&graphdriver,&graphmode,"");

                drawpoly(4,triangle);   /* zeichnet ein Dreieck */
                getch(); clearviewport();

                setfillstyle(SOLID_FILL, LIGHTGREEN);
                fillpoly(3,triangle);  /* 4. Punkt unnîtig */

                getch();
                closegraph();
             }
PortabilitÑt Die Funktion  ist lauffÑhig  auf allen Systemen, die
             BGI unterstÅzten.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getfillsettings\#,       \#fillpoly\#,       \#setfillstyle\#,
             \#setfillpattern\#
\end

screen( capsensitive("ellipse") )
Name         ØellipseÆ    -     zeichnet    einen    elliptischen
             Kreisausschnitt.

Definition   void  ellipse(int   x,  int   y,  int  stangle,
                           int endangle, int xradius, int yradius);

Prototyp in  graphics.h

Beschreibung ellipse zeichnet  einen elliptischen  Kreisbogen  in
             der momentan  gesetzten  Zeichenfarbe  um  den  Mit-
             telpunkt (x,y)  mit den  Radien xradius (horizontal)
             und yradius  (vertikal). stangle  und endangle legen
             in derselben  Weise wie  bei \#arc\#  den Anfangs-  bzw.
             Endpunkt des Kreisbogens fest.
Ergebnis     ellipse hat kein Ergebnis.
Beispiel     siehe \#arc\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#,   \#circle\#,    \#fillellipse\#,   \#pieslice\#,   \#sector\#,
             \#getarccoords\#
\end

screen( capsensitive("fillellipse") )
Name         Øfill  ellipseÆ   -  zeichnet   einen   ausgefÅllten
             elliptischen Kreis.

Definition   void fillellipse(int  x, int  y,  int  xradius,
                              int yradius);

Prototyp in  graphics.h

Beschreibung fillellipse zeichnet einen elliptischen Vollkreis in
             der momentan gesetzten Zeichenfarbe (wie ellipse mit
             stangle =  0 und endangle = 360), danach fÅllt diese
             Funktion  den   entstandenen  Kreis  mit  dem  durch
             \#setfillpattern\# bzw. \#setfillstyle\# festgelegten Muster
             und der dort angegebenen Farbe aus.
Ergebnis     fillellipse hat kein direktes Ergebnis. Wenn wÑhrend
             der AusfÅhrung ein Fehler auftritt, liefert der
             nÑchste Aufruf von \#graphresult\# den Wert grNoScanMem
Beispiel     siehe \#arc\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#, \#circle\#, \#ellipse\#, \#pieslice\#, \#sector\#, \#getarccoords\#
\end

screen( capsensitive("fillpoly") )
Name         Øfill polygonÆ - zeichnet ein ausgefÅlltes Polygon.

Definition   void fillpoly(int numpoints, int *polypoints);

Prototyp in  graphics.h

Beschreibung fillpoly  erwartet  als  Pa4rameter  die  Anzhal  an
             Koordinatenpaaren in  numpoints und  die Koordinaten
             selbst im Feld polypoints, das 2* numpoints Elemente
             hat. ZunÑchst  wird der  durch die  Koordinatenpaare
             festgelegt Polygonzug  gezeichnet, danach  wird  die
             FlÑchem   mit    dem   durch    \#setfillstyle\#    bzw.
             \#setfillpattern\# gesetzten Muster gefÅllt.
Ergebnis     fillpoly liefern  keinen Wert  zurÅck. Wenn  wÑhrend
             des AusfÅllens  ein  Fehler  auftritt,  liefert  der
             nÑchste  Aufruf   von   \#graphresult\#   das   Ergebnis
             grNoScanMem.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
                int graphdriver = DETECT,    /* automatische */
                                 graphmode;  /* Erkennung */

                /* Dreieck (1. = letzter Eckpunkt) */
                int triangle[] = { 50, 100, 100, 100, 150, 150,
                                   50, 100 };

                initgraph(&graphdriver,&graphmode,"");

                drawpoly(4,triangle);   /* zeichnet ein Dreieck */
                getch(); clearviewport();

                setfillstyle(SOLID_FILL, LIGHTGREEN);
                fillpoly(3,triangle);  /* 4. Punkt unnîtig */

                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen, die BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getfillsettings\#,      \#drawpoly\#,      \#setfillstyle\#,
             \#setfillpattern\#
\end

screen( capsensitive("floodfill") )
Name         Øflood fillÆ - fÅllt einen umschlossenen Bereich mit
             dem momentan gesetzten FÅll-Muster.

Definition   void floodfill(int x, int y, int border);

Prototyp in  graphics.h

Beschreibung floodfill arbeitet  im Gegensatz  zu  \#fillpoly\#  bit-
             orientiert:   ausgehend    von   dem   durch   (x,y)
             angegebenen  Punkt   wird  der  Bildschirm  in  alle
             Richtungen ØgeflutetÆ,  wobei  das  Erreichen  eines
             Pixels mit  der Farbe  border die  Operation in  der
             jeweiligen Richtung abbricht.
             Wenn sich  der Punkt  (x,y) innerhalb einer FlÑche
             befindet,  die   mit   Linien   der   Farbe   border
             umschlossen  ist,   fÅllt  floodfill  diese  FlÑche.
             Befindet sich  (x,y) au·erhalb  dieser FlÑche,  dann
             wird der  restliche Bildschirm  (bzw. das  restliche
             Zeichenfenster)  gefÅllt,  die  umschlossene  FlÑche
             bleibt frei.
Ergebnis     floodfill liefert  keinen Wert  zurÅck. Wenn wÑhrend
             des FlÑchenfÅllens  ein Fehler auftritt, liefert ein
             nachfolgender Aufruf  von \#graphresult\#  das  Ergebnis
             grNoFloodMem.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT,     /* automatische */
                                  graphmode;  /* Erkennung */
                initgraph(&graphdriver,&graphmode,"");

                setcolor(RED);  /* ein rotes Dreieck */
                moveto(10,10); lineto(100,10);
                lineto(50,100); lineto(10,10);
                getch();

                floodfill(30,30,RED);  /* fÅllt das Dreieck */
                getch();

                floodfill(100,100,RED); /* fÅllt den restlichen */
                getch();                /* Bildschirm */

                closegraph();
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#fillpoly\#, \#graphresult\#
\end

screen( capsensitive("getarccoords") )
Name         Øget arc  coordinatesÆ -  ermittelt die  Koordinaten
             des letzten Aufrufs von \#arc\#.

Definition   void getarccoords(struct arccoordstype *arccoords);

Prototyp in  graphics.h

Beschreibung getarccoords liefert  die Daten  des letzten Aufrufs
             von \#arc\#  in einer  Struktur des  Typs  arccoordstype
             zurÅck, die  in graphics.h  folgenderma·en definiert
             ist:

             struct arccoordstype
                    { int x,y;              /* Mittelpunkt */
                      int xstart, ystart,   /* Startpunkt */
                          xend, yend;       /* Endpunkt */
                    };
             NÅtzlich ist  getarccoords beispielweise  dann, wenn
             ein Kreisbogen  mit einer  Linie oder  einem anderen
             geometrischen Element fortgesetzt werden soll.
Ergebnis     getarccords hat kein Ergebnis.
Beispiel     siehe \#arc\#
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#, \#circle\#, \#ellipse\#, \#fillellipse\#, \#pieslice\#, \#sector\#
\end

screen( capsensitive("getaspectratio") )
Name         Øget aspect  ratioÆ -  ermittelt  das  physikalische
             Hîhen-/ SeitenverhÑltnis des Bildschirms.

Definition   void getaspectratio(int *xasp, int *yasp);

Prototyp in  graphics.h

Beschreibung Der Faktor von aspectratio ist immer 1, da man unter
             TOS  nur   das  SeitenverhÑltnis,   nicht  aber  das
             HîhenverhÑltnis explizit einstellen kann.
Ergebnis     getaspectratio hat kein Ergebnis.
PortabilitÑt Auf allen  Systemen,  die  BGI  unterstÅtzen,  ist
             diese Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#setaspectratio\#
\end

screen( capsensitive("getbkcolor") )
Name         Øget  background   colorÆ  -  liefert  die  momentan
             gesetzte Hintergrundfarbe im Grafikmodus zurÅck.

Definition   int getbkcolor(void);

Prototyp in  graphics.h

Beschreibung getbkcolor liefert  den Inhalt  des ersten  Eintrags
             der momentan gesetzten Farbpalette. FÅr das Ergebnis
             von getbkcolor  sind  die  folgenden  Konstanten  in
             graphics.h als enum definiert:

             Wert  Name      Wert  Name
             --------------------------------------------------------
             0     BLACK      8    DARKGRAY
             1     BLUE       9    LIGHTBLUE
             2     GREEN     10    LIGHTGREEN
             3     CYAN      11    LIGHTCYAN
             4     RED       12    LIGHTRED
             5     MAGENTA   13    LIGHTMAGENTA
             6     BROWN     14    YELLOW
             7     LIGHTGRAY 15    WHITE
             --------------------------------------------------------
Ergebnis     getbkcolor liefert  einen Wert  zwischen  0  und  15
             zurÅck.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int color;
                initgraph(&graphdriver,&graphmode,"");

                /* Linien mit gleichbleibender Farbe und
                   wechselndem Hintergrund */
                while (!kbhit())
                 { color = getbkcolor();
                   if (++color > getmaxcolor())  color = 0;
                   setbkcolor(color);
                   lineto(rand() % (getmaxx() + 1),
                      rand() % (getmaxy() + 1));
                   delay(100);
                  }

                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist zu allen Systemen kompatibel, die
             BGI unterstÅtzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getpalette\#, \#initgraph\#, \#setbkcolor\#
\end

screen( capsensitive("getcolor") )
Name         Øget colorÆ  - liefert die momentan gesetzte Grafik-
             Zeichenfarbe zurÅck.

Definition   int getcolor(void);

Prototyp in  graphics.h

Beschreibung getcolor liefert  die Nummer  des  Eintrags  in  der
             Farbpalette, der  momentan als  Zeichenfarbe benutzt
             wird. Der  Wert  0  als  Funktionsergebnis  bedeutet
             also, da·  die  Grafikroutinen  den  ersten  Eintrag
             verwenden -  welche Farbe  dies letztlich ist, hÑngt
             vom Wert dieses Eintrags ab.
             Ein Beispiel: In der mittlere Auflîsung (STMEDIUM)
             enthÑlt die Farb-Palette die vier EintrÑge BLACK(0),
             BLUE(1), GREEN(2)  und CYAN(3).  Wenn  getcolor  den
             Wert 1  zurÅckliefert, wird  BLUE  als  Zeichenfarbe
             benutzt.
             Solange nicht  mit setcolor  ein anderer Paletten-
             Eintrag als Zeichenfarbe gesetzt wird, verwenden die
             Grafikroutinen den  hîchsten Eintrag:  getcolor  hat
             direkt nach  dem  Start  der  Grafik  im  Modus  der
             mittleren Auflîsung  das Ergebnis  3.  AbhÑngig  vom
             verwendeten Grafikmodus  sind Ergebnisse  im Bereich
             von 0..15 mîglich.
Ergebnis     getcolor liefert  die Nummer  des Paletten-Eintrags,
             der momentan als Zeichenfarbe gesetzt ist.
Beispiel     #include <graphics.h>
             #include <stdlib.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int color;

                initgraph(&graphdriver,&graphmode,"");

                /* Linien mit wechselnder Farbe und
                   gleichbleibendem Hintergrund */
                while (!kbhit())
                 { color = getcolor();
                   if (++color > getmaxcolor())   color = 0;
                   setcolor(color);
                   lineto(random(getmaxx()) + 1),
                          random(getmaxy() + 1));
                  }
                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen, die BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getpalette\#, \#getmaxcolor\#, \#setcolor\#
\end

screen( capsensitive("getdefaultpalette") )
Name         Øget default paletteÆ - liefert einen Zeiger auf die
             Standard-Farbpalette  fÅr   den  momentan  gesetzten
             Grafikmodus zurÅck.

Definition   void *getdefaultpalette(void);

Prototyp in  graphics.h

Beschreibung getdefaultpalette liefert einen Zeiger auf die Farb-
             Palette zurÅck,  die  bei  der  Initialisierung  des
             Treibers (via  \#initgraph\# bzw.  \#setgraphmode\#) gesetzt
             war.
             colornum hat einen zulÑssigen Bereich von 0..512 und
             legt die  Nummer des Farb-Eintrags fest, dessen Wert
             sich  aus   den  Komponenten  red,  green  und  blue
             zusammensetzt.
Ergebnis     getdefaultpalette liefert kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                struct palettetype palette;
                int x,y;

                initgraph(&graphdriver, &graphmode, "");

                getpalette(&palette);
                for (x = 0; x <10; x++)  /* 10 Balken
                                            nebeneinander */
                  { setfillstyle(x, (x % 4) + 1);
                    bar(x * 60, 20, (x+1) * 60, 200);
                  }

                while (!kbhit())
                 { setpalette(rand() % palette.size, rand() %
                 64);
                   delay(300);  /* bunter Farbwechsel */
                 }

                /* Farb-Palette zurÅck aufs Original */
                setallpalette(getdefaultpalette());

                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist zu allen Systemen kompatibel, die
             BGI unterstÅtzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#,   \#getcolor\#,    \#getpalette\#,   \#setpalette\#,
             \#setallpalette\#
\end

screen( capsensitive("getdrivername") )
Name         Øget  driver   nameÆ  -   liefert  den   Namen   des
             Grafiktreibers.

Definition   char *getdrivername(void);

Prototyp in  graphics.h

Beschreibung getdrivername kann  nur nach der Initialisierung des
             Grafikpakets mit  initgraph  verwendet  werden.  Die
             Funktion liefert  den Namen  des Grafiktreibers, der
             durch \#initgraph\# aktiviert wurde.
Ergebnis     getdrivername liefert  einen Zeiger auf einen String
             zurÅck.
Gruppe       \#Kontrolle\#
PortabilitÑt Diese Funktion ist zu allen Systemen kompatibel, die
             BGI unterstÅtzen.
\end

screen( capsensitive("getfillpattern") )
Name         Øget fill  patternÆ  -  ermittelt  das  zuletzt  mit
             \#setfillpattern\#      gesetzte      Bitmuster      fÅr
             FlÑchenfÅllungen.

Definition   void getfillpattern(char *pattern);

Prototyp in  graphics.h

Beschreibung getfillpattern ermittelt  das festgelegte Muster und
             die Zeichenfarbe  fÅr die  Aufrufe von  \#fillellipse\#,
             \#fillpoly\#,  \#floodfill\#,   \#bar\#,   \#bar3d\#,   \#sector\#   und
             \#pieslice\#.
             pattern ist ein Zeiger auf eine Folge von 8 Bytes,
             bei dem  jedes Bit  fÅr ein Pixel in der durch color
             festgelegten  Farbe  steht.  Jedes  Byte  legt  acht
             nebeneinanderliegende Punkte  einer  Bildschirmzeile
             fest,  die   Bytes   selbst   sind   ØuntereinanderÆ
             angeordnet. Ein  Schachbrettmuster mit der Graustufe
             0.5 ist beispielsweise folgenderma·en definiert:
               char gray50[8] =
                 { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55
                 };
Ergebnis     getfillpattern hat kein direktes Ergebnis.
Beispiel     siehe getfillsettings
PortabilitÑt Auf allen  Systemen, die BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getfillsettings\#, \#setfillpattern\#
\end

screen( capsensitive("getfillsettings") )
Name         Øget  fill   settingsÆ  -  liefert  Daten  Åber  das
             momentan   gesetzte    FÅllmuster   und    die   fÅr
             FlÑchenfÅllungen verwendete Farbe.

Definition   void getfillsettings(struct fillsettingstype *fillinfo);

Prototyp in  graphics.h

Beschreibung getfillsettings ermittelt die Åber setfillstyle bzw.
             \#setfillpattern\# gesetzten  Parameter und  liefert sie
             in der als fillinfo Åbergebenen Struktur zurÅck. Der
             Datentypen  fillsetttingstype   ist  in   graphics.h
             folgenderma·en definiert:
             struct fillsettingstype
              { int pattern;     /* Nummer des momentan gesetzten
                                    Musters */
                int color;       /* Farbe (0..15) */
              };
             FÅr  pattern   sind  in   graphics.h  die  folgenden
             Bitmuster definiert:

             Name               Wert  Beschreibung
             --------------------------------------------------------
             EMPTY_FILL         0     FÅllen mit der Hintergrundfarbe
             SOLID_FILL         1     FÅllen mit der Farbe color
             LINE_FILL          2     ----------
             LTSLASH_FILL       3     //////////
             SLASH_FILL         4     //////////  mit dicken Linien
             BKSLASH_FILL       5     \\\\\\\\\\  mit dicken Linien
             LTBKSLASH_FILL     6     \\\\\\\\\\
             HATCH_FILL         7     leicht schraffiert
             XHATCH_FILL        8     stark schraffiert, Åberkreuzend
             INTERLEAVE_FILL    9     abwechselnde Linien
             WIDEDOT_FILL      10     Punkte, weit auseinander
             CLOSEDOT_FILL     11     Punkte, dicht nebeneinander
             USER_FILL         12     benutzerdefiniert
             --------------------------------------------------------
Ergebnis     getfillsettings hat kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT; /* automatische */
                int graphmode;              /* Erkennung */
                struct fillsettingstype save;
                char savepattern[8];
                char checkboard[] = { 0x0F, 0xF0, 0x0F, 0xF0,
                                      0x0F, 0xF0, 0x0F, 0xF0 };

                initgraph(&graphdriver, &graphmode, "");

                /* momentan gesetztes Muster ermitteln */
                getfillsettings(&save);
                                      /* Muster speichern */
                if (save.pattern == USER_FILL)
                                      /* benutzerdefiniert? */
                  getfillpattern(savepattern);
                                      /* -ja, Bitmuster lesen */
                setfillstyle(SLASH_FILL, BLUE);
                                      /* /////, blau */
                bar (0,0,100,100);    /* Balken zeichnen */

                setfillpattern(checkboard, YELLOW);
                                      /* eigenes Muster */
                bar (100,100,200,200);
                                      /* noch ein Balken */

                /* und das alte Muster wieder setzen */
                if (save.pattern == USER_FILL)
                  setfillpattern(savepattern, save.color);
                 else
                  setfillstyle(save.pattern, save.color);

                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#,    \#fillpoly\#,     \#floodfill\#,     \#getfillpattern\#,
             \#setfillstyle\#
\end

screen( capsensitive("getgraphmode") )
Name         Øget  graphics   modeÆ  -   Liefert  den  Modus  der
             Grafikauflîsung.

Definition   int getgraphmode(void);

Prototyp in  graphics.h

Beschreibung Bei  Monochrommonitoren   wird   grundsÑtzlich   ein
             konstantes Ergebnis  2 zurÅckgegeben,  da es hierfÅr
             nur  einen  Auflîsungsmodus  gibt  (hohe  Auflîsung,
             STHIGH 640x400).
             Bei Farbmonitoren  liefert getgraphmode ein Ergebnis
             im Teilbereich  zwischen  0..1  zurÅck,  0  fÅr  die
             niedrige  Auflîsung   (STLOW  300x200),  1  fÅr  die
             Mittlere (STMEDIUM 640x200).
Ergebnis     getgraphmode liefert die Nummer des momentan
             gesetzten Grafikmodus zurÅck.
Beispiel       currentmode = getgraphmode();  /* momentaner Modus
                                                 (int) */
               restorecrtmode();  /* Textmodus setzen */
               ...
               setgraphmode(currentmode);  /* zurÅck zur Grafik */
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#setgraphmode\#
\end

screen( capsensitive("getimage") )
Name         Øget   imageÆ    -   kopiert    einen   rechteckigen
             Bildausschnitt in einen Puffer.

Definition   void getimage(int  left, int  top,  int  right,
                           int bottom, void *bitmap);

Prototyp in  graphics.h

Beschreibung getimage kopiert  einen rechteckigen Bildausschnitt,
             dessen linke obere Ecke durch (left, top) und dessen
             rechte untere  Ecke durch (right, bottom) festgelegt
             ist, in  den durch bitmap spezifizierten Buffer. Die
             ersten beiden  16-Bit-Worte von  bitmap sind fÅr die
             Breite   und    Hîhe   des   kopierten   Ausschnitts
             reserviert:
             breite = right - left + 1;
             hoehe = bottom - top + 1;
             bitmap  mu·   also  vier  Bytes  mehr  Speicherplatz
             bieten, als fÅr die eigentlichen Bilddaten gebraucht
             wird.

Ergebnis     getimage hat kein direktes Funktionsergebnis.

Beispiel     #include <stdlib.h>
             #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int maxx, x;
                unsigned long picsize;    /* Bildgrî·e */
                void * picptr;       /* Zeiger fÅr den
                                        Bildausschnitt */

                initgraph(&graphdriver, &graphmode, "");
                maxx = getmaxx() / 4;    /* 1/4 des Schirms */

                for (x= 0; x<100; x++)  /* ein paar bunte Linien */
                 { setcolor(rand() % (getmaxcolor() + 1));
                   lineto(rand() % maxx, rand() % getmaxy());
                 }
                getch();
                           /* Bild "einfangen" */
                picsize = imagesize(0,0,maxx,getmaxy());
                                           /* Grî·e */
                picptr = malloc(picsize);  /* Speicherplatz */
                getimage(0,0,maxx,getmaxy(),picptr); /* Kopie */

                for (x = 1; x < 4; x++)  /* und drei Kopien davon */
                  putimage (x * maxx, 0, picptr, COPY_PUT);
                getch();
                closegraph();
             }

PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.

Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#

Querverweis  \#imagesize\#, \#putimage\#
\end

screen( capsensitive("getlinesettings") )
Name         Øget  line  settingsÆ  -  ermittelt  die  durch  den
             letzten Aufruf von \#setlinestyle\# gesetzten Parameter.

Definition   void getlinesettings(struct linesettingstype
                                         *lineinfo);

Prototyp in  graphics.h

Beschreibung getlinesettings  ermittelt   die  momentan  gesetzte
             Linienart,  das   verwendete   Muster,   sowie   die
             Liniendicke und  speichert die Ergebnisse in der als
             lineinfo    Åbergebenen     Variablen.    Der    Typ
             linesettingstype ist  in  graphics.h  folgenderma·en
             definiert:
             struct linesettingstype
              { int linestyle;       /* durchgezogen, gepunktet... */
                unsigned upattern;   /* "user pattern" */
                int thickness;       /* Dicke - 1 oder 3 Pixel */
              };
             FÅr die  Linienart (linestyle)  definiert graphics.h
             mehrere Konstanten:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             SOLID_LINE    0     durchgezogen
             DOTTED_LINE   1     gepunktet
             CENTER_LINE   2     Punkt Strich Punkt Strich...
             DASHED_LINE   3     gestrichelt
             USERBIT_LINE  4     benutzerdefiniert
             --------------------------------------------------------
             FÅr die  Dicke einer Linie (thickness) sind nur zwei
             Werte mîglich, die ebenfalls in graphics.h definiert
             sind:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             NORM_WIDTH    1normale Dicke (1 Pixel)
             THICK_WIDTH   3ØdickeÆ Dicke (3 Pixel)
             --------------------------------------------------------
Ergebnis     getlinesettings hat kein direktes Ergebnis.
Beispiel     struct linesettingstype save;
             int lkind, lpattern, lthickness;
             ...
             getlinesettings(&save);
             lkind      = save.linestyle;   /* Linienart (1..12) */
             lpattern   = save.pattern;     /* Bitmuster */
             lthickness = save.thickness;   /* Dicke (1 oder 3) */
             ...
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#setlinestyle\#, \#setwritemode\#
\end

screen( capsensitive("getmaxcolor") )
Name         Øget   maximum   colorÆ   -   liefert   die   Anzahl
             verwendbarer Farben zurÅck.

Definition   int getmaxcolor(void);

Prototyp in  graphics.h

Beschreibung getmaxcolor liefert  die Anzahl  der Farben,  die im
             momentan  gesetzten   Grafikmodus  verwendet  werden
             kînnen.
Ergebnis     Der zurÅckgelieferte  Wert entspricht  der Grî·e der
             Farb-Palette minus 1.
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getcolor\#, \#getpalette\#
\end

screen( capsensitive("getmaxmode") )
Name         Øget maximum  graphics modeÆ  - liefert  die  Anzahl
             verfÅgbarer Grafikmodi.

Definition   int getmaxmode(void);

Prototyp in  graphics.h

Beschreibung getmaxmode ermittelt  den maximal mîglichen Wert fÅr
             graphmode (der normalerweise fÅr den Grafikmodus mit
             der hîchsten Auflîsung steht).
Ergebnis     ZurÅckgeliefert wird  ein Integer-Wert grî·er gleich
             0.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
\end

screen( capsensitive("getmaxx") )
Name         Øget maximum  x coordinateÆ  - liefert  die  maximal
             mîgliche X-Koordinate des Bildschirms.

Definition   int getmaxx(void);

Prototyp in  graphics.h

Beschreibung getmaxx liefert  die maximal  mîgliche  X-Koordinate
             des Bildschirms  zurÅck, d.h.  die X-Koordinate  des
             rechten Bildschirmrandes.  Das  Ergebnis  hÑngt  vom
             verwendeten Grafikmodus ab.
             Ergebnis ist  vom momentan verwendeten Grafikmodus
             abhÑngig.
             getmaxx  und   \#getmaxy\#  ermîglichen,  ein  Grafik-
             Programm unabhÑngig  von der Auflîsung zu schreiben.
             Diese  beiden   Funktionen   sollten   grundsÑtzlich
             anstelle von Konstanten verwendet werden.
Ergebnis     getmaxx   liefert  fÅr  die  momentan  definierten
             Grafiktreiber Ergebnisse im Bereich von 319..1023.
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getviewsettings\#, \#getmaxy\#
\end

screen( capsensitive("getmaxy") )
Name         Øget maximum  y [coordinate]Æ  - liefert die maximal
             mîgliche Y-Koordinate des Bildschirms.

Definition   int getmaxy(void);

Prototyp in  graphics.h

Beschreibung getmaxy liefert  die maximal  mîgliche  Y-Koordinate
             des Bildschirms  zurÅck, d.h.  die Y-Koordinate  des
             unteren  Bildschirmrandes.   Das  Ergebnis  ist  vom
             momentan verwendeten Grafikmodus abhÑngig.
             \#getmaxx\# und  getmaxy ermîglichen  es, ein  Grafik-
             Programm unabhÑngig  von der Auflîsung zu schreiben.
             Diese  beiden   Funktionen   sollten   grundsÑtzlich
             anstelle von Konstanten verwendet werden.
Ergebnis     Mîgliche Ergebnisse  von getmaxy  liegen im  Bereich
             von 199..767.
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getviewsettings\#, \#getmaxx\#
\end

screen( capsensitive("getmodename") )
Name         Øget mode nameÆ - liefert den Namen eines Grafikmodi
             als String zurÅck.

Definition   char *getmodename(int mode_number);

Prototyp in  graphics.h

Beschreibung getmodename erwartet  die Nummer  eines  Grafikmodus
             als Parameter und liefert einen Zeiger auf den Namen
             dieses Modus zurÅck.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getgraphmode\#, \#getmaxmode\#, \#getmoderange\#, \#getdrivername\#,
             \#initgraph\#
\end

screen( capsensitive("getmoderange") )
Name         Øget  mode   rangeÆ  -   ermittelt   die   mîglichen
             Grafikmodi fÅr einen Grafiktreiber.

Definition   void getmoderange(int graphdriver, int *lomode,
                                   int *himode);

Prototyp in  graphics.h

Beschreibung getmoderange    liefert    den    niedrigstmîglichen
             Grafikmodus  fÅr  graphdriver  in  *lomode  und  den
             hîchstmîglichen  Modus   in  *himode   zurÅck.  Wenn
             graphdriver  einen   Wert  au·erhalb  des  erlaubten
             Bereichs (siehe  \#initgraph\#) enthÑlt,  werden *lomode
             und *himode auf -1 gesetzt.
             Hinweis: getmoderange  kann auch  dann  aufgerufen
             werden, wenn kein Grafikmodus gesetzt ist.
Ergebnis     getmoderange hat kein direktes Funktionsergebnis.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getgraphmode\#, \#getmaxmode\#, \#initgraph\#
\end

screen( capsensitive("getpalette") )
Name         Øget  paletteÆ  -  liefert  Informationen  Åber  die
             momentan gesetzte Farb-Palette.

Definition   void getpalette(struct palettetype *palette);

Prototyp in  graphics.h

Beschreibung getpalette  liefert   die  EintrÑge   der   momentan
             gesetzten Farb-Palette  und die  Gesamtgrî·e  dieser
             Palette in  der als  palette  Åbergebenen  Variablen
             zurÅck. Der  Datentyp palettetype  ist in graphics.h
             folgenderma·en definiert:
             #define MAXCOLORS 15
             struct palettetype
              { unsigned char size;     /* Anzahl der EintrÑge */
                signed char colors[MAXCOLORS+1];  /* Paletten-
                                                     EintrÑge */
              };
             Das Mitglied size enthÑlt die Anzahl der tatsÑchlich
             benutzten EintrÑge  des Arrays colors, sein Wert ist
             vom aktiven  Grafikmodus. Die  Elemente  von  colors
             (0..size-1) enthalten  die in  der  aktiven  Palette
             gespeicherten Bitmuster.
             Die folgenden  Konstanten sind  in graphics.h  fÅr
             Farb-Bitmuster definiert:

                   STLOW              STMEDIUM
             Name         Wert    Name        Wert
             --------------------------------------------------
             BLACK          0     BLACK         0
             BLUE           1     BLUE          1
             GREEN          2     GREEN         2
             CYAN           3     CYAN          3
             RED            4
             MAGENTA        5
             BROWN          6
             LIGHTGRAY      7
             DARKGRAY       8
             LIGHTBLUE      9
             LIGHTGREEN    10
             LIGHTCYAN     11
             LIGHTRED      12
             LIGHTMAGENTA  13
             YELLOW        14
             WHITE         15
             --------------------------------------------------------
Ergebnis     getpalette hat kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                struct palettetype palette;
                int x,y;

                initgraph(&graphdriver, &graphmode, "");

                getpalette(&palette);
                for (x = 0; x <10; x++)  /* 10 Balken
                                            nebeneinander */
                  { setfillstyle(x, (x % 4) + 1);
                    bar(x * 60, 20, (x+1) * 60, 200);
                  }

                while (!kbhit())
                 { setpalette(rand() % palette.size, rand() %
                   64);
                   delay(300);  /* bunter Farbwechsel */
                 }

                /* Farb-Palette zurÅck aufs Original */
                setallpalette(getdefaultpalette());

                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#,       \#getcolor\#,       \#getdefaultpalette\#,
             \#setallpalette\#, \#setpalette\#, \#setrgbpalette\#
\end

screen( capsensitive("getpalettesize") )
Name         Øget palette  sizeÆ - liefert die Grî·e der momentan
             gesetzten Farb-Palette  zurÅck (d.h.  die Anzahl der
             EintrÑge).

Definition   int getpalettesize(void);

Prototyp in  graphics.h

Beschreibung Mit getpalettesize  lÑ·t  sich  ermitteln,  wieviele
             EintrÑge  die  Farb-Palette  im  momentan  gesetzten
             Grafikmodus enthÑlt.
Ergebnis     getpalettesize liefert  die Anzahl  der EintrÑge als
             Integer zurÅck.
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#setpalette\#
\end

screen( capsensitive("getpixel") )
Name         Øget pixelÆ - liefert die Farbe eines Pixels zurÅck.

Definition   unsigned getpixel(int x, int y);

Prototyp in  graphics.h

Beschreibung getpixel liefert  die Farbe des Pixels auf dem durch
             (x,y) angegebenen Punkt zurÅck.
             Das von getpixel gelieferte Ergebnis steht fÅr die
             Nummer des  Paletteneintrags -  welche Farbe  diesem
             Eintrag zugeordnet  ist, wird  durch  das  Bitmuster
             festgelegt, das  in diesem  Eintrag der Farb-Palette
             gespeichert ist.
Ergebnis     getpixel  liefert   einen  Wert  im  Bereich  von  0
             (ØHintergrundÆ)..MAXCOLORS.
Beispiel     #include <graphics.h>
             #include <ext.h>
             #define NUMSTARS 1000
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x,px,py,pc;

                initgraph(&graphdriver, &graphmode, "");

                srand(1);   /* Viele bunte Sterne */
                for (x= 0; x < NUMSTARS; x++)
                  { px = rand() % getmaxx(); py = rand() %
                    getmaxy();
                    pc = 1 + rand() % getmaxcolor();
                    putpixel(px, py, pc);
                  }
                while (!kbhit())  /* Farbwechsel der Sterne */
                 { srand(1);  /* Wieder denselben Startwert */
                   for (x = 0; x < NUMSTARS; x++)
                    { px = rand() % getmaxx(); py = rand() %
                      getmaxy();
                      pc = rand() % getmaxcolor();  /* Dummy! */
                      pc = getpixel(px,py);  /* Farbe ermitteln */
                      putpixel(px,py, 1 + (++pc % getmaxcolor()));
                    }
                 }

                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#putpixel\#
\end

screen( capsensitive("gettextsettings") )
Name         Øget text settingsÆ - liefert Informationen Åber die
             Parameter fÅr  folgende  Ausgaben  mit  \#outtext\#  und
             \#outtextxy\#.

Definition   void gettextsettings(struct textsettingstype
                                         *texttypeinfo);

Prototyp in  graphics.h

Beschreibung gettextsettings ermittelt  die mit  \#settextstyle\# und
             \#settextjustify\# gesetzten  Parameter und  liefert sie
             in der als *textinfo Åbergebenen Variablen zurÅck.
             Der Strukturtyp textsettingstype und die mîglichen
             Werte  seiner   Komponenten   sind   in   graphics.h
             folgenderma·en definiert:
             struct textsettingstype
              { int font;        /* Nummer des aktiven
                                    Zeichensatzes */
                int direction;   /* horizontal oder vertikal */
                int charsize;    /* Vergrî·erungsfaktor */
                int horiz;       /* Justierung horizontal */
                int vert;        /* Justierung vertikal */
              };
             Die Komponenten  horiz und vert geben an, in welcher
             Weise Textausgaben  relativ zur  momentanen Position
             des Grafik-Cursors  (bzw. des zusammen mit \#outtextxy\#
             angegebenen Punktes) justiert werden:

             Name        Wert  Beschreibung
             --------------------------------------------------------
             LEFT_TEXT     0   linksbÅndig (horiz)
             CENTER_TEXT   1   mittenzentriert (horiz und vert)
             RIGHT_TEXT    2   rechtsbÅndig (horiz)
             BOTTOM_TEXT   0   Cursorposition = Grundlinie (vert)
             TOP_TEXT      2   CP = oberer Abschlu· (vert)
             --------------------------------------------------------
             Hinweis:  Die   Formatierungsmîglichkeiten  sind  im
             Abschnitt \#settextjustify\# ausfÅhrlich beschrieben.
             Es  stehen   fÅnf  verschiedene   ZeichensÑtze   zur
             VerfÅgung,  fÅr   die   graphics.h   die   folgenden
             Konstanten definiert:

             Name          Wert  Beschreibung
             --------------------------------------------------------
             DEFAULT_FONT    0   8 * 16 Bit pixelweise (Standard)
             TRIPLEX_FONT    1   Vektor-Zeichensatz ØTriplexÆ
             SMALL_FONT      2   kleiner Vektor-Zeichensatz
             SANSSERIF_FONT  3   Vektor-Zeichensatz ØSans serifÆ
             GOTHIC_FONT     4   Vektor-Zeichensatz ØGothicÆ
             --------------------------------------------------------
             Der pixelweise definierte Zeichensatz (DEFAULT_FONT)
             ist Teil  des Grafikpakets  und immer verfÅgbar. Die
             anderen  ZeichensÑtze   sind  in  separaten  Dateien
             (*.CHR) gespeichert  und  kînnen  entweder  als  .O-
             Dateien   eingebunden    und   via   \#registerbgifont\#
             ØregistriertÆ oder  durch  \#settextstyle\#  bei  Bedarf
             nachgeladen werden.
             Der Wert  von direction gibt an, ob Textausgaben von
             links nach  rechts (d.h.  horizontal) oder von unten
             nach oben  (d.h. in  vertikaler Richtung)  erfolgen.
             Mîgliche Werte fÅr direction sind:

             Name        Wert  Beschreibung
             --------------------------------------------------------
             HORIZ_DIR     0   von links nach rechts (Standard)
             VERT_DIR      1   Ausgabe von unten nach oben
             --------------------------------------------------------
             charsize legt  den Vergrî·erungsfaktor  (0..10)  fÅr
             Textausgaben  fest.   Eine   ØKlîtzchenvergrî·erungÆ
             (d.h. Faktor 1: 1 Pixel pro Punkt, Faktor 2: 4 Pixel
             pro Punkt  usw.)  ergibt  sich  dabei  nur  fÅr  den
             Standard-Zeichensatz.
             Der ØVergrî·erungsfaktorÆ 0, fÅr den in graphics.h
             die Konstante USER_CHAR_SIZE definiert ist, wird auf
             spezielle Weise  behandelt:  \#outtext\#  und  \#outtextxy\#
             verwenden hier  entweder den  durch  \#setusercharsize\#
             vorgegebenen    Vergrî·erungsfaktor     oder     den
             Standardwert  1,   wenn  \#setusercharsize\#  zu  diesem
             Zeitpunkt noch nicht aufgerufen wurde.
Ergebnis     gettextsettings hat kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x,y;
                char msg[20];

                initgraph(&graphdriver, &graphmode, "");

                for (x = 1, y = 10; x < 10; x+= 2)
                 { sprintf(msg, "Faktor %d", x);
                   settextstyle(GOTHIC_FONT, HORIZ_DIR, x);
                   outtextxy(0,y, msg);
                   y += textheight(msg);
                 }
                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#registerbgifont\#, \#settextjustify\#, \#settextstyle\#,
             \#setusercharsize\#, \#textheight\#, \#outtext\#, \#outtextxy\#
\end

screen( capsensitive("getviewsettings") )
Name         Øget viewport settingsÆ - liefert Informationen Åber
             das momentan gesetzte Zeichenfenster.

Definition   void getviewsettings(struct viewporttype *viewport);

Prototyp in  graphics.h

Beschreibung getviewsettings liefert  die  Grenzen  des  momentan
             gesetzten Zeichenfensters  und das  Flag der ØClipÆ-
             Funktion in  der als  viewport Åbergebenen Variablen
             zurÅck.  Der   Strukturtyp   viewporttype   ist   in
             graphics.h folgenderma·en definiert:
             struct viewporttype
              { int left, top,        /* obere linke und     */
                    right, bottom;    /* untere rechte Ecke  */
                int clipflag;         /* Clip-Funktion an/aus */
              };
Ergebnis     getviewsettings hat kein direktes Ergebnis.
Beispiel     siehe \#setviewport\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#clearviewport\#, \#setviewport\#
\end

screen( capsensitive("getx") )
Name         Øget x  coordinateÆ -  liefert die  X-Koordinate des
             Grafik-Cursors.

Definition   int getx(void);

Prototyp in  graphics.h

Beschreibung getx  liefert   die  X-Koordinate   der   momentanen
             Position des Grafik-Cursors.
Ergebnis     Die von getx zurÅckgelieferte Koordinate ist relativ
             zum Ursprung  des momentanen  Zeichenfensters - nach
             einer Befehlsfolge wie
             setviewport(20, 10, 60, 20, 0);  /* linke Ecke:
                                                 (20,10) */
             clearviewport();        /* lîscht das Fenster, setzt
                                        den Cursor in die obere
                                        linke Ecke */
             liefert getx also das Ergebnis 0.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int xsave,ysave;

                initgraph(&graphdriver, &graphmode, "");
                moveto(40,40); outtext("Ein ");
                xsave = getx(); ysave = gety();  /* Position
                                                    speichern */

                moveto(100,100); lineto(200,100);
                outtext("Hier sind wir jetzt.");
                getch();
                moveto(xsave, ysave);  /* alte Position wieder
                                          setzen */
                outtext("Text.");

                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getviewsettings\#, \#gety\#, \#initgraph\#, \#moveto\#
\end

screen( capsensitive("gety") )
Name         Øget y  [coordinate]Æ - liefert die Y-Koordinate des
             Grafik-Cursors.

Definition   int gety(void);

Prototyp in  graphics.h

Beschreibung gety  liefert   die  Y-Koordinate   der   momentanen
             Position des Grafik-Cursors.
Ergebnis     Die von gety zurÅckgelieferte Koordinate ist relativ
             zum Ursprung  des momentanen  Zeichenfensters - nach
             einer Befehlsfolge wie
             setviewport(20, 10, 60, 20, 0);  /* linke Ecke:
                                                 (20,10) */
             clearviewport();        /* lîscht das Fenster, setzt
                                        den Cursor in die obere
                                        linke Ecke */
             liefert gety den Wert 0.
Beispiel     siehe getx
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getviewsettings\#, \#getx\#, \#initgraph\#, \#moveto\#
\end

screen( capsensitive("graphdefaults") )
Name         Øgraphics defaultsÆ  - setzt sÑmtliche Parameter des
             Grafikpakets auf die Standardvorgaben zurÅck.

Definition   void graphdefaults(void);

Prototyp in  graphics.h

Beschreibung graphdefaults setzt die Standardvorgaben fÅr
             -  das Zeichenfenster (auf den gesamten Bildschirm);
             -  den Grafik-Cursor (Punkt (0,0));
             -  den  Hintergrund   (schwarz),  die   Zeichenfarbe
                (MAXCOLOR) und die Farb-Palette;
             -  FlÑchenfÅllungen (SOLID_FILL, MAXCOLOR);
             -  und Textausgaben  (DEFAULT_FONT,  HORIZ_DIR,  1),
                wobei der Wert 1 den Standard-Vergrî·erungsfaktor
                darstellt.
             Der Inhalt des Bildschirms bleibt unverÑndert.
Ergebnis     graphdefaults hat kein direktes Funktionsergebnis.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#getgraphmode\#
\end

screen( capsensitive("grapherrormsg") )
Name         Øgraphics error  messageÆ -  liefert den  Text einer
             Fehlermeldung des Grafikpakets.

Definition   char *grapherrormsg(int errorcode);

Prototyp in  graphics.h

Beschreibung grapherrormsg  liefert   einen  Zeiger   auf   einen
             statischen String  zurÅck, der  den Text  zu dem als
             errorcode  Åbergebenen   Fehlerstatus  enthÑlt,  und
             erspart so  dem Programmierer die Definition eigener
             Fehlermeldungen.
Ergebnis     grapherrormsg  liefert   einen  Zeiger   auf   einen
             statischen String  mit dem  Text  der  dazugehîrigen
             Meldung.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int errcode;
                initgraph(&graphdriver,
                          &graphmode, "###"); /* Suchweg ungÅltig */

                errcode = graphresult();
                if (errcode)
                  { restorecrtmode();
                    printf("Grafikfehler: %s\\n", grapherrormsg(errcode));
                    exit(1);
                  }

                /* FÅr diese Demonstration nur der
                   VollstÑndigkeit halber */
                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Fehlerbehandlung\#
Querverweis  \#initgraph\#, \#graphresult\#
\end

screen( capsensitive("_graphfreemem") )
Name         Øgraphics free  memoryÆ - vom Grafikpaket verwendete
             Routine  zur   Freigabe   von   dynamisch   belegtem
             Speicherplatz.

Definition   void _graphfreemem(void *ptr, unsigned size);

Prototyp in  graphics.h

Beschreibung _graphfreemem gibt  Åber den  Aufruf von  free einen
             dynamisch belegten  Bereich von  size  Bytes  wieder
             frei, auf den der als ptr Åbergebene Zeiger zeigt.
             Die   Routine    des   Grafikpakets   rufen   free
             ausschlie·lich Åber  diese Funktion  auf,  die  sich
             durch eine  eigene Version  ersetzen la·t, damit hat
             der Programmierer  die Kontrolle Åber die dynamische
             Speicherverwaltung der Grafik.
             Hinweis: Die  Deklaration von ØErsatzroutinenÆ fÅr
             _graphfreemem mu·  exakt in  der unter  ØDefinitionÆ
             gezeigten Form geschehen.
Ergebnis     _graphfreemem hat kein direktes Funktionsergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             #include <stdio.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                initgraph(&graphdriver, &graphmode, "");
                settextstyle(GOTHIC_FONT, HORIZ_DIR, 4);
                outtextxy(100, 100, "Textausgabe");
                getch();
                closegraph();
             }
             void *_graphgetmem(unsigned size)
             {
               printf("Aufruf _graphgetmem: %d Bytes\\n", size);
               getch();
               return(malloc(size));
             }

             void _graphfreemem(void *ptr, unsigned size)
             {
               printf("Aufruf _graphfreemem: %d Bytes\\n", size);
               getch();
               free(ptr);
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#setgraphbufsize\#, \#_graphgetmem\#
\end

screen( capsensitive("_graphgetmem") )
Name         Øgraphics get  memoryÆ -  vom Grafikpaket verwendete
             Routine zur dynamischen Belegung von Speicherplatz.

Definition   void *_graphgetmem(unsigned size);

Prototyp in  graphics.h

Beschreibung _graphgetmem belegt  Åber den Aufruf von malloc size
             Bytes auf  dem Heap  und liefert  einen  Zeiger  auf
             diesen Bereich zurÅck.
             Die  Routine   des   Grafikpakets   rufen   malloc
             ausschlie·lich Åber  diese beide  Funktion auf,  die
             sich durch  eine eigene Version ersetzen lÑ·t, damit
             hat  der   Programmierer  die   Kontrolle  Åber  die
             dynamische Speicherverwaltung der Grafik.
             Hinweis: Die  Deklaration von ØErsatzroutinenÆ fÅr
             _graphgetmem mu·  exakt in  der  unter  ØDefinitionÆ
             gezeigten Form geschehen.
Ergebnis     _graphgetmem liefert  einen untypisierten Zeiger auf
             die  Startadresse   des   belegten   Speicherplatzes
             zurÅck.
Beispiel     siehe \#_graphfreemem\#
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Kontrolle\#
Querverweis  \#setgraphbufsize\#, \#_graphfreemem\#
\end

screen( capsensitive("graphresult") )
Name         Øgraphics resultÆ  - liefert  den  Fehlerstatus  der
             letzten Grafikoperation zurÅck.

Definition   int graphresult(void);

Prototyp in  graphics.h

Beschreibung Das Grafikpaket  hat  einen  Status,  der  bei  I/O-
             Operationen (d.h.  Laden von Grafiktreibern und Zei-
             chensÑtzen)  sowie  durch  FlÑchenfÅllungen  gesetzt
             wird. Dieser  Status kann  mit graphresult abgefragt
             werden:  der   Wert  0   steht   fÅr   ØfehlerfreieÆ
             AusfÅhrung, Werte kleiner 0 zeigen einen Fehler an.
             Der  Statuscode   wird  durch  Zeichenbefehle  wie
             \#lineto\# nicht beeinflu·t:
              /* Status durch Aufruf von settextstyle gesetzt */
              settextstyle(GOTHIC_FONT, HORIZ_DIR, 1);
              setviewport(0,0,getmaxx(),getmaxy(),0);  /*
              unverÑndert */
              lineto(100,100);      /* unverÑndert */
              floodfill(10,10,RED);  /* Status wird neu gesetzt */
             Der Aufruf  von  graphresult  setzt  den  Statuscode
             automatisch auf  0  zurÅck.  Mehrere  PrÅfungen  des
             Statuscodes  mÅssen   deshalb  Åber  eine  temporÑre
             Variable geschehen:
             int errcode;

             main()
             { int errcode;
               ...

               errcode = graphresult();  /* Lesen und
                                            Zwischenspeichern */
               if (errcode)
                 {
                   printf("Fehler %s\\n", grapherrormsg(errcode));
                   exit(1);
                 }
               ...

             Die  folgenden   Fehlercodes  und   Meldungen   sind
             definiert:

             Name       Wert Text/Beschreibung
             --------------------------------------------------------
             grOk               0 No error - fehlerfreie AusfÅhrung
             grNoInitGraph     -1 (BGI) graphics not installed (use
                                  initgraph) - Grafiktreiber nicht
                                  initialisiert - initgraph mu· zuerst
                                  aufgerufen werden
             grNotDetected     -2 Graphics hardware not detected -
                                  kein grafikfÑhiger Adapter vorhanden/
                                  gewÅnschter Modus wird nicht unterstÅtzt
             grNoLoadMem       -5 Not enough memory to load driver - nicht
                                  genug Speicherplatz fÅr den
                                  Grafiktreiber
             grNoScanMem       -6 Out of memory in scan fill - nicht genug
                                  Speicherplatz (bar, fillpoly)
             grNoFloodMem      -7 Out of memory in flood fill - nicht
                                  genug Speicherplatz (floodfill)
             grFontNotFound    -8 Font file not found -
                                  Zeichensatzdatei nicht gefunden
             grNoFontMem       -9 Not enough memory to load font - nicht
                                  genug Speicherplatz fÅr den Zeichensatz
             grError          -11 Generic Error - nicht nÑher
                                  klassifizierbarer Fehler
             grIOerror        -12 Graphics I/O error - Ein-/Ausgabefehler
                                  beim Laden von Dateien
             grInvalidFont    -13 Invalid font file - keine
                                  Zeichensatz-Datei (falsche Version,
                                  Datei zerstîrt...)
             grInvalidFontNum -14 Invalid font file number -
                                  Kennziffer fÅr Zeichensatz nicht
                                  definiert
             --------------------------------------------------------
Ergebnis     graphresult liefert  den momentanen  Statuscode  des
             Grafikpakets (mîgliche Werte von -0 bis -14).
Beispiel     siehe \#grapherrormsg\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#grapherrormsg\#
\end

screen( capsensitive("imagesize") )
Name         Øimage   sizeÆ   -   berechnet   die   Grî·e   einer
             Puffervariablen    zur     Speicherung    grafischer
             Bildausschnitte.

Definition   unsigned long imagesize(int left, int top, int right,
                                int bottom);

Prototyp in  graphics.h

Beschreibung imagesize berechnet  die Anzahl  von Bytes,  die zur
             Speicherung  eines   Bildausschnitts  mit   \#getimage\#
             benîtigt  werden   (und  berÅcksichtigt   die   vier
             ØExtrabytesÆ fÅr die Hîhe und Breite des Rechtecks):
              pixelzahl = breite * hoehe;
              bytezahl = (pixelzahl * bits_pixel) / 8;
             bits_pixel steht  hier fÅr  die Anzahl von Bits, die
             zur Speicherung eines einzelnen Punktes erforderlich
             sind.
Beispiel     siehe \#getimage\#
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getpixel\#, \#getimage\#
\end

screen( capsensitive("initgraph") )
Name         Øinitialize   graphicsÆ    -    initialisiert    das
             Grafikpaket und setzt einen Grafikmodus.

Definition   void  initgraph(int  *graphdriver,  int  *graphmode,
                             char *pathtodriver);

Prototyp in  graphics.h

Beschreibung initgraph   initialisiert    das   Grafikpaket   via
             \#graphdefaults\# und  schaltet in  den Grafikmodus  mit
             der hîchstmîglichen Auflîsung. Graphdriver  gibt  an
             Welcher  Treiber verwendet wird.  Graphmode die Auf-
             lîsung.  Pathtodriver gibt den Pfad an unter dem die 
             Treiber und Fontdateien gesucht werden.
Ergebnis     initgraph hat kein direktes Funktionsergebnis
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#detectgraph\#
\end

screen( capsensitive("installuserdriver") )
Name         Øinstall  unser   driverÆ  -  zur  Installation  von
             Grafiktreibern,  die   nicht  direkt   von   Borland
             angeboten werden.

Definition   int   installuserdriver(char *name, int (*detect)(void));

Prototype in graphics.h

Beschreibung Die Funktion installuserdriver installiert einen
             neuen BGI-Treiber. Der Dateiname des Treibers muû
             im Parameter name stehen (die Angabe der Endung
             .BGI ist nicht notwendig). detect ist ein Zeiger
             auf eine parameterlose Funktion, die einen Grafik-
             modus (vom Typ int) fÅr den Treiber zurÅckgibt oder
             einen Fehlercode (z.B. grError ).
             Falls es keine Funktion zur Feststellung von Grafik-
             hardware gibt, kann fÅr detect auch 0 Åbergeben
             werden.
             installuserdriver liefert als Ergebnis den Fehler-
             code grError, falls keine weiteren Treiber mehr
             installiert werden kînnen, oder eine Kennummer fÅr
             den Treiber.

Beispiel     #include <stdio.h>
             #include <stdlib.h>
             #include <graphics.h>

             int  DetectWhatEver( void )
             {
                 /* recommended graphics mode: */
                 return( 2 );
             }
 
             int  main( void )
             {
                 int  driver, mode;

                 driver = installuserdriver( "WHATEVER", DetectWhatEver );
                 if ( driver == grError )
                      exit( 1 );
                 driver = DETECT;
                 initgraph( &driver, &mode, "" );
                 outtextxy( 50, 50, "This is the WHATEVER driver!" );
                 getchar( );
                 closegraph( );
                 return( 0 );
             }

PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.

Gruppe       \#Kontrolle\#

Querverweis  \#installuserfont\#
\end

screen( capsensitive("installuserfont") )
Name         Øinstall user  fontÆ -  zur Installation von Vektor-
             ZeichensÑtzen,  die   nicht   direkt   von   Borland
             angeboten werden.

Definition   int installuserfont(char *name);

Prototyp in  graphics.h

Beschreibung Mit installuserfont  kann das Grafikpaket um Vektor-
             ZeichensÑtze erweitert  werden, die  sich  nach  der
             ØInstallationÆ wie  die  Standard-ZeichensÑtze  Åber
             \#settextstyle\# aktivieren lassen.
             Die Funktion erwartet als Parameter name den Namen
             des Zeichensatzes,  der auch  unter diesem Namen als
             *.CHR-Datei charakterisiert ist.
             installuserfont  prÅft  die  als  name  angegebene
             Datei (wobei  die Endung  .CHR automatisch angehÑngt
             wird) und  liefert einen  Integer als  Ergebnis, der
             von   \#settextstyle\#   als   Kennziffer   fÅr   diesen
             Zeichensatz verwendet werden kann.
             Mit   installuserfont    kînnen   maximal    zwanzig
             zusÑtzliche   ZeichensÑtze    in   einem    Programm
             installiert werden.
Ergebnis     installuserfont liefert einen Integer zurÅck, der im
             weiteren  Programmverlauf  als  Kennziffer  fÅr  den
             entsprechenden Zeichensatz  interpretiert wird. Wenn
             die  Zeichensatz-Tabelle   des  Grafikpakets  keinen
             weiteren Eintrag  mehr aufnehmen  kann, liefert  die
             Funktion das Ergebnis grError (d.h. den Wert -11).
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#installuserdriver\#
\end

screen( capsensitive("line"),
		capsensitive("line (BGI)") )
Name         ØlineÆ - zeichnet eine Linie.

Definition   void line(int x0, int y0, int x1, int y1);

Prototyp in  graphics.h

Beschreibung line  verwendet   die  mit   \#setlinestyle\#   gesetzte
             Linienart,  -dicke   und  -farbe   sowie   den   mit
             \#setwritemode\# festgelegten  Schreibmodus (ØCopyÆ oder
             XOR).
             line zeichnet  eine Linie  vom Punkt  (x0,y0)  zum
             Punkt  (x1,y1),  ohne  den  Grafik-Cursor  dabei  zu
             bewegen.
Ergebnis     line hat kein direktes Ergebnis.
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#linerel\#, \#lineto\#, \#setlinestyle\#, \#setwritemode\#
\end

screen( capsensitive("linerel") )
Name         Øline relativeÆ  - zeichnet  eine Linie  relativ zur
             momentanen Position des Grafik-Cursors.

Definition   void linerel(int dx, int dy);

Prototyp in  graphics.h

Beschreibung linerel  verwendet  die  mit  \#setlinestyle\#  gesetzte
             Linienart,  -dicke   und  -farbe   sowie   den   mit
             \#setwritemode\# festgelegten  Schreibmodus (ØCopyÆ oder
             XOR).
             linerel interpretiert  die als  dx, dy Åbergebenen
             Werte  als   relative  Entfernung   zur   momentanen
             Position  des   Grafik-Cursors.  Die  durch  linerel
             ausgefÅhrte Operation ist mit den folgenden Befehlen
             identisch:
             xZiel = getx() + dx;  /* momentane X-Position plus
                                      dx */
             yZiel = gety() + dy;  /* momentane Y-Position plus
                                      dy */
             lineto(xZiel, yZiel);
             Wie bei  lineto bleibt  der Grafik-Cursor danach auf
             dem Endpunkt der Linie stehen.
Ergebnis     linerel hat kein direktes Ergebnis.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#line\#, \#lineto\#, \#setlinestyle\#, \#setwritemode\#,
             \#linerel\#
\end

screen( capsensitive("lineto") )
Name         Øline toÆ  - zeichnet  eine Linie von der momentanen
             Position des Grafik-Cursors zum angegebenen Punkt.

Definition   void lineto(int x, int y);

Prototyp in  graphics.h

Beschreibung lineto  verwendet   die  mit  \#setlinestyle\#  gesetzte
             Linienart,  -dicke   und  -farbe   sowie   den   mit
             \#setwritemode\# festgelegten  Schreibmodus (ØCopyÆ oder
             XOR).
             lineto zeichnet  eine  Linie  von  der  momentanen
             Position des  Grafik-Cursors zum  Punkt  (x,y).  Der
             Grafik-Cursor bleibt  danach  auf  dem  Punkt  (x,y)
             stehen.
Ergebnis     lineto hat kein direktes Ergebnis.
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#line\#, \#linerel\#, \#setlinestyle\#, \#setwritemode\#
\end

screen( capsensitive("moverel") )
Name         Ømove relativeÆ  - bewegt  den Grafik-Cursor relativ
             zu seiner momentanen Position.

Definition   void moverel(int dx, int dy);

Prototyp in  graphics.h

Beschreibung moverel interpretiert  die als  dx,  dy  Åbergebenen
             Werte als  relativen Abstand zur momentanen Position
             und entspricht den folgenden Befehlen:
              xZiel = getx() + dx;   /* momentane X-Position plus
                                        dx */
              yZiel = gety() + dy;   /* momentane Y-Position plus
                                        dy */
              moveto(xZiel, yZiel);
             moverel  arbeitet   relativ   zu   einem   eventuell
             gesetzten Zeichenfenster.
Ergebnis     moverel liefert keinen Wert zurÅck.
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#line\#, \#moveto\#
\end

screen( capsensitive("moveto") )
Name         Ømove  toÆ  -  setzt  den  Grafik-Cursor  auf  einen
             bestimmten Punkt.

Definition   void moveto(int x, int y);

Prototyp in  graphics.h

Beschreibung moveto setzt den Grafik-Cursor auf den Punkt (x,y).
             moveto arbeitet relativ zu einem eventuell gesetzten
             Zeichenfenster.
Ergebnis     moveto hat kein direktes Ergebnis.
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#line\#, \#moverel\#
\end

screen( capsensitive("outtext") )
Name         Øout textÆ  - gibt  Text ab  der momentanen Position
             des Grafik-Cursors aus.

Definition   void outtext(char *textstring);

Prototyp in  graphics.h

Beschreibung outtext gibt  den als  textstring Åbergebenen String
             ab der  momentanen Position  des Grafik-Cursors aus.
             Ein automatischer  Umbruch wie  im Textmodus  findet
             nicht  statt:   Ausgaben,  die  Åber  den  Rand  des
             Bildschirms    bzw.     des    momentan    gesetzten
             Zeichenfensters   hinausgehen    wÅrden,   schneidet
             outtext einfach ab.
             outtext benutzt  die Schriftart  und Formatierung,
             die durch \#settextstyle\# (Schriftart, Rotation, Grî·e)
             und    \#settextjustify\#    (linksbÅndig,    zentriert,
             rechtsbÅndig) vorgegeben ist. Damit das Programm bei
             einem  Wechsel   der  Schriftart  und  -grî·e  nicht
             modifiziert  werden   mu·,  sollte  der  Platzbedarf
             auszugebender  Strings   immer  Åber  \#textwidth\#  und
             \#textheight\# berechnet werden.
             Solange  nicht   mit  Rotation   gearbeitet  wird,
             verÑndert  outtext  die  X-  und  Y-Komponenten  des
             Grafik-Cursors  abhÑngig   von  der   Justierung  in
             folgender Weise:
             -  alle  Kombinationen   mit   LEFT_TEXT   fÅr   die
                horizontale Formatierung:
              GCX += textwidth(textstring);
              GCY += 0;    /* unverÑndert */
Ergebnis     outtext liefert einen Wert zurÅck.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */

                initgraph(&graphdriver, &graphmode, "");

                /* Markiert die Startposition des Cursors */
                settextjustify(CENTER_TEXT, TOP_TEXT);
                moveto(200,100); outtext("Start");
                moveto(200,100); lineto(200,50);

                /* Die "Experimentierzeile" */
                settextjustify(LEFT_TEXT, BOTTOM_TEXT);

                outtext("Eine Textzeile");

                /* Markiert die Endposition des Cursors */
                settextjustify(CENTER_TEXT, TOP_TEXT);
                lineto(400,100); outtext("Ende");

                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#,     \#settextjustify\#,     \#textheight\#,
             \#outtextxy\#
\end

screen( capsensitive("outtextxy") )
Name         Øout text  at x/yÆ  - grafische Textausgabe ab einem
             bestimmten Punkt.

Definition   void outtextxy(int x, int y, char *textstring);

Prototyp in  graphics.h

Beschreibung outtextxy gibt den als textstring Åbergebenen String
             ab der  Position (x,y) aus. Die Position des Grafik-
             Cursors wird dabei nicht verÑndert.
Ergebnis     outtextxy hat kein direktes Ergebnis.
Beispiel     siehe \#outtext\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#settextjustify\#, \#textheight\#, \#outtext\#
\end

screen( capsensitive("pieslice") )
Name         Øpie   sliceÆ    -   zeichnet    ein    ausgefÅlltes
             ØKuchenstÅckÆ.

Definition   void pieslice(int x, int y, int stangle, int endangle,
                           int radius);

Prototyp in  graphics.h

Beschreibung pieslice  zeichnet   ein  KreisbogenstÅck   in   der
             momentan gesetzten  Zeichenfarbe, dessen Mittelpunkt
             durch  (x,y)   angegeben  ist;   stangle  legt   den
             Startpunkt  des  mit  radius  gezogenen  Kreisbogens
             fest,  endangle   sein  Ende.   Die  Endpunkte   des
             Kreisbogens   werden    mit   dem   Kreismittelpunkt
             verbunden, danach  fÅllt  pieslice  das  entstandene
             ØKuchenstÅckÆ  mit  dem  durch  \#setfillpattern\#  bzw.
             \#setfillstyle\# festgelegten  Muster (und  in der  dort
             angegebenen Farbe).
Ergebnis     pieslice hat  kein direktes  Ergebnis. Wenn  wÑhrend
             der AusfÅhrung  ein  Fehler  auftritt,  liefert  der
             nÑchste Aufruf von \#graphresult\# den Wert grNoScanMem.
Beispiel     siehe \#arc\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#, \#circle\#,  \#ellipse\#,  \#fillellipse\#,  \#getarccoords\#,
             \#sector\#
\end

screen( capsensitive("putimage") )
Name         Øput imageÆ  -  kopiert  den  Inhalt  eines  Puffers
             bitweise in einen rechteckigen Bildausschnitt, wobei
             logische  VerknÅpfungen   mit  dem   Inhalt   dieses
             Ausschnitts mîglich sind.

Definition   void putimage(int x, int y, void *bitmap, int op);

Prototyp in  graphics.h

Beschreibung putimage   kopiert    einen   zuvor   mit   \#getimage\#
             gespeicherten Bildausschnitt,  wobei (left,top)  die
             obere linke  Ecke des  ØZielbereichsÆ festlegt.  FÅr
             den Parameter  op sind  die folgenden  Konstanten in
             graphics.h definiert:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             COPY_PUT  0   Kopie (öberschreiben des ØZielbereichsÆ)
             XOR_PUT   1   XOR-Operation mit dem ØZielbereichÆ
             OR_PUT    2   OR-Operation
             AND_PUT   3   AND-Operation
             NOT_PUT   4   NOT-Operation und öberschreiben
             --------------------------------------------------------
Ergebnis     putimage hat kein direktes Funktionsergebnis.
Beispiel     siehe \#getimage\#
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getimage\#, \#imagesize\#
\end

screen( capsensitive("putpixel") )
Name         Øput  pixelÆ   -  zeichnet   einen  Punkt   auf  den
             angegebenen Koordinaten.

Definition   void putpixel(int x, int y, int pixelcolor);

Prototyp in  graphics.h

Beschreibung putpixel zeichnet  einen Punkt  mit der  Farbe color
             auf dem Punkt (x,y).
Ergebnis     putpixel hat kein Funktionsergebnis.
Beispiel     siehe \#getpixel\#
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getpixel\#
\end

screen( capsensitive("rectangle") )
Name         ØrectangleÆ - zeichnet ein Rechteck.

Definition   void rectangle(int  left, int  top, int  right,
                            int bottom);

Prototyp in  graphics.h

Beschreibung rectangle zeichnet  ein Rechteck, dessen obere linke
             Ecke durch (left, top) und dessen untere rechte Ecke
             durch (right,  bottom)  festgelegt  ist,  wobei  die
             durch \#setlinestyle\# gesetzten Parameter (Linienart, -
             dicke und -farbe) verwendet werden.
             FÅr  die   Eckpunkte  des   Rechtecks  gelten  die
             folgenden Beziehungen:
              0 <= left <= right <= getmaxx();
              0 <= top <= bottom <= getmaxy();
             Etwas weniger  technisch: Alle  vier  Eckpunkte  des
             sich  ergebenden   Rechtecks  mÅssen  innerhalb  der
             Bildschirmgrenzen liegen, wobei sich die obere linke
             Ecke  tatsÑchlich   Ølinks  oberhalbÆ   der  unteren
             rechten Ecke  befinden mu·  -  einen  Austausch  von
             Wertepaaren   (d.h.    ein   ØUmdrehenÆ   der   Zei-
             chenrichtung) fÅhrt rectangle nicht aus.
Ergebnis     rectangle liefert keinen Wert zurÅck.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x, centerx, centery;

                initgraph(&graphdriver, &graphmode, "");
                centerx = getmaxx() / 2; centery = getmaxy() / 2;

                for (x = 10; x < centery; x += 20)
                  rectangle(centerx-x, centery-x, centerx+x,
                  centery+x);
                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#bar\#
\end

screen( capsensitive("registerbgidriver") )
Name         Øregister BGI  driverÆ - Registrierung eines als .O-
             Datei eingebundenen Grafiktreibers.

Definition   int  registerbgidriver( void (*driver)( void ));

Prototype in graphics.h

Beschreibung Die Funktion registerbgidriver meldet einen Treiber
             als resident im Speicher vorhanden an. Dazu wird die
             Startadresse des Treibers im Parameter driver Åber-
             geben. Als Resultat erhÑlt man die Kennummer des
             Treibers oder im Fehlerfall einen negativen Wert.

             Man kann einen Treiber einfach per \#fread\# in einen
             zuvor allozierten Speicherblock laden oder mittels
             des Programms \#BGIOBJ\# in eine Objektdatei kon-
             vertieren und diese dann in der Projektdatei ange-
             ben, um sie in sein eigenes Programm einzubinden.

Beispiel     #include <stdio.h>
             #include <stdlib.h>
             #include <graphics.h>

             extern void VdiDriver( void );

             int  main( void )
             {
                 int  mode, driver;

                 if ( registerbgidriver( VdiDriver ) < 0 )
                     exit( 1 );
                 driver = VDI;
                 mode = VDIMODE;
                 initgraph( &driver, &mode, "" );
                 outtextxy( 100, 100, "This driver is registered!" );
                 getchar( );
                 closegraph( );
                 return( 0 );
             }

PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.

Gruppe       \#Kontrolle\#
\end

screen( capsensitive("registerbgifont") )
Name         Øregister BGI  fontÆ -  Registrierung eines  als .O-
             Datei eingebundenen Grafik-Zeichensatzes.

Definition   int registerbgifont(void (*font)(void));

Prototyp in  graphics.h

Beschreibung registerbgifont erwartet  die Adresse  eines als .O-
             Datei direkt  in das  Programm eingebundenen Grafik-
             Zeichensatzes und  trÑgt diesen  Zeichensatz in eine
             interne Tabelle  fÅr  \#settextstyle\#  ein.  Auf  diese
             Weise ØregistrierteÆ  ZeichensÑtze werden nicht mehr
             als .CHR-Dateien  auf der  Diskette gesucht  und auf
             den Heap geladen, sondern direkt verwendet.
             Hinweis: Da  die  ZeichensÑtze  nur  indirekt  von
             anderen Routinen  angesprochen werden,  erfÅllt  der
             Aufruf  der   ØRegistrierfunktionÆ  einen   weiteren
             Zweck: er  teilt  dem Linker von Pure C mit, da· die
             entsprechende   .O-Datei   mit   in   das   Programm
             aufgenommen werden mu·.
Ergebnis     registerbgifont    liefert     die    Nummer     des
             ØregistriertenÆ    Grafik-Zeichensatzes.    Negative
             Funktionsergebnisse entsprechen  den Statuscodes des
             Grafikpakets und zeigen einen Fehler an.
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#,      \#getgraphmode\#,       \#gettextsettings\#,
             \#registerbgifont\#
\end

screen( capsensitive("restorecrtmode") )
Name         Ørestore CRT modeÆ - lîscht den Bildschirm.

Definition   void restorecrtmode(void);

Prototyp in  graphics.h

Beschreibung Auf   dem    Atari   wird    diese   Funktion    zum
             Bildschirmlîschen benutzt.
             Unter  MS-DOS   hat  restorecrtmode  die  Aufgabe,
             zwischen Grafik- und Textmodus umzuschalten.
Ergebnis     restorecrtmode liefert keinen Wert zurÅck.
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#setgraphmode\#
\end

screen( capsensitive("sector") )
Name         ØsectorÆ -  zeichnet ein  ausgefÅlltes  elliptisches
             ØKuchenstÅckÆ

Definition   void sector(int x, int y, int stangle, int endangle,
                             int xradius, int yradius);

Prototyp in  graphics.h

Beschreibung sector erfÅllt  dieselbe Funktion  wie pieslice  fÅr
             Ellipsen - der einzige Unterschied liegt hier darin,
             da· (wie bei \#ellipse\#) mit separaten Radien in X- und
             Y-Richtung gearbeitet wird.
Ergebnis     sector hat  kein direktes Ergebnis. Wenn wÑhrend der
             AusfÅhrung ein  Fehler auftritt, liefert der nÑchste
             Aufruf von \#graphresult\# den Wert grNoScanMem.
Beispiel     siehe arc
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen..
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#,  \#circle\#,  \#ellipse\#,  \#fillellipse\#,  \#getarccoords\#,
             \#pieslice\#
\end

screen( capsensitive("setactivepage") )
Name         Øset active  pageÆ -  legt fest, auf welcher Grafik-
             speicherseite folgende Zeichenbefehle arbeiten.

Definition   void setactivepage(int pagenum);

Prototyp in  graphics.h

Beschreibung setactivepage ist fÅr das Atari BGI nicht notwendig,
             da es nur eine Grafikspeicherseite gibt.
PortabiltÑt  Diese Funktion  ist nur  verfÅgbar, um kompatibel zu
             anderen BGI-Treibern zu bleiben.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setvisualpage\#
\end

screen( capsensitive("setallpalette") )
Name         Øset all  paletteÆ -  setzt sÑmtliche EintrÑge einer
             Farb-Palette.

Definition   void setallpalette(struct palettetype *palette);

Prototyp in  graphics.h

Beschreibung setallpalette setzt  mit der als palette Åbergebenen
             Struktur  sÑmtliche   EintrÑge  einer  Farb-Palette,
             wobei size  hier festlegt, wieviele EintrÑge (ab dem
             ersten, also  der ØFarbe  0Æ) gesetzt werden sollen.
             Jedes  Element   des  Arrays  colors  ersetzt  einen
             Eintrag der  Farb-Palette und  kann einen Wert von -
             1..63 haben.  Der ØFarbwertÆ  1  bedeutet,  da·  der
             korrespondierende    Eintrag     der     Farbpalette
             unverÑndert bleiben soll.
Ergebnis     setallpalette hat kein direktes Ergebnis.
Beispiel     siehe \#getpalette\#
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getcolor\#, \#getdefaultpalette\#, \#getpalette\#,
             \#setpalette\#
\end

screen( capsensitive("setaspectratio") )
Name         Øset aspect  ratioÆ -  verÑndert den Korrekturfaktor
             fÅr das Hîhen-/SeitenverhÑltnis des Bildschirms.

Definition   void setaspectratio(int xasp, int yasp);

Prototyp in  graphics.h

Beschreibung Die Funktion setaspectratio ist nicht notwendig. Der
             Faktor ist  immer  1,  da  man  unter  TOS  nur  das
             SeitenverhÑltnis,  nicht  aber  das  HîhenverhÑltnis
             explizit einstellen kann.
PortabiltÑt  Diese Funktion  ist nur  verfÅgbar, um kompatibel zu
             anderen BGI-Treibern zu bleiben.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getaspectratio\#
\end

screen( capsensitive("setbkcolor") )
Name         Øset background  colorÆ - setzt die Hintergrundfarbe
             des Bildschirms.

Definition   void setbkcolor(int color);

Prototyp in  graphics.h

Beschreibung setbkcolor setzt den Inhalt des ersten Eintrages der
             Farbpalette auf  den Wert  color. Dieser Eintrag ist
             fÅr  die  Hintergrundfarbe  des  Bildschirmspeichers
             verantwortlich. Die  Konstanten sind  in  graphics.h
             folgenderma·en definiert:

             Wert  Name      Wert  Name
             --------------------------------------------------------
             0     BLACK      8    DARKGRAY
             1     BLUE       9    LIGHTBLUE
             2     GREEN     10    LIGHTGREEN
             3     CYAN      11    LIGHTCYAN
             4     RED       12    LIGHTRED
             5     MAGENTA   13    LIGHTMAGENTA
             6     BROWN     14    YELLOW
             7     LIGHTGRAY 15    WHITE
             --------------------------------------------------
             Hinweis: Im  Gegensatz zur  Funktion setcolor, die
             die Zeichenfarbe nachfolgender Operationen festlegt,
             hat setbkcolor eine unmittelbare Wirkung.
Ergebnis:    setbkcolor hat kein Funktionsergebnis.
Beispiel     siehe \#setcolor\#
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getpalette\#, \#initgraph\#, \#setcolor\#
\end

screen( capsensitive("setcolor") )
Name         Øset  colorÆ   -  setzt   die  Farbe  fÅr  folgenden
             Zeichenaktionen.

Definition   void setcolor(int color);

Prototyp in  graphics.h

Beschreibung setcolor   legt   fest,   welcher   Paletten-Eintrag
             zukÅnftig als Zeichenfarbe verwendet werden soll.
Ergebnis     setcolor liefert  die Nummer  des Paletten-Eintrags,
             der momentan  als Zeichenfarbe gesetzt ist. setcolor
             hat kein Funktionsergebnis.
Beispiel     #include <graphics.h>
             #include <stdlib.h>
             #include <ext.h>
             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int color;

                initgraph(&graphdriver,&graphmode,"");

                /* Linien mit wechselnder Farbe und
                   gleichbleibendem Hintergrund */
                while (!kbhit())
                 { color = getcolor();
                   if (++color > getmaxcolor())   color = 0;
                   setcolor(color);
                   lineto(random(getmaxx()) + 1),
                          random(getmaxy()) + 1));
                  }
                getch();
                closegraph();
             }

PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getpalette\#, \#getmaxcolor\#, \#setbkcolor\#
\end

screen( capsensitive("setfillpattern") )
Name         Øset fill patternÆ - ermîglicht die freie Definition
             von Mustern fÅr FlÑchenfÅllungen.

Definition   void setfillpattern(char *pattern, int color);

Prototyp in  graphics.h

Beschreibung setfillpattern definiert  das ausgewÑhlte Muster und
             die Zeichenfarbe  fÅr die  Aufrufe von  \#fillellipse\#,
             \#fillpoly\#,  \#floodfill\#,   \#bar\#,   \#bar3d\#,   \#sector\#   und
             \#pieslice\#.
             pattern ist ein Zeiger auf eine Folge von 8 Bytes,
             bei dem  jedes Bit  fÅr ein Pixel in der durch color
             festgelegten Farbe steht.
Ergebnis     setfillpattern hat kein Ergebnis.
Beispiel     siehe \#setfillstyle\#
PortabilitÑt Auf allen  Systemen, die BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getfillsettings\#, \#setfillstyle\#
\end

screen( capsensitive("setfillstyle") )
Name         Øset fill  styleÆ -  setzt ein vordefiniertes Muster
             zur FlÑchenfÅllung.

Definition   void setfillstyle(int pattern, int color);

Prototyp in  graphics.h

Beschreibung setfillstyle erwartet einen dieser Werte als pattern
             und setzt das entsprechende Bitmuster.
             Hinweis:  Um  ein  benutzerdefiniertes  FÅllmuster
             (USER_FILL, Wert  12) zu  setzen, mu· \#setfillpattern\#
             verwendet werden.
Ergebnis     setfillstyle hat  kein direktes Ergebnis. Ein Aufruf
             von  setfillstyle   mit  einem   Wert  fÅr   pattern
             au·erhalb  des   Bereichs  0..11   wird  als  Fehler
             gewertet: das  momentan gesetzte  FÅll-Muster bleibt
             in  diesen  FÑllen  unverÑndert,  ein  nachfolgender
             Aufruf von \#graphresult\# liefert den Wert -grError.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT; /* automatische */
                int graphmode;              /* Erkennung */
                struct fillsettingstype save;
                char savepattern[8];
                char checkboard[] = { 0x0F, 0xF0, 0x0F, 0xF0,
                                      0x0F, 0xF0, 0x0F, 0xF0 };

                initgraph(&graphdriver, &graphmode, "");

                /* momentan gesetztes Muster ermitteln */
                getfillsettings(&save);       /* Muster
                                                 speichern */
                if (save.pattern == USER_FILL)
                                     /* benutzerdefiniert? */
                  getfillpattern(savepattern);  /* -> ja,
                                           Bitmuster lesen */

                setfillstyle(SLASH_FILL, BLUE);  /* /////, blau */
                bar (0,0,100,100);               /* Balken
                                                    zeichnen */

                setfillpattern(checkboard, YELLOW); /* eigenes
                                                       Muster */
                bar (100,100,200,200);    /* noch ein Balken */

                /* und das alte Muster wieder setzen */
                if (save.pattern == USER_FILL)
                  setfillpattern(savepattern, save.color);
                 else
                  setfillstyle(save.pattern, save.color);

                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#arc\#,    \#fillpoly\#,     \#floodfill\#,     \#getfillpattern\#,
             \#getfillsettings\#
\end

screen( capsensitive("setgraphbufsize") )
Name         Øset graphics  buffer sizeÆ  - legt  die  Grî·e  des
             Puffers fÅr FlÑchenfÅllungen und Polygone fest.

Definition   unsigned setgraphbufsize(unsigned bufsize);

Prototyp in  graphics.h

Beschreibung FÅr   FlÑchenfÅllungen   und   Polygone   wird   von
             setgraphbufsize die  Grî·e eines Puffers festgelegt.
             Diese Funktion ist unter TOS nicht notwendig, da der
             Speicherplatz intern verwaltet wir.
PortabiltÑt  Diese Funktion  ist nur  verfÅgbar, um kompatibel zu
             MS-DOS zu sein.
Gruppe       \#Kontrolle\#
\end

screen( capsensitive("setgraphmode") )
Name         Øset graphics  modeÆ - schaltet in einen Grafikmodus
             um und lîscht den Bildschirm.

Definition   void setgraphmode(int mode);

Prototyp in  graphics.h

Beschreibung setgraphmode  schaltet   immer   in   den   hîchsten
             Grafikmodus.     Bei     Monochrommonitoren     wird
             grundsÑtzlich STHIGH  zurÅckgegeben, da  es  hierfÅr
             nur  einen  Auflîsungsmodus  gibt  (hohe  Auflîsung,
             STHIGH 640x400).
             Bei Farbmonitoren  schaltet  setgraphmode  in  den
             mittleren Grafikmodus  STMEDIUM (640x200),  da  dies
             bei Farbmonitoren die hîchste Auflîsung ist.
             Ist  der   Grafikmodus  eingeschaltet   wird   der
             Bilschirm gelîscht.
Ergebnis     setgraphmode  liefert   die  Nummer   des   momentan
             gesetzten Grafikmodus zurÅck.
PortabilitÑt Diese Funktion  ist kompatibel  zu allen Systemen,
             die BGI unterstÅtzen.
Gruppe       \#Kontrolle\#  \#initgraph\#  \#getgraphmode\#
\end

screen( capsensitive("setlinestyle") )
Name         Øset line  styleÆ -  setzt die  Linienart und -dicke
             fÅr folgende Zeichenaktionen.

Definition   void setlinestyle(int linestyle, unsigned upattern,
                               int thickness);

Prototyp in  graphics.h

Beschreibung setlinestyle  setzt   die  Linienart   fÅr  folgende
             Zeichenoperationen  mit   \#line\#,  \#lineto\#,  \#rectangle\#,
             \#drawpoly\#, \#arc\#,  \#circle\#, \#ellipse\#,  \#pieslice\# usw.  Der
             Parameter upattern  hat hier  nur dann eine Wirkung,
             wenn linestyle den Wert USERBIT_LINE hat - in diesem
             Fall legen  die einzelnen  Bits das  Punktmuster der
             Linie fest,  wobei das  hîchstwertige Bit  (15)  dem
             jeweils  zuerst   gezeichneten  Punkt   einer  Linie
             entspricht:  0xFFFF   fÅr   upattern   ergibt   eine
             durchgezogene Linie,  0x3333 eine gestrichelte Linie
             usw.
             Hinweis:  Auch  wenn  setlinestyle  den  Wert  von
             pattern fÅr linestyle != USERBIT_LINE ignoriert, mu·
             dieser Parameter immer angegeben werden.
Ergebnis     setlinestyle hat kein direktes Ergebnis. Aufrufe von
             setlinestyle mit  einem Wert fÅr linestyle au·erhalb
             des Bereichs  0..4 werden  als Fehler  gewertet:  in
             diesen FÑllen bleibt die momentan gesetzte Linienart
             unverÑndert,   ein    nachfolgender    Aufruf    von
             \#graphresult\# liefert das Ergebnis -11.
Beispiel       struct linesettingstype save;
               int lkind, lpattern, lthickness;
               ...
               getlinesettings(&save);
               lkind      = save.linestyle;   /* Linienart
                                                 (1..12) */
               lpattern   = save.pattern;     /* Bitmuster */
               lthickness = save.thickness;   /* Dicke (1 oder 3) */
               ...
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getlinesettings\#, \#setwritemode\#
\end

screen( capsensitive("setpalette") )
Name         Øset paletteÆ  - Ñndert  einen Eintrag  der momentan
             gesetzten Farb-Palette.

Definition   void setpalette(int colornum, int actual_color);

Prototyp in  graphics.h

Beschreibung setpalette  setzt   einen  einzelnen   (durch  index
             bezeichneten) Eintrag  der Farb-Palette  auf das  in
             actual_color enthaltene Bitmuster.
Ergebnis     setpalette  hat   kein   direktes   Ergebnis.   Wenn
             setpalette  mit   ungÅltigen  Parametern  aufgerufen
             wird,  bleibt   die  momentan  gesetzte  Farbpalette
             unverÑndert; eine  folgender Aufruf  von \#graphresult\#
             liefert in diesem Fall den Wert grError.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                struct palettetype palette;
                int x,y;

                initgraph(&graphdriver, &graphmode, "");

                getpalette(&palette);
                for (x = 0; x <10; x++)  /* 10 Balken
                                            nebeneinander */
                  { setfillstyle(x, (x % 4) + 1);
                    bar(x * 60, 20, (x+1) * 60, 200);
                  }

                while (!kbhit())
                 { setpalette(rand() % palette.size, rand() %
                   64);
                   delay(300);  /* bunter Farbwechsel */
                 }

                /* Farb-Palette zurÅck aufs Original */
                setallpalette(getdefaultpalette());

                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getcolor\#, \#getdefaultpalette\#, \#getpalette\#,
             \#setallpalette\#
\end

screen( capsensitive("setrgbpalette") )
Name         Øset  RGB   paletteÆ  -  Ñndert  einen  Eintrag  der
             momentan gesetzten  Farbpalette fÅr  den IBM-Adapter
             8450.

Definition   void setpalette(int colornum, int red,
                             int green, int blue);

Prototyp in  graphics.h

PortabiltÑt  Diese Funktion  ist nur  verfÅgbar, um kompatibel zu
             MS-DOS zu sein.
Ergebnis     setpalette hat kein Ergebnis
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
\end

screen( capsensitive("settextjustify") )
Name         Øset text  justificationÆ - legt die Ausrichtung von
             Textausgaben durch outtext und outtextxy fest.

Definition   void settextjustify(int horiz, int vert);

Prototyp in  graphics.h

Beschreibung Die   durch   settextjustify   gesetzten   Parameter
             bestimmen, in  welchem VerhÑltnis  Textausgaben  mit
             \#outtext\#  zur   Position  des   Grafik-Cursors   bzw.
             Textausgaben  mit   \#outtextxy\#  zu   den  angegebenen
             Koordinaten stehen. Eine Befehlsfolge wie
              settextjustify(CENTER_TEXT, CENTER_TEXT);
              outtextxy(100,100, "ABC");
             schreibt die  Zeichen ABC so auf den Bildschirm, da·
             der Punkt  (100,100) im  Zentrum des  Buchstabens  B
             liegt.
             FÅr   die   Ausrichtung   von   Texten   definiert
             graphics.h die folgenden Konstanten:

             Name        Wert  Beschreibung
             --------------------------------------------------------
             LEFT_TEXT     0   linksbÅndig (horiz)
             CENTER_TEXT   1   mittelzentiert (horiz und vert)
             RIGHT_TEXT    2   rechtsbÅndig (horiz)
             BOTTOM_TEXT   0   Cursorposition = Grundlinie (vert)
             TOP_TEXT      2   Cursorposotion = oberer Abschlu·
                               (vert)
             --------------------------------------------------------
Ergebnis     settextjustify liefert keinen Wert zurÅck.
Beispiel     siehe \#outtext\#
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#outtext\#, \#outtextxy\#
\end

screen( capsensitive("settextstyle") )
Name         Øset  text   styleÆ  -  legt  den  Zeichensatz,  die
             Schreibrichtung und die Grî·e folgender Textausgaben
             fest.

Definition   void  settextstyle(int   font,  int  direction,  int
             charsize);

Prototyp in  graphics.h

Beschreibung settextstyle setzt  einen  Zeichensatz  (font),  die
             Schreibrichtung      (direction)       und       den
             Vergrî·erungsfaktor         (charsize).          Die
             Strukturkomponente  font   gibt  Auskunft  Åber  den
             Zeichensatz, der zur Textausgabe verwendet wird.
Ergebnis     Wenn eine Zeichensatz-Datei durch settextstyle nicht
             fehlerfrei  geladen   werden  konnte,   liefert  ein
             nachfolgender  Aufruf   von  graphresult  eines  der
             folgenden Ergebnisse:definiert:

             Name               Wert  Beschreibung
             --------------------------------------------------------
             grFontNotFound      -8   Zeichensatz-Datei nicht
                                      gefunden
             grfNoFontMem        -9   nicht genug Speicherplatz zum
                                      Laden der Datei
             grError             -11  unspezifischer Fehler
             grIOError           -12  I/O-Fehler
             grInvalidFont       -13  keine Zeichensatz-Datei
             grInvalidFontMem    -14  Wert von font au·erhalb des
                                      Bereichs 0..4
             --------------------------------------------------------
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x,y;
                char msg[20];

                initgraph(&graphdriver, &graphmode, "");

                for (x = 1, y = 10; x < 10; x+= 2)
                 { sprintf(msg, "Faktor %d", x);
                   settextstyle(GOTHIC_FONT, HORIZ_DIR, x);
                   outtextxy(0,y, msg);
                   y += textheight(msg);
                 }
                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#,  \#registerbgifont\#,   \#settextjustify\#,
             \#setusercharsize\#, \#textheight\#, \#outtext\#, \#outtextxy\#
\end

screen( capsensitive("setusercharsize") )
Name         Øset  user   character  sizeÆ   -  legt  voneinander
             unabhÑngige Vergrî·erungsfaktoren  fÅr die X- und Y-
             Richtung der Grafik-zeichensÑtze fest.

Definition   void setusercharsize(int multx, int divx,
                                  int multy, int divy);

Prototyp in  graphics.h

Beschreibung setusercharsize erlaubt im Gegensatz zu \#settextstyle\#
             voneinander unabhÑngige  Vergrî·erungsfaktoren in X-
             und  Y-Richtung:  die  Breite  eines  Zeichens  wird
             zuerst mit multx multipliziert und danach durch divx
             dividiert. Dasselbe gilt fÅr die Zeichenhîhe und die
             Parameter multy bzw. divy.
             Im folgenden  Beispiel wird der Text ABC mit einer
             Breite von Ø8Æ und einer Hîhe von Ø6.5Æ ausgegeben:
              settextstyle(GOTHIC_FONT, HORIZ_DIR, 0);
              setusercharsize(8,1,13,2);
              outtextxy(100,100,"ABC");
             Hinweis:  Wie   im  Abschnitt  Åber  \#gettextsettings\#
             erlÑutert,  haben   mit   setusercharsize   gesetzte
             Vergrî·erungsfaktoren nur  dann eine  Wirkung,  wenn
             zuvor  \#settextstyle\#  mit  charsize  =  0  aufgerufen
             wurde. Die  Standardvorgabe fÅr  setusercharsize ist
             (4,1,4,1).
Ergebnis     setusercharsize liefert keinen Wert zurÅck.
Beispiel     #include <graphics.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */

                char title[] = "Text in einem Rechteck";

                initgraph(&graphdriver, &graphmode, "");
                settextstyle(GOTHIC_FONT, HORIZ_DIR,
                             USER_CHAR_SIZE);

                settextjustify(CENTER_TEXT, CENTER_TEXT);
                                               /*  zentriert */
                setusercharsize(1,1,1,1);  /* fÅr die Berechnung */

                rectangle(0,0,200,100); /* 200 Pixel breit, 100
                                           hoch */
                setusercharsize(200, textwidth(title),
                                100, textheight(title));
                outtextxy(100,50,title); /* Ausgabe in der Mitte */

                getch();
                closegraph();
             }
PortabiltÑt  Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#outtext\#, \#textheight\#
\end

screen( capsensitive("setviewport") )
Name         Øset viewportÆ - setzt ein Grafik-Zeichenfenster.

Definition   void setviewport(int  left, int  top, int right,
                              int bottom, int clipflag);
Prototyp in  graphics.h

Beschreibung setviewport legt mit (left,top) die obere linke Ecke
             und mit (right, bottom) die untere rechte Ecke eines
             neuen  Zeichenfensters   fest   und   arbeitet   mit
             absoluten Koordinaten. Der Aufruf
              setviewport(0,0,100,100,1);
             setzt ein  Zeichenfenster von 100 Pixeln Breite, das
             sich in  der  oberen  linken  Ecke  des  Bildschirms
             befindet -  unabhÑngig davon,  ob zuvor  ein anderes
             Zeichenfenster gesetzt war oder nicht.
             setviewport setzt  den Grafik-Cursor auf den Punkt
             (0,0)   innerhalb    des   neuen    Fensters.    Der
             ØFensterinhaltÆ  wird  durch  diese  Funktion  nicht
             verÑndert.
             Der   Parameter    clipflag    legt    fest,    ob
             Zeichenaktionen am  Rand des  Fensters abgeschnitten
             werden sollen  (clipflag = 1) oder nicht (clipflag =
             0). Eine Befehlsfolge wie
              setviewport(0,0,100,100,1); /* Clip-Funktion aktiv */
              lineto(200,200);
             zeichnet eine  Linie vom (absoluten) Punkt (0,0) zum
             Punkt   (100,100)   -   der   restliche   Teil   der
             Zeichenaktion  (d.h.   die  Fortsetzung   zum  Punkt
             (200,200)) wird unterdrÅckt.
             Hinweis: Der  Grafik-Cursor selbst  ist von  einem
             ØClippingÆ nie betroffen, nur Zeichenaktionen werden
             gegebenenfalls  unterdrÅckt.   Im  zuvor   gezeigten
             Beispiel befindet  sich der  Grafik-Cursor nach  dem
             Aufruf von \#lineto\# auf dem absoluten Punkt (200,200).
             \#initgraph\#    und     \#setgraphmode\#    setzen    das
             Zeichenfenster   auf    den   gesamten   Bildschirm,
             entsprechen also  einem Aufruf  von  setviewport mit
             den folgenden Parametern:
              setviewport(0, 0, getmaxx(), getmaxy(), 0);
Ergebnis     setviewport hat  kein direktes  Ergebnis. Der Aufruf
             von setviewport  mit Werten,  die  die  Grenzen  des
             Bildschirms   Åberschreiten,   lÑ·t   das   momentan
             gesetzte     Zeichenfenster     unverÑndert.     Ein
             nachfolgender  Aufruf  von  \#graphresult\#  liefert  in
             diesem Fall das Ergebnis grError.
Beispiel     #include <graphics.h>
             #include <ext.h>

             #define CLIPON 1

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x, x1,y1,x2,y2;

                initgraph(&graphdriver, &graphmode, "");

                while (!kbhit())  /* ein bunter Sternenhimmel */
                 putpixel(rand() % getmaxx(), rand() % getmaxy(),
                          1 + rand() % getmaxcolor());

                getch();
                x1 = getmaxx() - 90; y1 = getmaxy() - 90;
                setcolor(RED);
                do { x2 = x1 + 80; y2 = y1 + 80;
                     setviewport(x1,y1,x2,y2,CLIPON);
                     clearviewport();
                     rectangle(40,20,80,75);
                     x1 -= getmaxy() / 10;
                     y1 -= getmaxx() / 20;
                   } while ((x1 >= 0) && (y1 >= 0));

                getch();
                closegraph();
             }
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#clearviewport\#, \#getviewsettings\#
\end

screen( capsensitive("setvisualpage") )
Name         Øset visual  pageÆ - wÑhlt eine von mehreren Grafik-
             Speicherseiten zur Anzeige aus.

Definition   void setvisualpage(int pagenum);

Prototyp in  graphics.h

Beschreibung Das Atari BGI unterstÅtzt nur eine Grafikseite.
Ergebnis     setvisualpage hat kein Ergebnis
PortabiltÑt  Diese Funktion  ist nur  verfÅgbar, um kompatibel zu
             MS-DOS zu bleiben.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setactivepage\#
\end

screen( capsensitive("setwritemode") )
Name         Øset  write   modeÆ  -  legt  den  Schreibmodus  fÅr
             Zeichenoptionen fest.

Definition   void setwritemode(int mode);

Prototyp in  graphics.h

Beschreibung setwritemode legt  fest,  ob  Zeichenaktionen  mit
             \#line\#, \#linerel\#,  \#lineto\#, \#rectangle\#  und \#drawpoly\#  den
             vorherigen  Bildschirminhalt   direkt  Åberschreiben
             (ØCopyÆ) oder  ob dazu  eine XOR-Operation verwendet
             wird. (Im  zweiten Fall  lÑ·t sich  die  gezeichnete
             Linie durch  einen weiteren  Zeichenbefehl im selben
             Modus ohne  Zestîrung des  Hintergrundes wieder  vom
             Bildschirm   entfernen).    Die   beiden   mîglichen
             Parameter von  setwritemode sind  in graphics.h  als
             Konstanten definiert:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             COPY_PUT  0   öberschreiben durch direkte Kopie
             XOR_PUT   1   XOR-Operation mit dem vorherigen Inhalt
             --------------------------------------------------------
Ergebnis     setwritemode hat kein direktes Ergebnis.
Beispiel     struct linesettingstype save;
             int lkind, lpattern, lthickness;
             ...
             getlinesettings(&save);
             lkind      = save.linestyle;   /* Linie (1..12) */
             lpattern   = save.pattern;     /* Bitmuster */
             lthickness = save.thickness;   /* Dicke (1 oder 3) */
             ...
PortabilitÑt Diese Funktion ist lauffÑhig auf allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#Zeichnen und FlÑchenfÅllung\#
Querverweis  \#getlinesettings\#, \#setlinestyle\#
\end

screen( capsensitive("textheight") )
Name         Øtext heightÆ  - liefert  den vertikalen Platzbedarf
             eines Strings in Pixeln zurÅck.

Definition   int textheight(char *textstring);

Prototyp in  graphics.h

Beschreibung textheight  berechnet   aus   dem   als   textstring
             Åbergebenen String,  sowie  dem  momentan  gesetzten
             Zeichensatz   und    dem   Vergrî·erungsfaktor   den
             vertikalen Platzbedarf einer Textzeile.
             Achtung: Anders  als  fÅr  die  VektorzeichensÑtze
             gibt  es   fÅr  den   Standardzeichensatz  nur  zwei
             verschiedene Texthîhen. Wird der Vergrî·erungsfaktor
             auf 0  oder 1 gesetzt, so wird der Text mit 10 Pixel
             Hîhe     ausgegeben,      fÅr      alle      anderen
             Vergrî·erungsfaktoren mit 32 Pixel.
             Hinweis:  Im   Gegensatz  zur  Funktion  \#textwidth\#
             spielt es bei textheight keine Rolle, welcher String
             zur Berechnung Åbergeben wird.
             Der Platzbedarf  von Strings  sollte grundsÑtzlich
             Åber  textheight  und  \#textwidth\#  ermittelt  werden.
             Nicht nur,  da· das Zentrieren von Titeln, Einpassen
             von Beschriftungen  usw. auf  diese Weise wesentlich
             einfacher geht  - Programme,  die  diese  Funktionen
             anstelle von  Konstanten  verwenden,  erfordern  bei
             einem Wechsel der Schriftart oder des Grafiktreibers
             erheblich weniger Modifikationen (wenn Åberhaupt).
Ergebnis     textheight liefert  das Ergebnis  der Berechnung  in
             Pixeln zurÅck.
Beispiel     #include <graphics.h>

             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x, ypos;

                initgraph(&graphdriver, &graphmode, "");

                settextjustify(CENTER_TEXT, BOTTOM_TEXT);

                for (ypos = 0, x = DEFAULT_FONT; x <=
                     GOTHIC_FONT; x++)
                 {  settextstyle(x, HORIZ_DIR, 8);
                    ypos += textheight("T") + 5;
                    outtextxy(getmaxx() / 2,ypos, "Pure C");
                 }

                getch();
                closegraph();
             }
PortabilitÑt Auf allen  Systemen die  BGI unterstÅtzen, ist diese
             Funktion lauffÑhig.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#outtext\#, \#setusercharsize\#,
             \#textwidth\#
\end

screen( capsensitive("textwidth") )
Name         Øtext widthÆ  - liefert  die Breite eines Strings in
             Pixeln zurÅck.

Definition   int textwidth(char *textstring);

Prototyp in  graphics.h

Beschreibung textwidth   berechnet   aus   dem   als   textstring
             Åbergebenen  String  sowie  dem  momentan  gesetzten
             Zeichensatz   und    dem   Vergrî·erungsfaktor   den
             horizontalen Platzbedarf einer Textzeile.
             Achtung: Im  Gegensatz zu  den VektorzeichensÑtzen
             kann auf  dem Atari der Standardzeichensatz nicht in
             der Breite  gestreckt werden.  FÅr einen  5  Zeichen
             langen String  wird also  immer das  Ergebnis 5*8=40
             geliefert.
             Hinweis:  Im  Gegensatz  zur  Funktion  \#textheight\#
             spielt es  hier sehr  wohl eine Rolle, aus wievielen
             (und  bei   proportionalen  ZeichensÑtzen:  welchen)
             Zeichen sich  der Text  zusammensetzt, der textwidth
             zur Berechnung Åbergeben wird.
             Der Platzbedarf  von Strings  sollte grundsÑtzlich
             Åber  \#textheight\#  und  textwidth  ermittelt  werden.
             Nicht nur,  da· das Zentrieren von Titeln, Einpassen
             von Beschriftungen  usw. auf  diese Weise wesentlich
             einfacher geht  - Programme,  die  diese  Funktionen
             anstelle von  Konstanten  verwenden,  erfordern  bei
             einem Wechsel der Schriftart oder des Grafiktreibers
             erheblich weniger Modifikationen (wenn Åberhaupt).
Ergebnis     textwidth liefert  das Ergebnis  ihrer Berechnung in
             Pixeln zurÅck.
Beispiel     siehe \#textheight\#
PortabilitÑt Diese Funktion ist kompatibel zu allen Systemen, die
             BGI unterstÅtzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#,      \#outtext\#,      \#setusercharsize\#,
             \#textheight\#
\end

screen( capsensitive("BGIOBJ") )
BGIOBJ - Konvertierung von ZeichensÑtzen

Die StandardzeichensÑtze  existieren als separate Dateien (.CHR),
die bei  Bedarf auf  den Heap  des Programms  geladen werden. Der
Vorteil  dieses   Konzepts  liegt   darin,  da·   immer  nur  der
Zeichensatz  Platz  im  Speicher  belegt,  der  auch  tatsÑchlich
gebraucht wird. Die Nachteile: Sowohl die Aktivierung des Grafik-
pakets als  auch der  Wechsel des  Zeichensatzes  machen  Disket-
tenzugriffe (nebst der dazugehîrigen FehlerprÅfung) notwendig und
setzen die entsprechenden Dateien voraus.
Mit BGIOBJ  lassen sich ZeichensÑtze in .O-Dateien  konvertieren,
die direkt in das Programm aufgenommen werden kînnen. Ein eventu-
eller Nachteil  liegt hier  natÅrlich darin,  da· sich der Umfang
des Programms entsprechend erhîht.
Die Aufnahme  eines Zeichensatzes  in ein  Programm besteht  aus
drei Schritten:
1.  Konvertierung mit  BGIOBJ in  eine .O-Datei. BGIOBJ gibt dem
    Zeichensatz dabei einen ØFunktionsnamenÆ.
2.  ØRegistrierungÆ   des   Zeichensatzes   im   Programm   Åber
    registerbgifont. An dieser Stelle wird der von BGIOBJ verge-
    bene ØFunktionsnameÆ verwendet:

    if (registerbgifont(gothic_font) != GOTHIC_FONT)
    {
       printf("Zeichensatz konnte nicht registriert werden!\\n");
       exit(1);
    }

TRIPLEX_FONT ist eine (in  graphics.h  definierte) Konstante  und
hat nichts mit dem ØFunktionsnamenÆ triplex_font zu tun.

Hinweis:   Wie    im   Abschnitt    Åber   registerbgifont    des
Bibliotheksverzeichnisses beschrieben,  erhalten das  Grafikpaket
und der  Linker erst durch diese ØRegistrierungÆ die Information,
da· der entsprechende Zeichensatz nicht geladen werden mu·.


Der Aufruf von BGIOBJ

geschieht von der Kommandoebene aus durch die Eingabe von bgiobj
Wenn Åberhaupt  keine  Parameter  angegeben  sind,  erhalten  Sie
daraufhin den folgenden Text:

BGIOBJ 1.0          (c) 1990 by Borland International, Inc.

Usage: BGIOBJ <source> <destination> <public name>


Beispiel:
 BGIOBJ.TTP GOTH
 erzeugt GOTH.O mit dem globalen Nemen gothic_font
 BGIOBJ.TTP EURO
 erzeugt EURO.O mit dem globalen Nemen euro_font

Wenn nur  der Name  eines Zeichensatzes angegeben wird, verwendet
BGIOBJ die folgenden Standardvorgaben:

Quelldatei Zieldatei   globaler Name
-----------------------------------------------------------------
TRIP.CHR   TRIP.O      triplex_font
LITT.CHR   LITT.O      small_font
SANS.CHR   SANS.O      sansserif_font
GOTH.CHR   GOTH.O      gothic_font
-----------------------------------------------------------------

Mit BGIOBJ erzeugte .O-Dateien kînnen
- entweder Åber eine .PRJ-Datei in ein Programm aufgenommen


Weitergehende Mîglichkeiten von BGIOBJ

Dieser  Abschnitt   erlÑutert  die   restlichen   Kommandozeilen-
Parameter  von   BGIOBJ  im  Detail  und  ist  fÅr  erfahrene  C-
Programmierer gedacht  - fÅr ØnormaleÆ Problemstellungen sind die
Standardvorgaben  des   Programms  in   praktisch  allen   FÑllen
ausreichend.
Wie zu  Anfang dieses  Anhangs beschrieben,  hat der  Aufruf  von
BGIOBJ die folgende Syntax:

Syntax:   BGIOBJ  <Quelldatei>   <Zieldatei[.O]  <globaler Name>

Alle Parameter  au·er Quelldatei  sind optional.  Die Reihenfolge
der   Parameter   ist   zwingend   vorgeschrieben   -   um   also
beispielsweise   einen   globalen   Namen   festzulegen,   mÅssen
Quelldatei und Zieldatei angegeben werde.;

Parameter  Beschreibung
-----------------------------------------------------------------
Quelldatei Name der zu konvertierenden Datei. Solange mit den
           ausgelieferten ZeichensÑtzen gearbeitet wird, fÅgt
           BGIOBJ das Suffix .CHR automatisch an, wenn der
           angegebene Name keinen Punkt enthÑlt.
Zieldatei  Name der zu erzeugenden Datei. Die Standardvorgabe ist
           Quelldatei.O. Das Suffix .O wird automatisch
           angehÑngt, wenn der angegebene Name keinen Punkt
           enthÑlt.

globaler   Der hier angegebene ØFunktionsnameÆ wird bei Aufruf
Name       von registerbgifont verwendet.
-----------------------------------------------------------------

Wenn Sie  eigene globale Namen fÅr ZeichensÑtze verwenden wollen,
mÅssen Sie Ihrem Programm entsprechende Prototypen hinzufÅgen:

              void globaler_Name(void);

Solange  mit   den   Standardvorgaben   von   BGIOBJ   und   den
StandardzeichensÑtzen gearbeitet  wird,  sind  eigene  Prototypen
nicht notwendig  - die  entsprechenden Deklarationen sind bereits
in graphics.h enthalten.
\end

screen( "GEM" )
GEM (Graphics Environment Manager)
----------------------------------------------------------------------

Im Gegensatz zu einem konventionellen \#Betriebssystem\#, dessen Haupt-
augenmerk meist auf der Dateiorganisation, einem Multitaskingsystem
und der Ansteuerung von PeripheriegerÑten liegt, ist GEM in erster
Linie zur konsistenten und portablen Programmierung von grafischen
Ausgabesystemen entwickelt worden. DarÅberhinaus soll GEM den Dialog
zwischen Programm und Anwender erleichtern.
Die \link("Betriebssystem")Betriebssystemumgebung\# von GEM besteht aus zwei Teilen, einem
mehr auf die Grafik spezialisiertem und einem Åberwiegend im Hinblick
auf eine leicht anzuwendende Benutzerschnittstelle orientierten Ab-
schnitt:

˘ \#AES\#  (Application Environment Services)
˘ \#VDI\#  (Virtual Device Interface)

\#AES\# Åbernimmt dabei die Organisation der Benutzerumgebung, wohingegen
\#VDI\# fÅr eine einheitliche grafische Gestaltung der BenutzeroberflÑche
sorgt. WÑhrend \#AES\# auf \#VDI\#-Funktionen basiert, wird im \#VDI\# keine
\#AES\#-Funktion verwendet. Man kann \#AES\# als das Åbergeordnete System be-
trachten. Zusammen mit den Funktionen eines konventionellen Betriebs-
sytems erfÅllt GEM damit alle Anforderungen an ein anwendergerechetes
\#Betriebssystem\#.
\end

screen( "AES" )
Das AES-System (ØApplication Environment ServicesÆ)
----------------------------------------------------------------------

besteht aus einem vereinfachten Multi-Tasking-Kernel (das ist jener
Teil eines Betriebssystems, der sich darum kÅmmert, daû scheinbar
mehrere Aufgaben gleichzeitig erledigt werden), einem Bildschirm-
manager und elf Funktionsbibliotheken fÅr folgende Aufgabenbereiche:

˘ \#Applikation\#sverwaltung (appl_...)
˘ \#Ereignisverwaltung\#     (evnt_...)
˘ \#MenÅs\#                  (menu_...)
˘ \#Objekte\#                (objc_...)
˘ \#Formulare\#              (form_...)
˘ \#Grafikfunktionen\#       (graf_...)
˘ \#Zwischenspeicher\#       (scrp_...)
˘ \#Dateiauswahl\#           (fsel_...)
˘ \#Fenster\#verwaltung      (wind_...)
˘ \#Resource\#organisation   (rsrc_...)
˘ \#Shell\#-Kommunikation    (shel_...)

Um AES-Funktionen in einem Programm verwenden zu kînnen, mÅssen die
\link("%%GLOBAL%%")Prototypen\# in der Deklarationsdatei AES.H mittels #include-Anweisung
verfÅgbar sein.
\end

screen( "Ereignisverwaltung" )
Die Ereignisfunktionen auf einen Blick
----------------------------------------------------------------------

\#evnt_button\# Auf Maustastendruck warten.
\#evnt_dclick\# Doppelklickintervall ermitteln oder Ñndern.
\#evnt_keybd\#  Auf Tastendruck warten.
\#evnt_mesag\#  Auf Mitteilung warten.
\#evnt_mouse\#  Auf Mausbewegungen in ein Rechteck hinein (oder auch
            heraus) warten.
\#evnt_multi\#  Auf mehrere Ereignisse wie Maustastendruck,
            Mausbewegungen usw. gleichzeitig warten.
\#evnt_timer\#  Eine bestimmte Zeitspanne lang warten.


Ereignisse im Multi-Tasking-Betrieb

Alle Benutzereingaben werden unter \#GEM\# als Ereignisse aufgefaût.
Folgende Ereignisse kînnen nun auftreten:

               ˘ Tastatureingaben
               ˘ Mausbewegungen
               ˘ Maustastendruck
               ˘ Zeitgeber Timeout
               ˘ Mitteilungen

Alle diese Ereignisse haben eine Gemeinsamkeit: Sie werden auûerhalb
des betrachteten Programms erzeugt. Sie kînnen deshalb nur durch
spezielle Vorkehrungen abgefangen werden.
Um Benutzeraktionen in einem Programm entgegenzunehmen, gibt es zwei
grundsÑtzliche Strategien: Polling und Interruptsteuerung. Polling be-
deutet, daû der Anwender von Zeit zu Zeit selbst nachfragen muû, ob
gerade ein bestimmtes Ereignis eingetreten ist. Mehrere EingabegerÑte
gleichzeitig per Polling abzufragen, ohne daû Benutzerereignisse ver-
loren gehen, ist eine sehr aufwendige Angelegenheit, die die meisten
Anwenderprogramme um ein Vielfaches komplizierter machen wÅrde. \#GEM\#
bietet deshalb in Form von \#evnt_multi\# eine Funktion an, die im Stande
ist, mehrere Benutzerereignisse gleichzeitig abzufangen und zu verwal-
ten. Die interne Organisation dieser Funktion beruht natÅrlich auf
einem Interuptmechanismus, so daû Ereignisse nicht verloren gehen
kînnen.
Die Funktion \#evnt_multi\# kann ganz spezifisch je nach den Anforderungen
des Anwenderprogramms auf bestimmte Ereignisse angesetzt werden. WÑh-
rend der Zeit, in der \#evnt_multi\# auf Ereignisse wartet, kînnen andere
\#GEM\#-Programme im Hintergrund abgearbeitet werden. Die Ereignisverwal-
tung ist demnach sehr eng mit dem Multi-Tasking-Kernel verknÅpft.
Das Multi-Tasking-Schema ist jedoch sehr einfach ausgelegt. Es kînnen
lediglich bis zu fÅnf Tasks (sprich Aufgaben) gleichzeitig ablaufen:
Drei Accessory-Programme, eine Applikation und der Bildschirmmanager.
Die einzelnen Tasks werden der Reihe nach mit Hilfe eines Dispatchers
abgearbeitet. Ein Dispatcher ist ein Programm im \#Betriebssystem\#, das
vergleichbar ist mit einem Dirigenten in einem Orchester. Seine Auf-
gabe ist es den Mitspielern im richtigen Moment den Einsatz zu geben.
Jeder AES-Prozeû lÑuft nun dauernd durch die Schleife des Dispatchers.
Wenn die \#Applikation\# noch auf ein Ereignis wartet, wird sie in die
Reihe der noch nicht fertigen Prozesse gelegt. Tritt das Ereignis ein,
dann kommt der Prozeû in die Warteschlange der fertigen Prozesse und
muû dort solange auf die Weiterverarbeitung warten, bis die bereits
wartenden Prozesse vor ihm abgearbeitet wurden. Schlieûlich wird das
Programm abgearbeitet und nach einem Aufruf einer evnt-Funktion wieder
in die Reihe der noch nicht fertigen Prozesse eingereiht. Falls das
Programm jedoch auf kein Ereignis warten muû, kann es sich direkt an
der Schlange der fertigen Prozesse anstellen.
Die Umschaltung von einer Task auf die andere kann nur wÑhrend des
Aufrufs von AES-Funktionen erfolgen. Ein Programm, das Åber weite
Strecken lediglich \#VDI\#-Fumktionen oder \#Betriebssystem\#-Funktionen
verwendet, lÑuft demnach Gefahr, andere Applikationen vîllig abzu-
hÑngen.
Dem Bildschirmmanager kommt als eigenstÑndige Task eine sehr wichtige
Aufgabe zu: Er verwaltet alle Mausbewegungen im Zusammenhang mit
selektierbaren Bildschirmbereichen, wie zum Beispiel den \#MenÅs\#. Wird
zum Beispiel ein MenÅpunkt ausgewÑhlt, dann sendet der Bildschirmmana-
ger eine Mitteilung Åber dieses Ereignis an das Anwenderprogramm.
Alle Ereignisse, die von \#evnt_multi\# auf einmal abgefangen werden
kînnen, lassen sich auch einzeln ermitteln. \#evnt_keybd\# nimmt alle
Tastatur-Eingaben entgegen. \#evnt_button\# ist fÅr die Maustasten zu-
stÑndig. Die Geschwindigkeit bei Doppelklicks kann mit \#evnt_dclick\#
anwendungsspezifisch eingestellt werden. Mit \#evnt_mouse\# werden die
Bewegungen der Maus Åberwacht. Mitteilungen werden Åber die Funktion
\#evnt_mesag\# analysiert. Die Funktion \#evnt_timer\# legt eine Time-
out-Periode fest. WÑhrend die letztgenannten Einzelfunktionen nur in
Spezialsituationen zum Einsatz kommen, stellt \#evnt_multi\# das Kern-
stÅck eines jeden \#GEM\#-Programms dar. Nach den Initialisierungen
von Bildschirm, \#MenÅs\# und \#Resource\#-Set bewegt man sich normalerweise
in einer Endlosschleife, die nur bei schweren Fehlern oder der Option
Quit verlassen wird.
\end

screen( capsensitive("evnt_keybd") )
Name           Event Keyboard - wartet auf ein Tastaturereignis.

Definition     int evnt_keybd( void );

Prototyp in    aes.h

Beschreibung   evnt_keybd wartet auf ein Tastaturereignis.
Ergebnis       Die Funktion liefert als Funktionswert den Scancode
               der gedrÅckten Taste bzw. die Tastenkombination.

Gruppe         \#Ereignisverwaltung\#
Querverweis    \#evnt_multi\#
\end

screen( capsensitive("evnt_button") )
Name           Event Button - wartet auf einen Mausknopfereignis.

Definition     int evnt_button( int ev_bclicks, int ev_bmask,
                                int ev_bstate, int *ev_bmx,
                                int *ev_bmy, int *ev_bbutton,
                                int *ev_bkstate );

Prototyp in    aes.h

Beschreibung   Die Funktion wartet auf einen Button-Event, d.h. bis
               die in ev_bmask spezifizierten Mausknîpfe ev_bclicks
               mal in den in ev_bstate angegeben Zustand versetzt
               werden.
ev_bclicks     die Anzahl der nîtigen Clicks
ev_bmask       einen Bitvektor, der die zu betrachtenden Knîpfe mit
               einer 1 maskiert. Dabei ist der "linkeste" Knopf das
               niederwertigste Bit.
ev_bstate      einen Bitvektor wie ev_bmask, der fÅr jeden Knopf
               festlegt welchen Status er ereichen muû:
               1 = gedrÅckt, 0 = nicht gedrÅckt
ev_bmx,ev_bmy  die x bzw. y Koordinate der Maus zum Zeitpunkt des
               Auftretens des Ereignisses
ev_bbutton     der Zustand der Mausknîpfe beim Auftreten des
               Ereignisses
ev_bkstate     den Zustand der Sondertasten der Tastatur beim
               Auftreten des Ereignisses
               0x001   rechte Shifttaste
               0x002   linke Shifttaste
               0x004   Controltaste
               0x008   Alternatetaste
               Bei gedrÅckter Taste wird das entsprechende Bit gesetzt
Ergebnis       Die Funktion liefert die Anzahl der tatsÑchlich
               vorgenommenen Mausklicks.
Gruppe         \#Ereignisverwaltung\#
Querverweis    \#evnt_multi\#
\end

screen( capsensitive("evnt_dclick") )
Name           Event Doubleclick - ermittelt oder legt den Zeitraum
               zwischen den beiden Klicks eines Doppelklicks fest.

Definition     int evnt_dclick( int ev_dnew, int ev_dgetset );

Prototyp in    aes.h

Beschreibung   Mit evnt_dclick kann man die Zeit ermitteln
               (ev_tgetset = 0) oder auf den Wert ev_dnew stellen
               (ev_dgetset <> 0), die zwischen zwei aufeinander-
               folgenden Klicks mit der Maustaste vergehen darf, sodaû
               das AES diese zwei Klicks als einen DoppelKlick
               interpretiert. Die Werte fÅr den Parameter ev_dnew
               liegen zwischen 0 und 4, wobei 4 fÅr die kÅrzeste
               Zeitspanne steht.
Ergebnis       Die Funktion liefert die tatsÑchliche
               Doppelklickgeschwindigkeit.
Gruppe         \#Ereignisverwaltung\#
\end

screen( capsensitive("evnt_mesag") )
Name           Event Message - wartet auf eine Mitteilung des AES.

Definition     int evnt_mesag( int *ev_mgpbuff );

Prototyp in    aes.h

Beschreibung   Diese Funktion wartet auf das Eintreten eines
               Mesassage-Events, d. h. bis eine andere Applikation
               oder der Screenmanager der Applikation etwas mitteilen.
               \#ev_mgpbuff\# zeigt dabei auf einen 16 Byte groûen
               Buffer.
Ergebnis       Als Ergwebnis wir immer 1 zurÅckgegeben.
Gruppe         \#Ereignisverwaltung\#
\end

screen( capsensitive("AC_CLOSE"),
		capsensitive("WM_SIZED"),
		capsensitive("AC_OPEN"),
		capsensitive("ev_mgpbuff"),
		capsensitive("WM_REDRAW"),
		capsensitive("WA_DNLINE"),
		capsensitive("WM_TOPPED"),
		capsensitive("WA_DNPAGE"),
		capsensitive("WM_VSLID"),
		capsensitive("WA_LFLINE"),
		capsensitive("WA_LFPAGE"),
		capsensitive("WA_RTLINE"),
		capsensitive("WA_RTPAGE"),
		capsensitive("WA_UPLINE"),
		capsensitive("MN_SELECTED"),
		capsensitive("WA_UPPAGE"),
		capsensitive("WM_ARROWED"),
		capsensitive("WM_CLOSED"),
		capsensitive("WM_FULLED"),
		capsensitive("WM_HSLID"),
		capsensitive("WM_NEWTOP"),
		capsensitive("WM_MOVED") )
Die Standardmessages des Screenmanagers sind wie folgt aufgebaut:

ev_mgpbuff[0]  Art der Message
ev_mgpbuff[1]  Identifikator der Applikation, die die Nachricht
               abgeschickt hat
ev_mgpbuff[2]  Anzahl der Bytes die Åber die StandardlÑnge von 16
               Bytes hinausgeht, die dann mit \#appl_read\# gelesen werden
               mÅssen

Arten der Standardmessages:

MN_SELECTED    ein MenÅeintrag wurde ausgewÑhlt
                ev_mgpbuff[3]  Objektnummer des Titeleintrags
                ev_mgpbuff[4]  Objektnummer des Eintrags
WM_REDRAW      ein Fensterbereich muû neu gezeichnet werden
                ev_mgpbuff[3]  Handle des neuzuzeichnenden Fensters
                ev_mgpbuff[4]  x-Koordinate des Bereichs
                ev_mgpbuff[5]  y-Koordinate des Bereichs
                ev_mgpbuff[6]  Breite des Bereichs
                ev_mgpbuff[7]  Hîhe des Bereichs
WM_TOPPED      ein Fenster soll zum oben liegenden Fenster werden
                ev_mgpbuff[3]  Handle des nach oben zu holenden
                               Fensters
WM_CLOSED      das oberste Fenster soll geschlossen werden
                ev_mgpbuff[3]  Handle des zu schlieûenden Fensters
WM_FULLED      der Fullsizeknopf des obersten Fensters wurde
               angeklickt
                ev_mgpbuff[3]  Handle des Fensters, das auf volle
                               Grîûe gebracht werden soll
WM_ARROWED     ein Pfeil oder Rollbalken wurde angeclickt
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  einer der folgenden Werte:
                               WA_UPPAGE  Seite nach oben
                               WA_DNPAGE  Seite nach unten
                               WA_UPLINE  Zeile nach oben
                               WA_DNLINE  Zeile nach unten
                               WA_LFPAGE  Seite nach links
                               WA_RTPAGE  Seite nach rechts
                               WA_LFLINE  Spalte nach links
                               WA_RTLINE  Spalte nach rechts
WM_HSLID       der horizontale Rollbalken wurde verschoben
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  die neue Sliderposition
                               (0 ganz links bis 1000 ganz rechts)
WM_VSLID       der vertikale Rollbalken wurde verschoben
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  die neue Sliderposition
                               (0 ganz oben bis 1000 ganz unten)
WM_SIZED       die Fenstergrîûe wurde verÑndert
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  neue x-Koordinate (unverÑndert)
                ev_mgpbuff[5]  neue y_Koordinate (unverÑndert)
                ev_mgpbuff[6]  neue Fensterbreite
                ev_mgpbuff[7]  neue Fensterhîhe
WM_MOVED       das ganze Fenster wurde verschoben
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  neue x-Koordinate
                ev_mgpbuff[5]  neue y_Koordinate
                ev_mgpbuff[6]  neue Fensterbreite (unverÑndert)
                ev_mgpbuff[7]  neue Fensterhîhe (unverÑndert)
WM_NEWTOP      das Fenster wurde nach oben gebracht
                ev_mgpbuff[3]  Handle des Fensters
AC_OPEN        ein Accessory wurde aktiviert
                ev_mgpbuff[4]  Identifikator des Accessories
AC_CLOSE       wird an ein Accessory geschickt, wenn die aktuelle
               Applikation beendet wird und der Bildschirm gelîscht
               wird und der Windowmanager neu initialisiert wird
                ev_mgpbuff[4]  Identifikator des Accessories

Querverweis:    \#evnt_multi\# \#evnt_mesag\#
\end

screen( capsensitive("evnt_mouse") )
Name           Event Mouse - wartet darauf, daû der Mauszeiger in
               einen Bereich hinein- oder hinausgeschoben wird.

Definition     int evnt_mouse( int ev_moflags, int ev_mox, int ev_moy,
                               int ev_mowidth, int ev_moheight,
                               int *ev_momx, int *ev_momy,
                               int *ev_mobutton, int *ev_mokstate );

Beschreibung   Die Funktion wartet darauf bis der Mauszeiger aus oder
               in ein angegebenes Rechteck bewegt wird.
ev_moflags     bei 1 wird ein Event erzeugt, wenn der Mauszeiger das
               Rechteck verlÑût, bei 0 wird der Event erzeugt, wenn
               der Mauszeiger das Rechteck betritt.
ev_mox,ev_moy  x und y Koordinate des zu Åberwachenden Rechtecks
ev_mowidth     Breite des zu Åberwachenden Rechtecks
ev_moheight    Hîhe des zu Åberwachenden Rechtecks
ev_momx,ev_momy die x und y Koordinate des Mauszeigers beim Betreten
                bzw. Verlassen des Rechtecks
ev_mobutton    der Zustand der Mausknîpfe beim Eintreten des Events
               (Format siehe \#evnt_button\#)
ev_mokstate    den Zustand der Sondertasten der Tastatur beim
               Auftreten des Events (Format siehe \#evnt_button\#)
Ergebnis       Als Ergebnis wird immer eine 1 zurÅckgeliefert.
Gruppe         \#Ereignisverwaltung\#
\end

screen( capsensitive("evnt_multi") )
Name           Event Multi - wartet auf ein beliebiges Ereignis.

Definition     int evnt_multi( int ev_mflags, int ev_mbclicks,
                               int ev_mbmask, int ev_mbstate,
                               int ev_mm1flags, int ev_mm1x,
                               int ev_mm1y, int ev_mm1width,
                               int ev_mm1height, int ev_mm2flags,
                               int ev_mm2x, int ev_mm2y,
                               int ev_mm2width, int ev_mm2height,
                               int *ev_mmgpbuff, int ev_mtlocount,
                               int ev_mthicount, int *ev_mmox,
                               int *ev_mmoy, int *ev_mmbutton,
                               int *ev_mmokstate, int *ev_mkreturn,
                               int *ev_mbreturn );

Prototyp in    aes.h

Beschreibung   Die evnt_multi Funktion wartet auf eine Reihe
               verschiedener Events.
ev_mflags      auf welche Events soll gewartet werden
                Keyboardevent   Bit 0 gesetzt   MU_KEYBD
                Buttonevent     Bit 1 gesetzt   MU_BUTTON
                Mouseevent 1    Bit 2 gesetzt   MU_M1
                Mouseevent 2    Bit 3 gesetzt   MU_M2
                Messageevent    Bit 4 gesetzt   MU_MESAG
                Timerevent      Bit 5 gesetzt   MU_TIMER
ev_mbclicks    Anzahl der Klicks, siehe ev_bclicks in \#evnt_button\#
ev_mbmask      welche Mausknîpfe sollen betrachtet werden
               (Format siehe ev_bmask in \#evnt_button\#)
ev_mbstate     welchen Zustand mÅssen die Mausknîpfe einnehmen
               (Format, siehe ev_bstate in \#evnt_button\#)
ev_mm1flags    soll der Event beim Betreten (0) oder Verlassen (1) des
               ersten Rechtecks ausgelîst werden, siehe ev_moflags in
               \#evnt_mouse\#
ev_mm1x,ev_mm1y x und y Koordinate des ersten Rechtecks, siehe ev_mox,
                ev_moy in \#evnt_mouse\#
ev_mm1width    die Breite des ersten Rechtecks, siehe ev_mowidth in
               \#evnt_mouse\#
ev_mm1height   die Hîhe des ersten Rechtecks, siehe ev_moheight in
               \#evnt_mouse\#
ev_mm2flags,
ev_mm2x,
ev_mm2y,
ev_mm2width,
ev_mm2height   sind die Parameter fÅr das zweite Mouseevent Rechteck
ev_mmgpbuff    ein 16 Byte Messagebuffer, siehe \#evnt_mesag\# und
               \#ev_mgpbuff\#
ev_mtlocount   low-Word fÅr den Timercounter, siehe \#evnt_timer\#
ev_mthicount   high-Word fÅr den Timercounter, siehe \#evnt_timer\#
ev_mmox,ev_mmoy die x und y Koordinate des Mauszeigers beim Auftreten
                des Events, siehe \#evnt_mouse\#
ev_mmobutton   Zustand der Mausknîpfe beim Auftreten des Events
               (Format siehe \#evnt_button\#)
ev_mmokstate   den Zustand der Sondertasten der Tastatur beim
               Auftreten des Events (Format, siehe \#evnt_button\#)
ev_mkreturn    der Scancode der gedrÅckten Taste
ev_mbreturn    Anzahl der Klicks mit der Maustaste

Ergebnis       Als Ergebnis liefert die Funktion die Nummer des oder
               der aufgetretenen Events im oben angegeben Format.
Gruppe         \#Ereignisverwaltung\#
Querverweis    \#evnt_keybd\#   \#evnt_button\#   \#evnt_mouse\#   \#evnt_mesag\#
               \#evnt_timer\#   \#evnt_dclick\#
\end

screen( capsensitive("evnt_timer") )
Name           Event Timer - wartet einen Zeitabschnitt ab.

Definition     int evnt_timer( int ev_tlocount, int ev_thicount );

Prototyp in    aes.h

Beschreibung   Die Funktion wartet bis die Zeit, die durch ev_tlocount
               und ev_thicount in Millisekunden vorgegeben wird,
               verstrichen ist.
Ergebnis       Als Ergebnis wird immer eine 1 zurÅckgeliefert.
Gruppe         \#Ereignisverwaltung\#
\end

screen( "Fenster" )
Die Fensterfunktionen auf einen Blick:
----------------------------------------------------------------------

\#wind_calc\#   Fensterdimensionen berechnen.
\#wind_close\#  Fenster schlieûen.
\#wind_create\# Fenster erzeugen.
\#wind_delete\# Fenster lîschen.
\#wind_find\#   Fensterhandle anhand einer Positionsangabe ermitteln.
\#wind_get\#    Eigenschaften eines Fensters ermitteln.
\#wind_new\#    Alle Fenster lîschen.
\#wind_open\#   Fenster îffnen.
\#wind_set\#    Eigenschaften eines Fensters verÑndern.
\#wind_update\# Bildschirmoperationen sperren oder freigeben.


Fenster als Benutzerumgebung

Aus der Sicht des Anwenders ist die Integration von Fenstern die wohl
herausragendste Eigenschaft des \#GEM\#-Betriebssystems. Die Maus ist
dabei die ideale ErgÑnzung fÅr den Umgang mit Fenstern. Ein Fenster
besteht aus einer Reihe von bestimmten Einheiten, die entsprechend den
Anforderungen der \#Applikation\# gesetzt werden kînnen.

Im Mittelpunkt eines Fensters steht immer die ArbeitsflÑche, auf der
ein bestimmtes Objekt, wie zum Beispiel ein Text oder eine Grafik,
ganz oder in Ausschnitten dargestellt wird. Die Titelleiste gibt dem
Fenster einen Namen, dient aber gleichzeitig auch zum Verschieben des
Fensters auf dem Bildschirm. Mit der Schlieûbox (links oben) kann das
Fenster geschlossen werden. Klickt man die Full-Box (rechts oben) an,
wird das eventuell verkleinerte Fenster auf seine volle Grîûe ge-
bracht. Die Informationszeile ist fÅr kurze Mitteilungen an den Be-
nutzer gedacht. Mit den Pfeilen (auf und ab, links und rechts) erhÑlt
ein Programm die Mitteilung, daû der Inhalt des Fensters in die ent-
sprechende Richtung verschoben werden soll. Die horizontalen und ver-
tikalen Schieber ermîglichen die absolute Positionierung der Arbeits-
flÑche eines Fensters. Mit der Grîûeneinstellungsbox (rechts unten)
kînnen Sie ein Fenster zumeist stufenlos vergrîûern bzw. verkleinern.
Um ein Fenster anzulegen, muû es zuerst mit der Funktion \#wind_create\#
erzeugt werden. Beim Anlegen wird das Fenster im Speicher initiali-
siert. Es wird gleichzeitig festgelegt, aus welchen Bestandteilen sich
das Fenster zusammensetzen soll und welche maximale Grîûe das Fenster
einnehmen darf. Man kann zwar die Grîûe eines Fenster beim ôffnen mit
\#wind_open\# in beliebigen Schritten kleiner einstellen als beim Anlegen
mit \#wind_create\#, aber \#GEM\# muû fÅr seine Speicherbereichsverwaltung
genau wissen, wie groû das Fenster maximal werden kann. Geîffnete Fen-
ster kînnen mit \#wind_close\# wieder geschlossen werden. Sie sind damit
jedoch noch nicht aus dem Speicher entfernt worden und kînnen mit
\#wind_open\# erneut aktiviert werden. Soll ein geschlossenes Fenster auch
aus dem Speicher entfernt werden, so geschieht dies mit der Funktion
\#wind_delete\#. Mit Hilfe der Funktion \#wind_get\# lassen sich aktuelle
Einstellungen eines Fensters jederzeit abfragen. So erhÑlt man Infor-
mationen Åber die Position, die Grîûe, die verwendeten Fensterbestand-
teile, usw. Besonders wichtig ist meist die Stellung der horizontalen
und vertikalen Schieber. In umgekehrter Weise, kann man einzelne
Parameter eines Fensters mit Hilfe der Funktion \#wind_set\# auch direkt
vom Programm aus festlegen. Die meisten VerÑnderungen in den Fenstern
werden jedoch automatisch vom Bildschirmmanager Åberwacht. Wenn der
Anwender bestimmte SchlÅsselbereiche anklickt, sendet der Bildschirm-
manager sofort eine Mitteilung an das Programm, das mit Hilfe der
\#Ereignisverwaltung\# sofort die richtigen Aktionen in die Wege leiten
kann. Im Endeffekt liegt die gesamte Verantwortung fÅr die Verwaltung
der Fenster beim Anwenderprogramm.
Wenn man den Fensterinhalt verÑndern will, sollte man zuvor mit der
Funktion \#wind_update\# alle anderen Bildschirmoperationen verbieten.
Ansonsten kînnte es passieren, daû eine andere \#Applikation\# zur selben
Zeit wie Sie den Bildschirm restaurieren will, und es entsteht Bild-
schirmsalat. Man darf aber nicht vergessen, den Bildschirm anschlie-
ûend erneut mit der Funktion \#wind_update\# fÅr weitere Bildschirm-
operationen wieder frei zugeben, da ansonsten auch alle \#MenÅs\# und
Accessories ausgeschaltet blieben.
\end

screen( capsensitive("wind_create") )
Name           Window create - meldet ein neues Fenster an.

Definition     int wind_create( int wi_crkind, int wi_crwx,
                                int wi_crwy, int wi_crww,
                                int wi_crwh );

Prototyp in    aes.h

Beschreibung   Die Funktion versucht beim AES ein neues Fenster
               anzumelden und legt dabei gleichzeitig sein Aussehen
               und die maximale Grîûe fest.
wi_crwx, wi_crwy, wi_crww, wi_crwh legen die maximale
               Ausdehnung des Fensters fest.
               wi_crkind beschreibt das Fensters als Bitvektor:
  NAME         0x0001   Titelzeile
  CLOSER       0x0002   Schlieûbox
  FULLER       0x0004   Volle-Grîûe-Box
  MOVER        0x0008   Fenster kann bewegt werden
  INFO         0x0010   Infozeile
  SIZER        0x0020   Grîûenverstellungsbox
  UPARROW      0x0040   Pfeil nach oben
  DNARROW      0x0080   Pfeil nach unten
  VSLIDE       0x0100   vertikaler Slider
  LFARROW      0x0200   Pfeil nach links
  RTARROW      0x0400   Pfeil nach rechts
  HSLIDE       0x0800   horizontaler Slider
Ergebnis       Die Funktion liefert ein nicht negatives Handle, falls
               das AES noch ein freies Windowhandle zur VerfÅgung hat.
               Ein RÅckgabewert kleiner Null signalisiert einen Fehler
               oder keine weiteren Handles mehr.
Gruppe         \#Fenster\#
Querverweis    \#wind_delete\#
\end

screen( capsensitive("wind_open") )
Name           Open Window - îffnet ein Fenster.

Definition     int wind_open( int wi_ohandle, int wi_owx, int wi_owy,
                              int wi_oww, int wi_owh );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt ein Fenster mit dem Handle
               wi_ohandle aus dem \#wind_create\#-Aufruf an den
               Koordinaten wi_owx und wi_owy mit den Maûen wi_oww
               und wi_owh dar.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgeliefert wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#   \#wind_close\#
\end

screen( capsensitive("wind_new") )
Name           New Window - schlieût alle Fenster.
               (erst ab TOS Version 1.4 verfÅgbar)

Definition     void wind_new(void);

Prototyp in    aes.h

Beschreibung   Die Funktion schlieût und lîscht alle Fenster und
               Åbergibt die Mauskontrolle wieder an das System.
Ergebnis       Diese Funktion liefert kein Ergebnis
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#   \#wind_close\#
\end

screen( capsensitive("wind_close") )
Name           Close Window - schlieût ein Fenster.

Definition     int wind_close( int wi_clhandle );

Prototyp in    aes.h

Beschreibung   Die Funktion schlieût das vorher mit \#wind_open\#
               geîffnete Fenster mit dem Handle wi_clhandle wieder,
               gibt aber das Windowhandle nicht frei. Das Fenster
               kann also jederzeit wieder erîffnet werden.
Ergebnis       Ein Fehler ist nur dann aufgeteten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_open\#
\end

screen( capsensitive("wind_delete") )
Name           Delete Window - lîscht ein Fenster.

Definition     int wind_delete( int wi_dhandle );

Prototyp in    aes.h

Beschreibung   Die Funktion lîscht das Fenster mit dem Handle
               wi_dhandle wieder vollstÑndig und gibt das Windowhandle
               wieder frei. Die Funktion ist also das GegenstÅck zu
               \#wind_create\#.
Ergebnis       Ein Fehler ist nur dann aufgeteten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#  \#wind_close\#
\end

screen( capsensitive("wind_get") )
Name           Get Window - ermittelt die Parameter eines Fensters.

Definition     int wind_get( int wi_ghandle, int wi_gfield, ... );

Prototyp in    aes.h

Beschreibung   Die Funktion liefert je nach Wert des Parameters
               wi_gfield verschiedene Informationen Åber das Fenster
               mit dem Handle wi_ghandle. Dabei sind die zusÑtzlichen
               Parameter wi_gw1, wi_gw2, wi_gw3 und wi_gw4 alles
               Zeiger auf Integerwerte,also
               int *wi_gw1, *wi_gw2, *wi_gw3, *wi_gw4;
wi_gfield:
WF_WORKXYWH    berechnet die Koordinaten des Arbeitsbereichs des
               Fensters und schreibt sie in die weiteren Parameter
               wi_gw1, wi_gw2, wi_gw3 und wi_gw4.
WF_CURRXYWH    berechnet die Gesamtgrîûe des Fenster und schreibt sie
               in die weiteren Parameter wi_gw1, wi_gw2, wi_gw3 und
               wi_gw4.
WF_PREVXYWH    berechnet die Gesamtgrîûe des vorherigen Fensters und
               schreibt sie in die weiteren Paramter wi_gw1, wi_gw2,
               wi_gw3 und wi_gw4.
WF_FULLXYWH    berechnet die maximale Gesamtgrîûe des Fensters und
               schreibt sie in die weiteren Parameter wi_gw1, wi_gw2,
               wi_gw3 und wi_gw4.
WF_HSLIDE      berechnet die Position des horizontalen Sliders und
               schreibt sie in den weiteren Parameter wi_gw1 (1 ganz
               links, bis 1000 ganz rechts).
WF_VSLIDE      berechnet die Position des vertikalen Sliders und
               schreibt sie in den weiteren Parameter wi_gw1 (1 ganz
               oben, bis 1000 ganz unten).
WF_TOP         liefert das Handle des obersten Fensters und schreibt
               es in den weiteren Parameter wi_gw1.
WF_FIRSTXYWH   berechnet die Koordinaten des ersten Rechtecks in der
               Rechtecksliste und schreibt sie in die weiteren
               Parameter wi_gw1, wi_gw2, wi_gw3 und wi_gw4.
WF_NEXTXYWH    berechnet die Koordinaten des nÑchsten Rechtecks in der
               Rechtecksliste und schreibt sie in die weiteren
               Parameter wi_gw1, wi_gw2, wi_gw3 und wi_gw4.
WF_RESVD       reserviert.
WF_HSLSIZE     berechnet die Grîûe des horizontalen Sliders relativ
               zur Gesamtbreite und schreibt sie in den zusÑtzlichen
               Parameter wi_gw1 (-1 kleinste Grîûe, 1 klein bis 1000
               Gesamtbreite).
WF_VSLSIZE     berechnet die Hîhe des vertikalen Sliders relativ zur
               Gesamthîhe und schreibt sie in den zusÑtzlichen
               Parameter wi_gw1 (-1 kleinste Hîhe, 1 klein bis 1000
               Gesamthîhe).
WF_SCREEN      liefert die Adresse und LÑnge des internen Buffers, in
               dem das AES den Hintergrund von DropdownmenÅs und
               Alertboxen zwischenspeichert und schreibt sie in die
               weiteren Parameter wi_gw1 Highword der Adresse,
               wi_gw2 Lowword der Adresse, wi_gw3 Highword der LÑnge
               und wi_gw4 Lowword der LÑnge.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Fenster\#
\end

screen( capsensitive("wind_set") )
Name           Set Window - verÑndert einzelne Parameter eines
               Fensters.

Definition     int wind_set( int wi_shandle, int wi_sfield, ... );

Prototyp in    aes.h

Beschreibung   Die Funktion verÑndert das Fenster mit dem Handle
               wi_shandle, je nach Wert des Parameters wi_sfield.
               Dabei sind die zusÑtzlichen Parameter wi_sw1, wi_sw2,
               wi_sw3 und wi_sw4 alles Integerwerte, also:
               int wi_sw1, wi_sw2, wi_sw3, wi_sw4;
wi_sfield
WF_KIND        legt wi_sw1 als neue Fensterkomponenten fest, Format
               wie bei \#wind_create\#.
WF_NAME        schreibt den String, auf den wi_sw1 und wi_sw2 zeigt,
               in die Titelzeile.
WF_INFO        schreibt den String, auf den wi_sw1 und wi_sw2 zeigt,
               in die Infozeile.
WF_CURRXYWH    setzt die Fenstergrîûe aus wi_sw1, wi_sw2, wi_sw3 und
               wi_sw4 fest.
WF_HSLIDE      setzt den horizontalen Slider auf die neue Position
               wi_sw1 (1 ganz links bis 1000 ganz rechts).
WF_VSLIDE      setzt den vertikalen Slider auf die neue Position
               wi_sw1 (1 ganz oben bis 1000 ganz unten).
WF_TOP         das Fenster mit dem Handle wi_shandle wird zum neuen
               oberen Fenster.
WF_NEWDESK     legt den Objektbaum, auf den wi_sw1 und wi_sw2 zeigt,
               mit dem Startobjekt wi_sw3 als neues Desktop fest.
WF_HSLSIZE     setzt die Grîûe des horizontalen Sliders relativ zur
               Gesamtbreite auf den Wert wi_sw1 (-1 kleinste Grîûe, 1
               klein bis 1000 Gesamtbreite).
WF_VSLSIZE     setzt die Hîhe des vertikalen Sliders relativ zur
               Gesamthîhe auf den Wert  wi_sw1 (-1 kleinste Hîhe, 1
               klein bis 1000 Gesamthîhe).
WF_COLOR       verÑndert die Farbe eines Fensterelements. Dazu wird
               in wi_sw1 Nummer des Elements angegeben:
               
               Element     Objekttyp  Beschreibung
               ----------------------------------------------------
               W_BOX       IBOX        Wurzelobjekt des Fensters
               W_TITLE     BOX         Elternobjekt der Schlieû-
                                       und Zoombox, sowie des Names
               W_CLOSER    BOXCHAR     Schlieûbox
               W_NAME      BOXTEXT     Move-Balken
               W_FULLER    BOXCHAR     Zoombox
               W_INFO      BOXTEXT     Infozeile
               W_DATA      IBOX        Elternobjekt der restlichen
                                       Elemente
               W_WORK      IBOX        ArbeitsflÑche
               W_SIZER     BOXCHAR     Size-Box
               W_VBAR      BOX         Elternobjekt der vertikalen
                                       Sliderelemente
               W_UPARROW   BOXCHAR     Pfeil nach oben
               W_DNARROW   BOXCHAR     Pfeil nach unten
               W_VSLIDE    BOX         Hintergrund des vert. Sliders
               W_VELEV     BOX         Vertikaler Slider
               W_HBAR      BOX         Elternobjekt der vertikalen
                                       Sliderelemente
               W_LFARROW   BOXCHAR     Pfeil nach links
               W_RTARROW   BOXCHAR     Pfeil nach rechts
               W_HSLIDE    BOX         Hintergrund des horiz. Sliders
               W_HELEV     BOX         Horizontaler Slider

               Im Parameter wi_sw2 wird die Farbe fÅr den Objekttyp
               des Fensterelements Åbergeben, falls das Fenster ge-
               toppt ist, in wi_sw3 falls es nicht aktiv ist. Ein
               Wert von -1 behÑlt die aktuelle Farbeinstellung
               bei (ab Atari TT verfÅgbar).
WF_DCOLOR      setzt die Standard-Farben fÅr die Fensterelemente.
               Der Parameter wi_shandle wird ignoriert (ab Atari TT
               verfÅgbar).

Hinweis zum Pure-C-Compiler:

Anstelle die Zeigerwerte, die Åbergeben werden mÅssen (z. B. bei
WF_NEWDESK), in zwei Integerwerte aufzuspalten, kann man gleich den
gesamten Zeiger als Parameter Åbergeben und dafÅr den zweiten
Integerparameter weglassen. Im obigen Beispiel lautet der Aufruf also:

        wind_set(wi_shandle,WF_NEWDESK,desk_tree,wi_sw3);

        OBJECT *desk_tree;
        int    wi_shandle, wi_sw3;

Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#   \#OBJECT\#
\end

screen( capsensitive("wind_find") )
Name           Find Window - sucht ein Fenster zu einem bestimmten
               Punkt.

Definition     int wind_find( int wi_fmx, int wi_fmy );

Prototyp in    aes.h

Beschreibung   Die Funktion berechnet das Windowhandle des Fensters
               das sich unter den Koordinaten wi_fmx, wi_fmy befindet.

Ergebnis       Die Funktion liefert das Windowhandle. Ein RÅckgabewert
               von Null signalisiert, daû sich kein Benutzerfenster an
               den angegebenen Koordinaten befindet, sondern nur das
               Desktopfenster, welches das Handle Null hat.
Gruppe         \#Fenster\#
Querverweis    \#wind_get\#
\end

screen( capsensitive("wind_update"),
		capsensitive("END_MCTRL"),
		capsensitive("BEG_UPDATE"),
		capsensitive("BEG_MCTRL"),
		capsensitive("END_UPDATE") )
Name           Update Window - bestimmt das Neuzeichnen eines Fensters.

Definition     int wind_update( int wi_ubegend );

Prototyp in    aes.h

Beschreibung   Die Funktion signalisiert dem AES, daû die
               Benutzerapplikation gerade den Bildschirm neu aufbaut.
               Das AES schrÑnkt daraufhin seine eigenen grafischen
               "TÑtigkeiten", wie z. B. das Herunterklappen von
               DropdownmenÅs, ein.
wi_ubegend     BEG_UPDATE  ein Fenster wird nach dem dem Aufruf
                           aufgebaut.
               END_UPDATE  Fensteraufbau ist abgeschlossen.
               BEG_MCTRL   das Anwenderprogramm mîchte die alleinige
                           Kontrolle Åber die Maus haben.
               END_MCTRL   das AES kann die Kontrolle wieder haben.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Fenster\#
\end

screen( capsensitive("WC_WORK"),
		capsensitive("WC_BORDER"),
		capsensitive("wind_calc") )
Name           Window Calculation - berechnet die Grenzen oder den
               gesamten Platzbedarf eines Fensters.

Definition     int wind_calc( int wi_ctype, int wi_ckind, int wi_cinx,
                              int wi_ciny, int wi_cinw, int wi_cinh,
                              int *coutx, int *couty, int *coutw,
                              int *couth );

Prototyp in    aes.h

Beschreibung   Die Funktion berechnet fÅr ein Fenster die Grîûe des
               Randbereichs aus den Koordinaten des Arbeitsbereichs
               oder aus den Koordinaten des Arbeitsbereichs die
               Koordinaten des Randbereichs.
wi_ctype       WC_BORDER  berechnet die Koordinaten des Randbereichs
               aus den Koordinaten des Arbeitsbereichs in den
               Parametern wi_cinx, wi_ciny, wi_cinw und wi_cinh.
               WC_WORK  berechnet die Koordinaten des Arbeitsbereichs
               aus den Koordinaten des Randbereichs in den Parametern
               wi_cinx, wi_ciny, wi_cinw und wi_cinh.
wi_crkind      ein Integerparameter der alle Komponenten des Fenster
               beeinhaltet, Format wie in \#wind_create\#
coutx, couty   die berechneten x und y Koordinaten
coutw, couth   die berechnete Ausdehnung
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#
\end

screen( "Objekte" )
Die Objektfunktionen auf einen Blick
----------------------------------------------------------------------

\#objc_add\#    Objekt im Objektbaum einfÅgen.
\#objc_change\# Status eine Objekts Ñndern.
\#objc_delete\# Objekt aus dem Objektbaum entfernen.
\#objc_draw\#   Objekt (mit Unterobjekten) darstellen.
\#objc_edit\#   Texte eines Objekts verÑndern.
\#objc_find\#   Objektindex Åber Position ermitteln.
\#objc_offset\# Bildschirmkoordinaten eines Objekts ermitteln.
\#objc_order\#  Reihenfolge im Objektbaum umstellen.


Die Basis des AES-Systems: Objekte

Objekte sind die Basiselemente des \#AES\#-Systems. Sie sind nichts an-
deres als Datenstrukturen namens \#OBJECT\#, mit deren Hilfe Grafikele-
mente, wie Alarmboxen, \#Fenster\#, \#MenÅs\# und Symbole beschrieben werden.
Alle Objekte werden in einem einheitlichen Objektbaum zusammengefaût.
Mit der Datenstruktur \#OBJECT\# hat man ein sehr flexibles Werkzeug zur
VerfÅgung, das gegenÅber einem BinÑrbaum den Vorteil hat, daû man auf
die einzelnen Objekte sowohl Åber eine vertikale Hierarchie als auch
Åber eine horizontale Anordnung zugreifen kann. Mit \#OBJECT\# findet man
nÑmlich die hÑufig benîtigten Elemente auf gleicher Hierarchiestufe
sehr leicht.
Die Programmierung eines Objektbaums kann zwar im Grunde mit Hilfe der
Definition eines Objektbaums durchgefÅhrt werden, doch schon bei klei-
neren Aufgaben erweist sich dieses Unterfangen aufgrund der enormen
DatenfÅlle als ziemlich aussichtslos. Aus diesem Grunde gibt es
\#Resource\# Construction Sets. Dies sind \#GEM\#-Programme, mit deren
Hilfe man die Objekte grafisch definieren kann. Die einzelnen Objekte
eines Programms werden dann in einer \#Resource\#datei gespeichert, aus
der sie bequem geladen werden kînnen.
Die wichtigste Funktion in der Objektbibliothek ist sicherlich
\#objc_draw\#, die fÅr das Zeichnen eines Objekts bzw. eines Objektbaumes
verantwortlich ist. Sehr nÅtzlich ist auch \#objc_change\#, da mit ihr
gleichzeitig der Objektstatus geÑndert und das betreffende Objekt
seinem neuen Status entsprechend neu gezeichnet werden kann. Wichtig
ist auch noch die Funktion \#objc_find\#, mit deren Hilfe man, ausgehend
von den Koordinaten einer Position, das darunter liegende Objekt er-
mitteln kann.
\end

screen( capsensitive("objc_add") )
Name           Object add - fÅgt ein Objekt im Objektbaum ein.

Definition     int objc_add( OBJECT *ob_atree, int ob_aparent,
                             int ob_achild );

Prototyp in    aes.h

Beschreibung   Die Funktion fÅgt im Objektbaum ob_atree das Objekt mit
               der Nummer ob_achild hierarchisch als Kind von
               ob_aparent ein.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#objc_delete\#
\end

screen( capsensitive("objc_delete") )
Name           Object delete - lîscht ein Objekt aus dem Objektbaum.

Definition     int objc_delete( OBJECT *ob_dltree, int ob_dlobject );

Prototyp in    aes.h

Beschreibung   Die Funktion lîscht das Objekt mit der Nummer
               ob_dlobject aus dem Objektbaum ob_dltree.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#objc_add\#
\end

screen( capsensitive("objc_draw") )
Name           Object draw - zeicnet ein Objekt.

Definition     int objc_draw( OBJECT *ob_drtree, int ob_drstart,
                              int ob_drdepth, int ob_drxclip,
                              int ob_dryclip, int ob_drwclip,
                              int ob_drhclip );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt ObjektbÑume oder Teile von
               ObjektbÑumen auf dem Bildschirm dar. Dabei ist
               ob_drtree der entsprechende Objektbaum und ob_drstart
               das Objekt, bei dem mit dem Zeichnen begonnen werden
               soll (also gleich Null, falls der ganze Baum gezeichnet
               werden soll).
ob_drdepth     gibt an, wieviele Stufen des Baumes ab dem Startobjekt
               gezeichnet werden sollen. ZusÑtzlich kann man noch ein
               Rechteck (ob_drxclip, ob_dryclip, ob_drwclip,
               ob_drhclip) angeben, auûerhalb dessen keine
               Zeichenoperationen stattfinden. Dies ist immer dann
               sinnvoll, wenn z. B. nach dem Schlieûen eines Fensters
               nur ein Teil des Objektbaumes vom Fenster bedeckt war
               und nun neugezeichnet werden soll.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("objc_find") )
Name           Objekt find - ermittelt, welches Objekt sich an der
               angegebenen Bildschirmposition befindet.

Definition     int objc_find( OBJECT *ob_ftree, int ob_fstartob,
                              int ob_fdepth, int ob_fmx, int ob_fmy );

Prototyp in    aes.h

Beschreibung   Die Funktion sucht in dem Objektbaum ob_ftree ab dem
               Objekt ob_fstartob bis in eine Verschachtelungstiefe
               von ob_fdepth nach der Objektnummer des Objekts, das
               unterhalb der Koordinaten ob_fmx, ob_fmy liegt.
Ergebnis       Als Ergebnis wird die Nummer des entsprechenden Objekts
               oder -1 fÅr "nicht gefunden" wird zurÅckgegeben.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("objc_offset") )
Name           Object Offset - berechnet die Position eines Objekts
               auf dem Bildschirm.

Definition     int objc_offset( OBJECT *ob_oftree, int ob_ofobject,
                                int *ob_ofxoff, int *ob_ofyoff );

Prototyp in    aes.h

Beschreibung   Die Funktion berechnet zu dem Objekt mit der Nummer
               ob_ofobject im Objektbaum ob_oftree die absoluten
               Bildschirmkoordinaten und schreibt diese in die
               RÅckgabeparameter ob_ofxoff und ob_ofyoff.
Ergebnis       Ein RÅckgabewert von Null signalisiert einen Fehler.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#  \#form_center\#
\end

screen( capsensitive("objc_order") )
Name           Object Order - ordnet ein Kind innerhalb des
               Objektbaumes neu an.

Definition     int objc_order( OBJECT *ob_ortree, int ob_orobject,
                               int ob_ornewpos );

Prototyp in    aes.h

Beschreibung   Die Funktion verschiebt das Objekt mit der Nummer
               ob_orobjekt im Objektbaum ob_ortree.
ob_ornewpos    0  bringt das Objekt auf die unterste Hierarchiestufe
               1  bringt das Objekt eine Stufe Åber die unterste
                  Hierarchiestufe
               2  bringt das Objekt zwei Stufen Åber die unterste
                  Hierarchiestufe
                          :
                          :
               -1 bringt das Objekt ganz nach oben
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("objc_edit") )
Name           Object edit - editiert einen Text in einem Objekt.

Definition     int objc_edit( OBJECT *ob_edtree, int ob_edobject,
                              int ob_edchar, int *ob_edidx,
                              int ob_edkind );

Prototyp in    aes.h

Beschreibung   Die Funktion ermîglicht es in Objekttypen G_FTEXT und
               G_FBOXTEXT Text einzufÅgen. Dabei ist ob_edtree der
               entsprechende Objektbaum, ob_edobjekt das zu
               editierende Objekt, ob_edchar das einzufÅgende
               Zeichen und ob_edidx die Position des Textcursors.
ob_edkind      ED_START  Reserviert.
               ED_INIT   Berechnet aus te_ptext und te_ptmptl einen
                         formatierten String und schaltet den
                         Grafikcursor ein.
               ED_CHAR   Eigentliches EinfÅgen, wie oben beschrieben.
               ED_END    Cursor wieder ausschalten.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#TEDINFO\#
\end

screen( capsensitive("objc_change") )
Name           Object change - verÑndert die Darstellung eines Objekts
               innerhalb der angegebenen Grenzen.

Definition     int objc_change( OBJECT *ob_ctree, int ob_cobject,
                                int ob_cresvd, int ob_cxclip,
                                int ob_cyclip, int ob_cwclip,
                                int ob_chclip, int ob_cnewstate,
                                int ob_credraw );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Objektstatus des Objekts mit der
               Nummer ob_cobject im Objektbaum ob_ctree auf den Wert
               ob_cnewstate. Ist ob_credraw gleich Eins, so wird das
               Objekt innerhalb des Begrenzungsrechtecks mit den
               Koordinaten ob_cxclip, ob_cyclip, ob_cwclip, ob_chclip
               neu gezeichnet. Der Parameter ob_cresvd hat keine
               Bedeutung, muû aber Null sein.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#ob_state\#
\end

screen( "Objektbaum" )
Die Datenstruktur der Objekte: \#OBJECT\#
----------------------------------------------------------------------

Die Datenstruktur des Objektbaums ist zwar kein Baum im Sinne eines
BinÑrbaums, besitzt jedoch innerhalb eines Zeigers die logischen Ver-
kettungen eines Baums, mit VorgÑngern und Nachfolgern. Die Spezifika-
tion von VorgÑngern und Nachfolgern wird durch Indizes auf ein Array
vorgenommen. Die Baumstruktur der einzelnen Objekte kann man sich am
leichtesten an Hand eines einfachen Beispiels veranschaulichen:
Ein MenÅ setzt sich zunÑchst aus der MenÅleiste zusammen. Diese ent-
hÑlt wiederum mehrere Titeltexte. Die Titeltexte sind also direkt in
der MenÅleiste enthalten, sie sind beide Nachfolger des Objekts 'MenÅ-
leiste', bewegen sich also auf der selben hierarchischen Ebene.
Das Objekt MenÅleiste verweist mit ob_head auf den ersten MenÅtitel
und mit ob_tail auf den letzten MenÅtitel. Im ersten MenÅtitel dient
der Zeiger ob_next zur Adressierung des nÑchsten MenÅtitels.
Die Verkettung weist also folgende Struktur auf:

      MenÅleiste:
   +---------+---------+--------+
   | \#ob_head\# | \#ob_tail\# | ...    |
   |    o    |    o    |        |
   +----|----+----|----+--------+
        |         +-------------------------+
        V                                   V
   +---------+---------+--------+       +---------+---------+--------+
   | ...     | \#ob_next\# | ...    |  ...  | ...     | ...     | ...    |
   |         |    o    |        |       |         |         |        |
   +---------+----|----+--------+       +---------+---------+--------+
      1.MenÅtitel |                         n-ter MenÅtitel
                  +-----> 2.MenÅtitel


Welche Aktionen mit einem Objekt durchgefÅhrt werden dÅrfen, wird in
ob_flags festgelegt. Der Zustand eines Objekts wird im Eintrag
\#ob_state\# festgehalten. Der Eintrag ob_type legt den Objekttyp fest.
Manche Objekte benîtigen zur exakten Festlegung eine zusÑtzliche Da-
tenstruktur, wie TEDINFO oder BITBLK. In ob_spec wird dann ein Zeiger
auf diese zusÑtzliche Struktur abgelegt. Zusammenfassend nochmals der
Gesamtaufbau der Datenstruktur fÅr Objekte \#OBJECT\#:

         +-------------+
         |  \#ob_next\#    |   Index fÅr das nÑchste Objekt
         +-------------+
         |  \#ob_head\#    |   Index des ersten Kindes
         +-------------+
         |  \#ob_tail\#    |   Index des letzten Kindes
         +-------------+
         |  \#ob_type\#    |   \#Objektart\#
         +-------------+
         |  \#ob_flags\#   |   \#Manipulationsflags\#
         +-------------+
         |  \#ob_state\#   |   \#Objektstatus\#
         +-------------+
         |  \#ob_spec\#    |   \#OBSPEC\#
         +-------------+
         |  \#ob_x\#       |   relative x-Koordiante zum Eltern-Objekt
         +-------------+
         |  \#ob_y\#       |   relative y-Koordinate zum Eltern-Objekt
         +-------------+
         |  \#ob_width\#   |   Breite des Objekts
         +-------------+
         |  \#ob_height\#  |   Hîhe des Objekts
         +-------------+

Die Datenstruktur \#OBJECT\# ist in der Datei AES.H definiert. Die ent-
sprechenden Zusatzstrukturen, wie \#TEDINFO\#, \#ICONBLK\#, \#BITBLK\#, \#PARMBLK\#,
\#USERBLK\# und \#ICONBLK\#, befinden sich ebenfalls in AES.H.
\end

screen( "Objektart" )
Objektarten
----------------------------------------------------------------------

Folgende Objektarten stehen zur Auswahl:

20  G_BOX        Rechteckiger Kasten.
21  G_TEXT       Grafiktext, ob_spec zeigt auf TEDINFO-Struktur.
22  G_BOXTEXT    rechteckiger Kasten mit Grafiktext, ob_spec zeigt
                 auf TEDINFO-Struktur.
23  G_IMAGE      Bild, ob_spec zeigt auf BITBLK-Struktur.
24  G_USERDEF    Benutzerdefinierte Funktion zum Zeichnen eines
                 eigenen Objekts. ob_spec verweist auf eine USERBLK
                 Struktur.
25  G_IBOX       Transparentes Rechteck.
26  G_BUTTON     Text mit Rahmen fÅr Optionsauswahl.
27  G_BOXCHAR    Rechteck, mit einem Zeichen.
28  G_STRING     Zeichenkette, ob_spec zeigt auf den String.
29  G_FTEXT      Formatierter Grafiktext, ob_spec zeigt auf
                 TEDINFO-Struktur
30  G_FBOXTEXT   Rechteck mit formatiertem Grafiktext, ob_spec zeigt
                 auf TEDINFO-Struktur.
31  G_ICON       Icon-Symbol, ob_spec zeigt auf die ICONBLK-Struktur.
32  G_TITLE      Titel eines Drop-Down-MenÅs, ob_spec zeigt auf
                 den String.

Diese Objekte sind in der Datei AES.H als Konstanten definiert. Die
Datenstrukturen, wie \#OBJECT\#, \#TEDINFO\#, \#ICONBLK\#, \#BITBLK\#, \#PARMBLK\#,
\#USERBLK\# und \#ICONBLK\#, befinden sich ebenfalls in AES.H.
\end

screen( "Objektstatus" )
Objektstati
----------------------------------------------------------------------

Vom Objektstatus hÑngt es ab, wie ein Objekt spÑter auf dem Bildschirm
dargestellt wird.
Ein Objektstatus kann von folgendem Typ sein:

0  NORMAL      Normale Darstellung.
1  SELECTED    Inverse Darstellung, dh. das Objekt ist selektiert.
2  CROSSED     Falls die \#Objektart\# BOX ist, wird das Objekt mit
               durchgestrichen gezeichnet.
4  CHECKED     Am linken Objektrand befindet sich ein HÑkchen.
8  DISABLED    Das Objekt wird grau dargestellt und ist nicht mehr
               selektierbar.
16 OUTLINED    Das Objekt bekommt einen Rahmen.
32 SHADOWED    Ein Schatten wird unter das Objekt gezeichnet.

Sie finden diese Konstanten in der Datei AES.H definiert.
\end

screen( "Manipulationsflags",
		"Objektflags" )
Objektflags
----------------------------------------------------------------------

Die Manipulationsflags eines Objektes bestimmen seine Eigenschaften.
Folgende Mîglichkeiten stehen zu Auswahl:

0   NONE          Keine Eigenschaften.
1   SELECTABLE    Das Objekt ist selektierbar.
2   DEFAULT       Wenn der Benutzer die 'Return'- oder 'Enter'-Taste
                  drÅckt, wird dieses Objekt automatisch selektiert.
                  Diese Flag ist pro Baum nur einmal zugelassen.
4   EXIT          Beim Anklicken eines solchen Objektes wird der
                  Dialog beendet (siehe auch \#form_do\#).
8   EDITABLE      Dieses Objekt kann vom Benutzer mittels der Tastatur
                  editiert werden.
16  RBUTTON       Haben im selben Objektbaum mehrere Objekte die
                  eigenschaft RBUTTON, so kann immer nur eines dieser
                  Objekte selektiert sein. Diese Objekte sollten alle
                  Kinder eines Elternobjekts mit der \#Objektart\# G_IBOX
                  sein. Wird ein anderes Objekt dieser Gruppe ausge-
                  wÑhlt, wird das zuvor selektierte automatisch de-
                  selektiert.
32  LASTOB        Hierbei handelt es sich um das letzte Objekt inner-
                  halb eines Objektbaumes.
64  TOUCHEXIT     Der Dialog (siehe auch \#form_do\#) wird beendet, sobald
                  sich der Mauszeiger Åber diesem Objekt befindet, und
                  der linke Mausknopf gedrÅckt wird.
128 HIDETREE      Alle Kinder dieses Objektes werden von \#objc_draw\# und
                  \#objc_find\# nicht mehr bemerkt, sobald dieses Flag ge-
                  setzt ist.
256 INDIRECT      ob_spec zeigt nun auf einen weiteren Zeiger, der
                  dann auf den eigentlichen Wert von ob_spec zeigt
                  (siehe auch \#OBJECT\#). Auf diese Weise lassen sich
                  die Standarddatenstrukturen wie TEDINFO etc. auf
                  einfache Art erweitern.

Sie finden diese Konstanten in der Datei AES.H definiert.
\end

screen( "Resource" )
Die Resourcefunktionen auf einen Blick
----------------------------------------------------------------------

\#rsrc_free\#   Resourcespeicher freigeben.
\#rsrc_gaddr\#  Adresse einer Datenstruktur ermitteln.
\#rsrc_load\#   Resourcedatei laden.
\#rsrc_obfix\#  Zeichenkoordinaten eines Objekts in Pixelkoordinaten
            umwandeln.
\#rsrc_saddr\#  Adresse fÅr eine Datenstruktur zuordnen.


Resourcen - Grundlage der flexiblen Programmierung

öber Resourcedateien kann man nahezu alle Daten fÅr die Programmierung
einer BenutzeroberflÑche, wie zum Beispiel MenÅtexte und FormularÅber-
schriften, auûerhalb eines C-Programms bequem mit einem \#Resource\#-
Editor verwalten. Die Daten werden lediglich beim Programmstart mit
\#rsrc_load\# geladen. Anschlieûend kann man mit \#rsrc_gaddr\# auf die
einzelnen \#Objekte\#, \#MenÅs\# oder \#Formulare\# direkt zugreifen. Mit Hilfe
von \#rsrc_obfix\# kann man die Koordinaten eines Objekts auf die gerÑte-
spezifische Umgebung umrechnen.
\end

screen( capsensitive("rsrc_load") )
Name           Recource load - lÑdt eine Recourcedatei in den Speicher.

Definition     int rsrc_load( const char *re_lpfname );

Prototyp in    aes.h

Beschreibung   Die Funktion lÑdt ein Resourcefile mit dem Filenamen
               re_lpfname in den Speicher und initialisiert einige
               interne Zeiger.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_free\#
\end

screen( capsensitive("rsrc_free") )
Name           Resource free - gibt den Speicher eines Recourcesets
               wieder frei.

Definition     int rsrc_free( void );

Prototyp in    aes.h

Beschreibung   Die Funktion gibt den durch ein Resourcefile belegten
               Speicherplatz wieder frei.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_load\#
\end

screen( capsensitive("rsrc_gaddr") )
Name           Resource get Address - ermittelt die Adresse eines
               Objekts in einem Resourceset.

Definition     int rsrc_gaddr( int re_gtype, int re_gindex,
                               void *gaddr );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt die Anfangsadressen
               verschiedener Objektstrukturen von im Speicher
               geladenen Resourcefiles.
re_gindex      fÅr re_gtype ungleich Null die Objektnummer
gaddr          fÅr Werte von re_gtype zwischen 0 und 6 erhÑlt man die
               Adresse des Zeigers, fÅr alle anderen Werte erhÑlt man
               den Zeiger direkt
re_gtype       die Anfangsadresse welcher Struktur soll berechnet
               werden
                0       Objektbaum
                1       OBJECT
                2       TEDINFO
                3       ICONBLK
                4       BITBLK
                5       String
                6       imagedate
                7       ob_spec
                8       te_ptext
                9       te_ptmplt
                10      te_pvalid
                11      ib_pmask
                12      ib_pdata
                13      ib_ptext
                14      ib_pdate
                15      ad_frstr
                16      ad_frimg
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_load\#   \#OBJECT\#   \#TEDINFO\#-struktur   \#BITBLK\#-struktur
               \#ICONBLK\#-struktur
\end

screen( capsensitive("rsrc_saddr") )
Name           Resource store Address - speichert die Adresse eines
               Objwekts.

Definition     int rsrc_saddr( int re_stype, int re_sindex,
                               void *saddr );

Prototyp in    aes.h

Beschreibung   Die Funktion speichert die Anfangsadresse saddr einer
               Datenstruktur im Speicher.
re_stype       die Anfangsadresse welcher Struktur soll gespeichert
               werden, fÅr die Typencodierung: siehe \#rsrc_gaddr\#
re_sindex      fÅr re_stype ungleich Null die Objektnummer

Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_gaddr\#   \#OBJECT\#
\end

screen( capsensitive("rsrc_obfix") )
Name           Resource Object fix - wandelt Zeichensatz- in Pixel-
               Koordinaten um.

Definition     int rsrc_obfix( OBJECT *re_otree, int re_oobject );

Prototyp in    aes.h

Beschreibung   Die Funktion konvertiert die Grîûe und die Position des
               Objekts mit der Nummer re_oobject im Objektbaum
               re_otree von Zeichendarstellung in Pixeldarstellung.
Ergebnis       Als Ergebnis wird immer der Wert 1 zurÅckgegeben.
Gruppe         \#Resource\#
\end

screen( "Formulare" )
Die Formularfunktionen auf einen Blick
----------------------------------------------------------------------

\#form_alert\#  Alarmbox darstellen.
\#form_button\# Auswerten eines Mausklicks Åber einem Formular.
\#form_center\# Koordinaten fÅr eine zentrierte Objektausgabe berechnen.
\#form_dial\#   Bildschirmspeicher reservieren und freigeben.
\#form_do\#     Eingaben in einem Formular aufnehmen.
\#form_error\#  \#Betriebssystem\#fehlermeldung ausgeben.
\#form_keybd\#  Auswerten einer Tastatureingabe.

Mit den Formularfunktionen kann man bestimmte, hÑufig benîtigte Ele-
mente fÅr die BenutzerfÅhrung sehr schnell aktivieren. Insbesondere
fÅr Fehlermeldungen und Ja/Nein-Entscheidungen eignen sich die beiden
Funktionen \#form_error\# und \#form_alert\# hervorragend. Daneben sind in
dieser Funktionsreihe einige Funktionen zur Manipulation und Darstel-
lung von Objekten integriert: \#form_center\#, \#form_dial\# und  \#form_do\#.
Die beiden Funktionen \#form_button\# und \#form_keybd\# sind nicht offiziell
dokumentiert, funktionieren aber in der angegebenen Weise.
\end

screen( capsensitive("form_do") )
Name           Form do Dialog - fÅhrt den dialog mit dem Anwender
               durch.

Definition     int form_do( OBJECT *fo_dotree, int fo_dostartob );

Prototyp in    aes.h

Beschreibung   Die Funktion Åbernimmt die Behandlung von
               Benutzeraktionen in einem Formular.
fo_dotree      Zeiger auf den Objektbaum der Dialogbox
fo_dostartob   Nummer des Editobjekts, wo sich zu Dialogbeginn der
               Textcursor befinden soll (0 falls der Objektbaum kein
               Editobjekt enthÑlt)
Ergebnis       Als Ergebnis wird der Index des Objekts zurÅckgegeben,
               mit dessen Hilfe der Dialog beendet wurde. Bei einem
               Doppelklick wird zusÑtzlich das 15. Bit gesetzt.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#   \#ob_type\#   \#ob_flags\#
\end

screen( capsensitive("form_alert") )
Name           Form alert box - zeichnet eine Auswahlbox.

Definition     int form_alert( int fo_adefbttn,
                               const char *fo_astring );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt eine Alarmbox auf dem Bildschirm
               dar und gibt die Nummer des Buttons zurÅck, mit dem die
               Alarmbox verlassen wurde. Der Bildschirmhintergrund
               wird dabei vom AES gesichert.
fo_adefbttn    Nummer des Defaultbuttons der darzustellenden Alarmbox
                0  kein Defaultbutton
                1  erster Button
                2  zweiter Button
                3  dritter Button
fo_astring     Zeiger auf den String, der das Aussehen der Alarmbox
               bestimmt. Format: "[n][lines][buttons]" wobei
n              die Nummer des einzublendenden Icons ist
                0  kein Icon
                1  Ausrufezeichen
                2  Fragezeichen
                3  Stopschild
lines          hîchstens fÅnf Textzeilen mit maximal 40 Zeichen, die
               durch das Zeichen '|' getrennt werden
buttons        Texte fÅr hîchstens drei Buttons, die durch das Zeichen
               '|' getrennt werden.
Ergebnis       Als Ergebnis wird die Nummer der ausgewÑhlten Option
               zurÅckgeliefert.
Gruppe         \#Formulare\#
\end

screen( capsensitive("form_dial") )
Name           Form Dialog Space- reserviert oder gibt Speicherplatz
               frei fÅr ein Dialogobjekt.

Definition     int form_dial( int fo_diflag, int fo_dilittlx,
                              int fo_dilittly, int fo_dilittlw,
                              int fo_dilittlh, int fo_dibigx,
                              int fo_dibigy, int fo_dibigw,
                              int fo_dibigh );

Prototyp in    aes.h

Beschreibung   Die Funktion form_dial Åbernimmt mehrere verschiedene
               Aufgaben, um eine Dialogbox darzustellen, in
               AbhÑngigkeit vom Parameter fo_diflag.
fo_diflag      FMD_START   reserviert Bildschirmspeicher fÅr die
                           Dialogbox
               FMD_GROW    zeichnet eine sich îffnende Box von den
                           Anfangskoordinaten zu den Endkoordinaten
                           (\#graf_growbox\#)
               FMD_SHRINK  zeichnet eine sich schlieûende Box von den
                           Anfangskoordinaten zu den Endkoordinaten
                           (\#graf_shrinkbox\#)
               FMD_FINISH  gibt den Bildschirmspeicher wieder frei und
                           verursacht eine WM_REDRAW Message
                           (siehe auch unter: \#evnt_mesag\#)
fo_dilittlx,   x und y Koordinate, Breite und Hîhe des kleinsten,
fo_dilittly,   sich ausdehnenden bzw. schlieûenden Rechtecks.
fo_dilittlw,
fo_dilittlh
fo_dibigx,     x und y Koordinate, Breite und Hîhe des grîûten, sich
fo_dibigy,     ausdehnenden bzw. schlieûenden Rechtecks.
fo_dibigw,
fo_dibigh
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Formulare\#
Querverweis    \#evnt_mesag\#   \#graf_growbox\#   \#graf_shrinkbox\#
\end

screen( capsensitive("form_error") )
Name           Form Error - stellt eine Fehlerbox fÅr TOS-Fehler dar.

Definition     int  form_error( int fo_enum );

Prototyp in    aes.h

Beschreibung   Gibt eine Fehlerbox auf dem Bildschirm aus, die die
               Åbergebene MS-DOS Fehlernummer fo_enum im Klartext
               beinhaltet. Man muû also erst die GEMDOS Fehlernummer
               in die entsprechende MS-DOS Fehlernummer umrechnen.
Ergebnis       Als Ergebnis wird die Nummer (1-3) der ausgewÑhlten
               Option zurÅckgegeben. Bei der jetzigen GEM-Version
               steht jedoch nur eine Option zur VerfÅgung.
Gruppe         \#Formulare\#
\end

screen( capsensitive("form_center") )
Name           Form centered Object - zentriert ein Objekt auf dem
               Bildschirm.

Definition     int  form_center( OBJECT *fo_ctree, int *fo_cx,
                                  int *fo_cy, int *fo_cw, int *fo_ch );

Prototyp in    aes.h

Beschreibung   Die Funktion plaziert ein beliebiges Objekt, auf das
               fo_ctree zeigt, in der Bildschirmmitte und schreibt die
               errechneten Koordinaten in fo_cx, fo_cy, fo_cw, fo_ch.
Ergebnis       Als Ergebnis wird immer eine 1 zurÅckgegeben.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#  \#objc_offset\#
\end

screen( capsensitive("form_keybd") )
Name           Form Keyboard - Nimmt Tastatureingaben in ein Formular
               vor.

Definition     int form_keybd( OBJECT *fo_ktree, int fo_kobject,
                               int fo_kobnext, int fo_kchar,
                               int *fo_knxtobject, int *fo_knxtchar );

Prototyp in    aes.h

Beschreibung   Die Funktion Åbernimmt Eingaben von der Tastatur in ein
               Formular auf das fo_ktree zeigt. Dabei ist fo_kchar das
               einzutragende Zeichen, fo_kobject das aktuelle
               Editobjekt und fo_obnext, das nÑchste Editobjekt. In
               fo_knxtobject steht das neue Editobjekt und in
               fo_knxtchar entweder Null, d. h. die Funktion konnte
               mit fo_kchar etwas anfangen oder den Orginalwert, d. h.
               es handlet sich um einen Buchstaben, den man mit
               \#objc_edit\# einfÅgen muû.
Ergebnis       Der RÅckgabewert der Funktion ist Null, falls ein
               Exitobjekt gewÑhlt wurde, sonst ist er positiv.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#   \#objc_edit\#   \#form_button\#
\end

screen( capsensitive("form_button") )
Name           Form Button - Nimmt Maustasteneingaben in ein Formular
               vor.

Definition     int form_button( OBJECT *fo_btree, int fo_bobject,
                                int fo_bclicks, int *fo_bnxtobj );

Prototyp in    aes.h

Beschreibung   Die Funktion behandelt Mausknopfevents, die in einem
               Formular, auf das fo_btree zeigt, auftreten und
               Åbernimmt alle TÑtigkeiten die aus diesem Event
               resultieren (z. B. Invertierung von Buttons, die
               selektiert wurden). Dabei ist fo_bobject das aktuelle
               Editobjekt und fo_bclicks die Anzahl der Mausklicks. In
               fo_bnxtobj erhÑlt man das neue Editobjekt.
Ergebnis       Der RÅckgabewert der Funktion ist Null, falls ein
               Exitobjekt selektiert wurde, sonst ist er positiv.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#   \#evnt_multi\#   \#form_keybd\#
\end

screen( "MenÅs" )
Die MenÅfunktionen im öberblick
----------------------------------------------------------------------

\#menu_bar\#        MenÅleiste darstellen oder entfernen.
\#menu_icheck\#     HÑkchen bei MenÅoptionen setzen oder lîschen.
\#menu_ienable\#    MenÅoptionen setzen oder lîschen.
\#menu_register\#   MenÅoptionen einfÅgen.
\#menu_text\#       Text von MenÅeintrÑgen Ñndern.
\#menu_tnormal\#    MenÅtitel invertieren.

Die wichtigste Funktion unter den MenÅfunktionen ist zweifellos die
Funktion \#menu_bar\#. Damit wird ein kompletter MenÅbaum dargestellt,
dessen Adresse man sich vorzugsweise aus einer \#Resource\#datei holt.
Um einzelne MenÅfunktionen wÑhrend des Programmablaufs flexibel ein-
und auszuschalten, verwendet man die Funktion \#menu_ienable\#. Schalter
lassen sich sehr gut mit \#menu_icheck\# verwalten. Mit \#menu_register\#
kann man zusÑtzliche MenÅoptionen wÑhrend des Programmlaufs bequem
einfÅgen. Wenn das MenÅ nicht mehr gebraucht wird kann es mit
\#menu_bar\# wieder vollstÑndig entfernt werden.
\end

screen( capsensitive("menu_bar") )
Name           Menu Bar - zeigt oder lîscht eine MenÅleiste.

Definition     int menu_bar( OBJECT *me_btree, int me_bshow );

Prototyp in    aes.h

Beschreibung   Die Funktion lîscht (me_bshow = 0) oder stellt
               (me_bshow = 1) die MenÅleiste des Objektbaumes dar,
               auf den me_btree zeigt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#MenÅs\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("menu_tnormal") )
Name           Menu Text normal - stellt einen MenÅtitel invers
               oder normal dar.

Definition     int menu_tnormal( OBJECT *me_ntree, int me_ntitle,
                                 int me_nnormal );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt den Titel mit der Objektnummer
               me_ntitle im MenÅbaum me_ntree entweder normal
               (me_nnormal = 1) oder invers (me_nnormal = 0) dar.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#MenÅs\#
\end

screen( capsensitive("menu_icheck") )
Name           Menu indicate Check - schreibt oder lîscht ein
               HÑckchen in der MenÅleiste.

Definition     int menu_icheck( OBJECT *me_ctree, int me_citem,
                                int me_ccheck );

Prototyp in    aes.h

Beschreibung   Falls me_ccheck gleich Null ist, so wird das HÑckchen
               vor dem MenÅeintrag me_citem im Objektbaum me_ctree
               entfernt, falls me_ccheck gleich Eins ist, so wird das
               HÑckchen vor den Eintrag gesetzt.
Ergebnis       Bei einem RÅckgabewert von Null ist ein Fehler
               aufgetreten.
Gruppe         \#MenÅs\#
Querverweis    \#OBJECT\#   \#ob_state\#
\end

screen( capsensitive("menu_ienable") )
Name           Menu indicate enable - aktiviert oder desaktiviert
               einen MenÅpunkt.

Definition     int menu_ienable( OBJECT *me_etree, int me_eitem,
                                 int me_eenable );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Objektstatus des MenÅeintrags
               me_eitem im Objektbaum me_etree auf DISABLED bzw.
               NORMAL, falls me_eenable gleich Null bzw. Eins ist.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#MenÅs\#
Querverweis    \#OBJECT\#   \#ob_state\#
\end

screen( capsensitive("menu_register") )
Name           Menu Register - fÅgt ein Accessory im
               AccessorymenÅ ein.

Definition     int menu_register( int me_rapid,
                                  const char *me_rpstring );

Prototyp in    aes.h

Beschreibung   Die Funktion hat zwei Aufgaben. Zum einen placiert sie
               den String me_rpstring in der Desk-Accessory-Liste.
               Zum anderen gibt sie die Nummer des MenÅeintrags
               (0 - 5) zurÅck.
Ergebnis       Ein RÅckgabewert von -1 signalisiert einen Fehler.
               me_rapid ist der Accessoryidentifikator.
Gruppe         \#MenÅs\#
\end

screen( capsensitive("menu_text") )
Name           Menu Text - ersetzt den Text eines MenÅeintrags.

Definition     int menu_text( OBJECT *me_ttree, int me_titem,
                              const char *me_ttext );

Prototyp in    aes.h

Beschreibung   Die Funktion Ñndert den Text des MenÅeintrages me_titem
               im Objektbaum me_ttree in den Text, auf den me_ttext
               zeigt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#MenÅs\#
Querverweis    \#OBJECT\#
\end

screen( "Grafikfunktionen" )
Die Grafik-Funktionen auf einen Blick
----------------------------------------------------------------------

\#graf_dragbox\#   Verschieben eines Rechtecks
\#graf_growbox\#   Animation eines sich vergrîûernden Rechtecks.
\#graf_handle\#    Kennung der Bildschirm-Arbeitsstation ermitteln.
\#graf_mkstate\#   Status der Maustasten ermitteln.
\#graf_mouse\#     Mausdarstellung verÑndern.
\#graf_mbox\#      Rechteckverschiebung darstellen.
\#graf_rubbox\#    RechteckhÅlle (ØGummibandÆ) darstellen.
\#graf_shrinkbox\# Animation eines sich verkleinernden Rechtecks.
\#graf_slidebox\#  Vertikale oder horizontale Verschiebung eines Rechtecks.
\#graf_watchbox\#  Objektstatus an Position des Mauszeigers koppeln.

In dieser Funktionsgruppe befinden sich einige Funktionen zur allge-
meinen Programmierung unter \#AES\#, wie \#graf_handle\# und \#graf_mouse\#, in
erster Linie aber Funktionen, die vor allem zur grafischen Animation
verwendet werden, wie \#graf_shrinkbox\# und \#graf_growbox\#, die jedoch
beide aus urheberrechtlichen GrÅnden in neueren \#GEM\#-Implementationen
nicht mehr vorhanden sein werden. Bisher sind jedoch noch alle Atari-
STs mit diesen Funktionen ausgeliefert worden.
\end

screen( capsensitive("graf_rubbox"),
		capsensitive("graf_rubberbox") )
Name           Graphics Rubberbox - zeichnet eine 'Rubberbox'
               (Gummirechteck) auf den Bildschirm.

Definition     int graf_rubbox( int gr_rx, int gr_ry,
                                int gr_minwidth, int gr_minheight,
                                int *gr_rlastwidth,
                                int *gr_rlastheight );
               oder

               int graf_rubberbox(...

Prototyp in    aes.h

Beschreibung   Die Funktion stellt ein Gummiband in Form eines
               Rechtecks auf dem Bildschirm dar, dessen obere linke
               Ecke festbleibt und dessen untere rechte Ecke solange
               bewegt werden kann, wie die linke Maustaste gedrÅckt
               wird.
gr_rx, gr_ry   Koordinaten der linken, oberen Ecke
gr_minwidth    kleinste Breite des Gummibandes
gr_minheight   kleinste Hîhe des Gummibandes
gr_rlastwidth  Breite des Gummibandes bei Loslassen des  Mausknopfs
gr_rlastheight Hîhe des Gummibandes bei Loslassen des Mausknopfs
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_dragbox") )
Name           Graphics drag Box - verschiebt ein Rechteck mit
               der Maus.

Definition     int graf_dragbox( int gr_dwidth, int gr_dheight,
                                 int gr_dstartx, int gr_dstarty,
                                 int gr_dboundx, int gr_dboundy,
                                 int gr_dboundw, int gr_dboundh,
                                 int *gr_dfinishx, int *gr_dfinishy );

Prototyp in    aes.h

Beschreibung   Die Funktion ermîglicht das Verschieben eines kleineren
               Rechtecks innerhalb eines grîûeren Begrenzungsrechtecks.
gr_dwidth      Breite des zu verschiebenden Rechtecks
gr_dheight     Hîhe des zu verschiebenden Rechtecks
gr_dstartx     x-Anfangskoordinate des zu verschiebenden Rechtecks
gr_dstarty     y-Anfangskoordinate des zu verschiebenden Rechtecks
gr_dboundx     x-Koordinate des Begrenzungsrechtecks
gr_dboundy     y-Koordinate des Begrenzungsrechtecks
gr_dboundw     Breite des Begrenzungsrechtecks
gr_dboundh     Breite des Begrenzungsrechtecks
gr_dfinishx    x-Koordinate des zu verschiebenden Rechtecks
               beim Loslassen des Mausknopfs
gr_dfinishy    y-Koordinate des zu verschiebenden Rechtecks
               beim Loslassen des Mausknopfs
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_movebox"),
		capsensitive("graf_mbox") )
Name           Graphics move Box - verschiebt ein Rechteck mit
               der Maus.

Definition     int graf_mbox( int gr_mwidth, int gr_mheight,
                              int gr_msourcex, int gr_msourcey,
                              int gr_mdestx, int gr_mdesty );

               oder

               int graf_movebox(...

Prototyp in    aes.h

Beschreibung   Die Funktion zeichnet ein Rechteck mit den Maûen
               gr_mwidth und gr_mheight, das sich von den
               Ausgangskoordinaten gr_msourcex und gr_msourcey zu den
               Koordinaten gr_mdestx und gr_mdesty bewegt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_growbox") )
Name           Graphics grow Box - zeichnet ein sich vergrîûerndes
               Rechteck.

Definition     int graf_growbox( int gr_gstx, int gr_gsty,
                                 int gr_gstwidth, int gr_gstheight,
                                 int gr_gfinx, int gr_gfiny,
                                 int gr_gfinwidth, int gr_gfinheight);

Prototyp in    aes.h

Beschreibung   Die Funktion zeichnet ein sich ausdehnendes Rechteck
               der Anfangsgrîûe gr_gstwidth und gr_gstheight mit den
               Anfangskoordinaten gr_gstx und gr_gsty bis zur Endgrîûe
               gr_gfinwidth und gr_gfinheight mit den Endkoordinaten
               gr_gfinx und gr_gfiny.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#form_dial\#   \#graf_shrinkbox\#
\end

screen( capsensitive("graf_shrinkbox") )
Name           Graphics shrink Box - zeichnet ein sich verkleinerndes
               Rechteck.

Definition     int graf_shrinkbox(int gr_sfinx, int gr_sfiny,
                                  int gr_sfinwidth, int gr_sfinheight,
                                  int gr_sstx, int gr_ssty,
                                  int gr_sstwidth, int gr_sstheight);

Prototyp in    aes.h

Beschreibung   Die Funktion zeichnet ein sich zusammenziehendes
               Rechteck der Anfangsgrîûe gr_sstwidth und gr_sstheight
               mit den Anfangskoordinaten gr_sstx und gr_ssty bis zur
               Endgrîûe gr_sfinwidth und gr_sfinheight mit den
               Endkoordinaten gr_sfinx und gr_sfiny.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#form_dial\#   \#graf_growbox\#
\end

screen( capsensitive("graf_watchbox") )
Name           Graphics watch Box - selektiert ein Objekt und
               Åberwacht die Mausbewegungen bezÅglich dieses Objekts.

Definition     int graf_watchbox( OBJECT *gr_wptree, int gr_wobject,
                                  int gr_winstate, int gr_woutstate );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Objektstatus des Objekts
               gr_wobject im Objektbaum gr_wptree in AbhÑngigkeit der
               Position des Mauszeigers innerhalb oder auûerhalb eines
               Rechtecks. Die Funktion wird beim Loslassen des
               Mausknopfs verlassen. Dabei ist gr_winstate der
               Objektstatus, falls sich der Mauszeiger innerhalb des
               Rechtecks befindet, und gr_woutstate der Objektstatus,
               falls sich der Mauszeiger auûerhalb des Rechtecks
               befindet.
Ergebnis       Der RÅckgabewert der Funktion ist entweder gleich Eins
               fÅr "Mauszeiger innerhalb des Objekts" oder gleich Null
               fÅr "Mauszeiger auûerhalb des Objekts".
Gruppe         \#Grafikfunktionen\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("graf_slidebox") )
Name           Graphics slide Box - ermittelt die Position der
               Schieberegler.

Definition     int graf_slidebox( OBJECT *gr_slptree, int gr_slparent,
                                  int gr_slobject, int gr_slvh );

Prototyp in    aes.h

Beschreibung   Die Funktion ermîglicht es einen "Slider" recht einfach
               zu realisieren. Solange die linke Maustaste gedrÅckt
               wird, kann das Objekt mit der Nummer gr_slobjekt
               innerhalb des Mutterobjekts gr_slparent im Objektbaum
               gr_slptree horizontal (gr_slvh = 0) oder vertikal
               (gr_slvh = 1) verschoben werden.
Ergebnis       Die Funktion liefert die relative Position zwischen 0
               (ganz links bzw. ganz oben) und 1000 (ganz rechts bzw.
               ganz unten) des "Sliders" als Funktionswert.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("graf_handle") )
Name           Graphics handle - ermittelt den VDI-Handle der
               Arbeitsstation.

Definition     int graf_handle( int *gr_hwchar, int *gr_hhchar,
                                int *gr_hwbox, int *gr_hhbox );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt die Kennung (\#handle\#) der
               VDI-Workstation, auf die die Ausgaben des AES gehen.
               ZusÑtzlich bekommt man noch Information Åber die Grîûe
               des Zeichensatzes. Dabei sind gr_hwchar und gr_hhchar
               die Breite und Hîhe des Zeichensatzes in
               Bildschirmpunkten und gr_hwbox und gr_hhbox die Breite
               und Hîhe eines Rechtecks, das jedes einzelne Zeichen
               vollstÑndig umgibt.
Ergebnis       Als Ergebnis erhÑlt man den VDI-Handle.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#v_opnvwk\#
\end

screen( capsensitive("graf_mouse") )
Name           Graphics Mouse - verÑndert die Darstellung des
               Mauszeigers.

Definition     int graf_mouse( int gr_monumber, \#MFORM\# *gr_mofaddr );

Prototyp in    aes.h

Beschreibung   Die Funktion wÑhlt die neue Form gr_monumber fÅr den
               Mauszeiger aus.
gr_monumber    ARROW                   0
               TEXT_CRSR               1
               HOURGLASS,BUSYBEE       2
               POINT_HAND              3
               FLAT_HAND               4
               THIN_CROSS              5
               THICK_CROSS             6
               OUTLN_CROSS             7
               USER_DEF                255  eigene Mausform
               M_OFF                   256  Mauszeiger abschalten
               M_ON                    257  Mauszeiger anschalten
               Falls gr_monumber gleich USER_DEF, dann ist der
               Parameter ein Zeiger auf die Struktur \#MFORM\#, die das
               Aussehen des Mauszeigers festlegt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_mkstate") )
Name           Graphics Mouse and Keyboard Status - ermittelt
               den Status von Maus und Tastatur.

Definition     int graf_mkstate( int *gr_mkmx, int *gr_mkmy,
                                 int *gr_mkmstate, int *gr_mkkstate );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt die aktuelle Mausposition und
               den Zustand der  Maustasten und der Sondertasten der
               Tastatur.
               gr_mkmx,
               gr_mkmy        Position des Mauszeigers
               gr_mkkstate    Sondertasten der Tastatur (\#evnt_button\#)
               gr_mkmstate    Zustand der Mausknîpfe (\#evnt_button\#)
Ergebnis       Als Ergebis wird immer eine 1 zurÅckgegeben.
Gruppe         \#Grafikfunktionen\#
\end

screen( "Applikation" )
Die Applikationsfunktionen auf einen Blick
----------------------------------------------------------------------

\#appl_exit\#    AES-Anwenderprogramm abmelden und Kennung freigeben.
\#appl_find\#    AES-Kennung einer anderen AES-Applikation ermitteln.
\#appl_init\#    AES-Anwendung anmelden.
\#appl_read\#    AES-Mitteilungen lesen.
\#appl_tplay\#   Ereignisse abspielen.
\#appl_trecord\# Ereignisse aufzeichnen.
\#appl_write\#   AES-Mitteilungen schreiben.

Jede Applikation unter \#GEM\# hat ein Anfang und ein Ende: Mit \#appl_init\#
meldet man sie ordnungsgemÑû unter \#GEM\# an. Am Ende eines Programms
verlÑût man das \#AES\#-System mit \#appl_exit\#. Um mit anderen Applika-
tionen kommunizieren zu kînnen, muû man zuerst mit \#appl_find\# deren
Kennung ermitteln. Anschlieûend kann man mit \#appl_write\# Mitteilungen
an andere Programme weitergeben. Mit \#appl_read\# kann man dann lÑngere
Mitteilungen empfangen, fÅr kÅrzere (bis zu 16 Bytes) empfiehlt sich
jedoch der Gebrauch der Funktion \#evnt_mesag\#. Insbesondere fÅr De-
monstrationen und die Implementation von Makro-Recordern eignen sich
die Funktionen \#appl_trecord\# und \#appl_tplay\#. Damit lassen sich \#GEM\#-
Ereignisse aufzeichnen und wieder abspielen.
\end

screen( capsensitive("appl_init") )
Name           Application Initialization - meldet die Applikation
               unter AES an.

Definition     int appl_init( void );

Prototyp in    aes.h

Beschreibung   Der Aufruf von appl_init meldet das Programm beim AES
               an, initialisiert die internen ParameterÅbergabefelder
               und gibt eine nichtnegative Zahl als
               Applikationsidentifikation zurÅck.
Ergebnis       Eine Zahl kleiner Null signalisiert einen Fehler.
Gruppe         \#Applikation\#
Querverweis    \#appl_find\#   \#appl_exit\#
\end

screen( capsensitive("appl_find") )
Name           Application find - ermittelt die Applikationsnummer
               einer AES-Anwendung.

Definition     int appl_find( const char *ap_fpname );

Prototyp in    aes.h

Beschreibung   Diese Funktion ermittelt die Applikationsidentifikation
               einer anderen, parallel laufenden Applikation. Dabei
               zeigt ap_fpname auf den Namen der Applikation deren
               Identifikator gefunden werden soll.
               Wichtig: Der Name muû unbedingt acht Zeichen lang sein,
               ist er kÅrzer, so muû er mit Leerzeichen aufgefÅllt
               werden.
Ergebnis       Ein RÅckgabewert kleiner Null kennzeichnet einen
               aufgetretenen Fehler.
Gruppe         \#Applikation\#
\end

screen( capsensitive("appl_read") )
Name           Application read - empfÑngt eine Mitteilung einer
               anderen Applikation.

Definition     int appl_read( int ap_rid, int ap_rlength,
                              void *ap_rpbuff );

Prototyp in    aes.h

Beschreibung   Mit dieser Funktion ist es mîglich nach einem
               Message-Event  ap_rlength Bytes aus dem Buffer
               ap_rpbuff zu lesen. ap_rid ist dabei die
               Applikationsidentifikation der Applikation, die die
               Nachricht gesendet hat.
Ergebnis       Wird eine Null zurÅckgegeben, so ist ein Fehler
               aufgetreten, sonst wird eine positive Zahl als
               Ergebnis zurÅckgegeben.
Gruppe         \#Applikation\#
Querverweis    \#appl_init\#   \#appl_write\#   \#evnt_mesag\#
\end

screen( capsensitive("appl_write") )
Name           Application write - sendet eine Mitteilung an eine
               ander Applikation.

Definition     int appl_write( int ap_wid, int ap_wlength,
                               void *ap_wpbuff );

Prototyp in    aes.h

Beschreibung   Mit appl_write ist es mîglich einer parallel laufenden
               Applikation, deren Applikationsidentifikator ap_wid
               ist, ap_wlength Bytes aus dem Buffer ap_wpbuff als
               Nachricht zu schicken.
Ergebnis       Wird eine Null zurÅckgegeben, so ist ein Fehler
               aufgetreten, sonst wird eine positive Zahl als
               Ergebnis zurÅckgegeben.
Gruppe         \#Applikation\#
Querverweis    \#appl_init\#   \#appl_read\#   \#appl_find\#
\end

screen( capsensitive("appl_exit") )
Name           Application exit - meldet eine Applikation vom AES ab.

Definition     int appl_exit( void );

Prototyp in    aes.h

Beschreibung   Meldet eine Applikation beim AES wieder ab und gibt
               deren Applikationsidentifikator wieder frei.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Applikation\#
Querverweis    \#appl_init\#
\end

screen( capsensitive("appl_tplay") )
Name           Application play - spielt aufgezeichnete AES-
               Ereignise ab.

Definition     int appl_tplay( void *ap_tpmem, int ap_tpnum,
                               int ap_tpscale );

Prototyp in    aes.h

Beschreibung   Die Funktion appl_tplay erlaubt es eine Reihe von
               aufgezeichneten Benutzeraktionen (Events) wieder
               abzuspielen. ap_tpmem zeigt dabei auf den
               Aufzeichnungsbuffer, ap_tpnum ist die Anzahl der
               abzuspielenden Events und ap_tpscale gibt die
               Wiederholungsgeschwindigkeit an ( 50 entspricht z. B.
               halber Geschwindigkeit)
Ergebnis       Als Ergebnis wird immer der Wert 1 zurÅckgegeben.
Gruppe         \#Applikation\#
Querverweis    \#appl_trecord\#
\end

screen( capsensitive("appl_trecord") )
Name           Application record - nimmt AES-Ereignisse auf.

Definition     int appl_trecord( void *ap_trmem, int ap_trcount );

Prototyp in    aes.h

Beschreibung   Die Funktion ermîglicht es, eine Anzahl von ap_trcount
               an Benutzeraktionen (Events) in dem Buffer, auf den
               ap_trmem zeigt, aufzuzeichnen.
Ergebnis       Als Ergebnis wird die Anzahl der tatsÑchlich
               aufgezeichneten Ereignisse zurÅckgeliefert.
Gruppe         \#Applikation\#
Querverweis    \#appl_tplay\#
\end

screen( "Zwischenspeicher",
		"Clipboardfunktionen" )
Clipboardfunktionen

Unter \#GEM\# gibt es die Mîglichkeit, Informationen in einem Zwischen-
speicher, dem Clipboard, abzulegen. Das Clipboard ist als Datei reali-
siert. Man kann Daten hineinschreiben und wieder auslesen.

Die Clipboardfunktionen auf einen Blick:

\#scrp_read\#   Aus dem Clipboard lesen.
\#scrp_write\#  Ins Clipboard schreiben.
\end

screen( capsensitive("scrp_read") )
Name           Scrap read - liest das Clipboard ein.

Definition     int scrp_read( char *sc_rpscrap );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt den aktuellen Pfadnamen fÅr die
               Zwischenablage und schreibt ihn in sc_rpscrap.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Zwischenspeicher\#
Querverweis    \#scrp_write\#
\end

screen( capsensitive("scrp_write") )
Name           Scrap write - schreibt in ein Clipboard.

Definition     int scrp_write( char *sc_wpscrap );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Pfadnamen fÅr die Zwischenablage
               auf den neuen Namen sc_wpscrap.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Zwischenspeicher\#
Querverweis    \#scrp_read\#
\end

screen( "Shell" )
Shellfunktionen

FÅr den Aufruf anderer Applikationen und der Kommunikation mit diesen
Programmen sind die Shellfunktionen zustÑndig. Sie stellen auch
weitere \#Betriebssystem\#informationen zur VerfÅgung.

Die Shellfunktionen auf einen Blick:

\#shel_envrn\#  Environment-Variable abfragen.
\#shel_find\#   Datei suchen.
\#shel_get\#    Environment-Puffer lesen.
\#shel_put\#    Environment-Puffer schreiben.
\#shel_read\#   Kommandozeilenparameter lesen.
\#shel_write\#  Applikation starten.
\end

screen( capsensitive("shel_read") )
Name           Shell read - liest die Kommandozeilen-Parameter
               der Applikation.

Definition     int shel_read( char *sh_rpcmd, char *sh_rptail );

Prototyp in    aes.h

Beschreibung   Die Funktion kann fÅr eine Applikation den Pfadnamen
               und Kommandozeile bestimmen, wenn diese Applikation mit
               \#shel_write\# gestartet wurde. Nach Beendigung der
               Funktion beinhaltet sh_rptail den Pfadnamen und
               sh_rpcmd die Kommandozeile.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Shell\#
Querverweis    \#shel_write\#
\end

screen( capsensitive("shel_write") )
Name           Shell write - startet eine Andere Applikation.

Definition     int shel_write( int sh_wdoex, int sh_wisgr,
                               int sh_wiscr, char *sh_wpcmd,
                               char *sh_wptail );

Prototyp in    aes.h

Beschreibung   Mit der Funktion shel_write kann man aus einer
               Applikation eine nachfolgende Applikation starten.
sh_wdoex       0  kein weiteres Programm laden und starten
               1  ein neues Programm laden und starten
sh_wisgr       0  es handelt sich um kein Grafikprogramm
               1  es handelt sich um ein Grafikprogramm
sh_wiscr       wird ignoriert
sh_wpcmd       Pfadname des zu startenden Programms
sh_wptail      Kommandozeile fÅr das zu startende Programm
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Shell\#
\end

screen( capsensitive("shel_find") )
Name           Shell find - sucht Dateien.

Definition     int shel_find( char *sh_fpbuff );

Prototyp in    aes.h

Beschreibung   Mit der Funktion shel_find kann man eine Datei mit dem
               Namen sh_fpbuff im Inhaltsverzeichnis suchen. Die Datei
               wird dabei im Wurzelverzeichnis, im aktuellen Directory
               und unter BerÅcksichtigung aller Suchpfade, die in der
               Environmentvariable 'PATH=' angegeben sind, gesucht.
               Nach der Bearbeitung der Funktion findet man den ganzen
               Zugriffspfad in sh_fpbuff.
Ergebnis       Ein RÅckgabewert von Null signalisiert 'Datei nicht
               gefunden'.
Gruppe         \#Shell\#
Querverweis    \#shel_envrn\#
\end

screen( capsensitive("shel_envrn") )
Name           Shell environment - ermittelt den Wert von
               Environmentvariablen.

Definition     int shel_envrn( char **sh_epvalue, char *sh_eparm );

Prototyp in    aes.h

Beschreibung   Die Funktion ermîglicht es den Wert von verschiedenen
               Environmentvariablen zu ermitteln. Dazu Åbergibt man
               den Namen der Variable in sh_eparm und erhÑlt einen
               Zeiger auf den Wert der Variablen in sh_epvalue.
Ergebnis       Die Funktion liefert als Ergebnis immer 1.
Gruppe         \#Shell\#
\end

screen( capsensitive("shel_put") )
Name           Shell put - schreibt in den GEM-Environment-Puffer.

Definition     int shel_put( char *sh_paddr, int sh_plen );

Prototyp in    aes.h

Beschreibung   Die Funktion schreibt in den Environment-Puffer des
               AES. Dabei werden sh_plen Zeichen aus dem
               Speicherbereich, auf den sh_paddr zeigt, in den
               Environment-Puffer kopiert.
Ergebnis       Ein RÅckgabewert von Null signalisiert einen Fehler.
Gruppe         \#Shell\#
Querverweis    \#shel_get\#   \#shel_envrn\#   \#shel_find\#
\end

screen( capsensitive("shel_get") )
Name           Shell get - liest den GEM-Environment-Puffer.

Definition     int shel_get( char *sh_gaddr, int sh_glen );

Prototyp in    aes.h

Beschreibung   Die Funktion liest aus dem Environment-Puffer des AES
               sh_glen Zeichen und kopiert sie in den Speicherbereich
               auf den sh_gaddr zeigt.
Ergebnis       Ein RÅckgabewert von Null signalisiert einen Fehler.
Gruppe         \#Shell\#
Querverweis    \#shel_put\#
\end

screen( "Dateiauswahl" )
Dateiauswahl

Zur Auswahl eines Dateinamens mit Hilfe einer Dialogbox dienen die
Funkitonen:

\#fsel_input\#    Dateinamen auswÑhlen.
\#fsel_exinput\#  Dateinamen auswÑhlen. 
              (erst ab TOS Version 1.4 verfÅgbar)
\end

screen( capsensitive("fsel_input") )
Name           File Selection Input - selektiert Dateinamen.

Definition     int fsel_input( char *fs_iinpath, char *fs_iinsel,
                               int *fs_iexbutton );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt eine Dateiauswahlbox mit dem
               Pfadnamen, auf den fs_iinpath zeigt, auf dem Bildschirm
               dar und erlaubt es dem Benutzer, ein File auszuwÑhlen.
               Der eventuell verÑnderte Pfadname steht dann in dem
               Buffer, auf den fs_iinpath zeigt. Der ausgewÑhlte
               Filename steht in fs_iinsel, und fs_iexbutton enthÑlt
               die Nummer des Knopfes, mit dem die Fileselektorbox
               verlassen wurde (0 = CANCEL, 1 = OK).
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Dateiauswahl\#
Querverweis    \#fsel_exinput\#
\end

screen( capsensitive("fsel_exinput") )
Name           File Selection Input - selektiert Dateinamen.
               (erst ab TOS Version 1.4 verfÅgbar)

Definition     int fsel_exinput( char *fs_einpath, char *fs_einsel,
                               int *fs_eexbutton, char *elabel );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt eine Dateiauswahlbox mit dem
               Pfadnamen, auf den fs_einpath zeigt, auf dem Bildschirm
               dar und erlaubt es dem Benutzer, ein File auszuwÑhlen.
               Der eventuell verÑnderte Pfadname steht dann in dem
               Buffer, auf den fs_einpath zeigt. Der ausgewÑhlte
               Filename steht in fs_einsel, und fs_eexbutton enthÑlt
               die Nummer des Knopfes, mit dem die Fileselektorbox
               verlassen wurde (0 = CANCEL, 1 = OK).
               Mit elabel kann zusÑtzlich ein Titel Åbergeben werden,
               der als öberschrift in der Dateiauswahlbox angezeigt
               wird.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurÅckgegeben wird.
Gruppe         \#Dateiauswahl\#
Querverweis    \#fsel_input\#
\end

screen( "VDI" )
Das VDI
----------------------------------------------------------------------

Die VDI-Funktionen lassen sich in folgende Gruppen gliedern:

               \#Kontrollfunktionen\#
               \#Ausgabefunktionen\#
               \#Attributfunktionen\#
               \#Rasterfunktionen\#
               \#Eingabefunktionen\#
               \#Auskunftsfunktionen\#
               \#Escapefunktionen\#

WÑhrend das \#AES\#-System in erster Linie die Basis fÅr eine bedie-
nungsfreundliche BenutzeroberflÑche sein soll, sind die VDI-Funktionen
als standardisiertes Grafiksystem zu verstehen.
Leider ist das VDI-System auûerhalb der \#GEM\#-Welt nur wenig verbrei-
tet und hat aus diesem Grund nur wenig Chancen einmal ein echter Stan-
dard zu werden. Dem Programmierer stellt sich VDI als eine sehr um-
fangreiche Grafikbibliothek dar, deren Ausgabeformat Åber mehrere Com-
putersysteme hinweg portabel ist.
FÅr ein systemunabhÑngiges Grafiksystem ist ein von der jeweiligen
Hardware unabhÑngiges Koordinatensystem nîtig. In VDI sind dies die
Normalkoordinaten. Der Ursprung dieses Koordinatensystems liegt in der
linken unteren Ecke, der Wertebereich reicht von 0 bis 32767, schîpft
demnach die 16 Bit eines Maschinenwortes voll aus. Daneben gibt es
jedoch noch ein zweites Koordinatensystem, die Rasterkoordinaten, mit
deren Hilfe groûflÑchige Kopieroperationen und Verschiebungen ohne Ge-
schwindigkeitsverlust durchgefÅhrt werden kînnen. Unter \#GEM\# kann man
also wahlweise zwei verschiedene Koordinatensysteme verwenden.

Die zum Arbeiten mit den VDI-Funktionen nîtigen Konstanten, Daten-
strukturen und Funktionsprototypen finden Sie in der Datei VDI.H.

Einige der VDI-Funktionen benîtigen jedoch die VDI-erweiterung \#GDOS\#.
\end

screen( "GDOS" )
Das GDOS
----------------------------------------------------------------------

Einige Funktionen des VDI kînnen erst nach der Installation des GDOS
aus dem AUTO-Ordner heraus richtig benutzt werden. GrundsÑtzlich
ermîglicht das GDOS beliebige GerÑtetreiber und ZeichensÑtze, die
im ASSIGN.SYS File aufgefÅhrt werden mÅssen, zu laden und zu benutzen.
Es ist dabei vîllig unabhÑngig vom verwendeten GerÑt. GerÑtespezifisch
sind nur die nachzuladenden Treiber, die die VDI Funktionen auf dem
entsprechenden GerÑt realisieren. Bei genauer Kenntnis des
Treiberformats ist es so mîglich beliebige, und auch exotische
AusgabegerÑte als VDI AusgabegerÑt zu betreiben.
Mit residentem GDOS erhîht sich die Zahl der VerfÅgung stehenden
VDI-Funktionen, wÑhrend alle anderen Funktionen voll funktionsfÑhig
bleiben bzw. einen erweiterten Ausgabeumfang erhalten. Umgekehrt ist
das aber nicht so, Funktionen, die GDOS benîtigen, fÅhren ohne
residentes GDOS zum Absturz des Rechners.

Die neueste Version des GDOS ist das \#FSMGDOS\#, das zusÑtzlich
frei scalierbare ZeichensÑtze zur VerfÅgung stellt.

Die Funktionen \#vq_gdos\# und \#vq_vgdos\# prÅfen, ob GDOS installiert
ist. Einige Funktionen sollten nicht ohne GDOS benutzt werden:

\#v_opnwk\#, \#v_clswk\#, \#vst_load_fonts\#, \#vst_unload_fonts\#,
\#vst_font\#, \#v_clear_disp_list\#, \#v_bit_image\#, \#vqp_films\#,
\#vqp_state\#, \#vsp_state\#, \#vsp_save\#, \#vsp_message\#, \#vqp_error\#,
\#v_meta_extents\#, \#v_write_meta\#, \#vm_filename\#,  \#vm_coords\#,
\#vm_pagesize\#
\end

screen( "FSM",
		"FSMGDOS" )
Das FSMGDOS
----------------------------------------------------------------------

Die neueste Version des \#GDOS\# ist das FSMGDOS, das zusÑtzlich
frei scalierbare ZeichensÑtze zur VerfÅgung stellt. FSM steht
fÅr Font Scale Manager.

Die Funktion \#vq_vgdos\# prÅft, ob FSMGDOS installiert ist.
Einige Funktionen kînnen ohne FSMGDOS nicht benutzt werden
(zusÑtzlich zu den unter \#GDOS\# aufgefÅhrten Funktionen):


\#vqt_f_extent\#, \#v_ftext\#, \#v_killoutline\#, \#v_getoutline\#,
\#vst_scratch\#, \#vst_error\#, \#vqt_advance\#, \#vst_arbpt\#,
\#vqt_devinfo\#, \#v_flushcache\#, \#vqt_cachesize\#,
\#vqt_get_tables\#, \#v_loadcache\#, \#v_savecache\#,
\#vst_setsize\#, \#vst_skew\#
\end

screen( capsensitive("handle") )
Das VDI-Handle
----------------------------------------------------------------------

dient zur Spezifikation des Zieles der VDI-Funktionen. Hat man mehrere
GerÑte, wie Drucker und Bildschirm, als Arbeitsstation (\#v_opnwk\#,
\#v_opnvwk\#) geîffnet, wird jeder Arbeitsstation ein handle zugeteilt,
durch das das VDI erkennt, welches GerÑt angesprochen werden soll.
Jede VDI-Funktion braucht also grundsÑtzlich einen Parameter handle
zur Zielangabe und die \#Attributfunktionen\# setzen die Attribute
grundsÑtzlich nur fÅr das durch das handle spezifizierte GerÑt, d. h.
Attribute kînnen fÅr alle GerÑte verschieden eingestellt werden.
\end

screen( capsensitive("pxyarray") )
Das pxyarray
----------------------------------------------------------------------

wird im VDI benutzt um verschiedene grafische Objekte
anhand von mehreren Koordinatenpaaren (x,y) darzustellen. Beispiele
fÅr die Anwendung des pxyarrays sind die Darstellung von Rechtecken.

       pxyarray[0]         x-Koordinate des oberen linken Eckpunktes
       pxyarray[1]         y-Koordinate des oberen linken Eckpunktes
       pxyarray[2]         x-Koordinate des unteren rechten Eckpunktes
       pxyarray[3]         y-Koordinate des unteren rechten Eckpunktes
oder allgemein von n Punktepaaren
       pxyarray[0]         x-Koordinate des ersten Punktepaares
       pxyarray[1]         y-Koordinate des ersten Punktepaares
       pxyarray[2]         x-Koordinate des zweiten Punktepaares
       pxyarray[3]         y-Koordinate des zweiten Punktepaares
           :
       pxyarray[2*n - 2]   x-Koordinate des n-ten Punktepaares
       pxyarray[2*n - 1]   y-Koordinate des n-ten Punktepaares
\end

screen( "Kontrollfunktionen" )
Kontrollfunktionen im öberblick
----------------------------------------------------------------------

Alle VDI-Applikationen mÅssen sich beim System ordentlich anmelden,
damit die vorhandenen Resourcen einwandfrei bereitgestellt werden
kînnen.

\#v_bez_on\#          Bezier-Spline-Erzeugung an.
\#v_bez_off\#         Bezier-Spline-Erzeugung aus.
\#v_clrwk\#           Reinitialisierung einer Arbeitsstation.
\#v_clswk\#           Physikalische Arbeitstation (Drucker etc.) abmelden.
\#v_clsvwk\#          Virtuelle Arbeitstation (Bildschirm) abmelden.
\#v_flushcache\#      \#FSM\#-Cache lîschen.
\#v_getoutline\#      Outline eines Zeichens berechnen.
\#v_killoutline\#     Speicher zur Outline-Generierung freigeben.
\#v_loadcache\#       FSM-Cache laden.
\#v_opnwk\#           Physikalische Arbeitstation (Drucker etc.) anmelden.
\#v_opnvwk\#          Virtuelle Arbeitstation (Bildschirm) anmelden.
\#v_set_app_buff\#    Speicher fÅr Bezier-Spline-Erzeugung reservieren.
\#v_savecache\#       FSM-Cache speichern.
\#v_updwk\#           Befehle im Puffer eines Ein-/AusgabegerÑts sofort
                  ausfÅhren.
\#vs_clip\#           Arbeitsbereich auf einen Teil des Bildschirms be-
                  schrÑnken.
\#vst_load_fonts\#    ZusÑtzliche ZeichensÑtze laden.
\#vst_unload_fonts\#  Speicherplatz, den zusÑtzliche ZeichensÑtze belegt
                  haben, freigeben.
\end

screen( "Ausgabefunktionen" )
Ausgabefunktionen im öberblick
----------------------------------------------------------------------

\#v_alpha_text\#   Ausgabe von Text im Textmodus
\#v_bez\#          Bezier-Spline zeichnen.
\#v_bez_fill\#     Bezier-Spline zeichnen und fÅllen.
\#v_pline\#        Linienzug zeichnen.
\#v_pmarker\#      Markierung zeichnen.
\#v_gtext\#        Text grafisch ausgeben.
\#v_ftext\#        Text mittels \#FSM\#-Font ausgeben.
\#v_fillarea\#     Angegebene FlÑche ausfÅllen.
\#v_cellarray\#    Farbauswahltabelle darstellen.
\#v_contourfill\#  FlÑche bis zu bestimmten Begrenzungen ausfÅllen.
\#vr_recfl\#       Rechteck ausfÅllen.
\#v_arc\#          Kreisbogen zeichnen.
\#v_bar\#          AusgefÅlltes Rechteck zeichnen.
\#v_circle\#       AusgefÅllten Kreis zeichnen.
\#v_ellipse\#      AusgefÅllte Ellipse zeichnen.
\#v_ellarc\#       Ellipsenbogen zeichnen.
\#v_ellpie\#       AusgefÅlltes Ellipsensegment zeichnen.
\#v_justified\#    Ausgerichteten Text ausgeben.
\#v_pieslice\#     AusgefÅlltes Kreissegment zeichnen.
\#v_rbox\#         Abgerundetes Rechteck zeichnen.
\#v_rfbox\#        AusgefÅlltes, abgerundetes Rechteck zeichnen.

Mit den Ausgabefunktionen kînnen grafische Elemente wie Kreise und
Linien, aber auch Texte auf den angemeldeten Arbeitsstationen ausge-
geben werden.
\end

screen( "Attributfunktionen" )
Attributfunktionen im öberblick
----------------------------------------------------------------------

Diese Gruppe von Funktionen dient dem Einstellen von Farbe, Typ, Stil
und Hîhe der \#Ausgabefunktionen\#.

˘ öbergeordnete Attribute:

\#vs_color\#       FarbintensitÑt einer Farbe festlegen.
\#vswr_mode\#      Schreibmodus(Replace, Transparent, ...) auswÑhlen.

˘ Linienattribute:

\#vsl_color\#      Linienfarbe auswÑhlen.
\#vsl_ends\#       Linienenden definieren (Abrundung, Pfeile, ...).
\#vsl_type\#       Liniendarstellung einstellen.
\#vsl_udsty\#      Eigene Liniendarstellung definieren.
\#vsl_width\#      Linienbreite definieren.
\#v_bez_qual\#     QualitÑt der Bezier-Spline-Erzeugung setzen.

˘ Markierungsattribute:

\#vsm_color\#      Markierungsfarbe festlegen.
\#vsm_height\#     Markierungsgrîûe festlegen.
\#vsm_type\#       Markierungstyp auswÑhlen.

˘ Textattribute:

\#vst_alignment\#  Horizontale und vertikale Ausrichtung eines Texts
               bestimmen.
\#vst_arbpt\#      Setzen der Zeichenzellenhîhe in Punkten.
\#vst_color\#      Farbe fÅr Textausgaben festlegen.
\#vst_effects\#    Texteffekte auswÑhlen (kursiv, ...).
\#vst_error\#      Setzen der \#FSMGDOS\# Fehlerbehandlung.
\#vst_font\#       Zeichensatz auswÑhlen.
\#vst_height\#     Textgrîûe festlegen.
\#vst_point\#      Grîûe der Zeichenzelle festlegen.
\#vst_rotation\#   Drehung der Textausgabe.
\#vst_scratch\#    Bestimmen der Grîûe des Scratch-Buffers.
\#vst_setsize\#    Setzen der Zeichenzellenbreiten in Punkten.
\#vst_skew\#       Setzen des Neigungsgrades fÅr Kursivschrift.

˘ FÅlltypattribute:

\#vsf_color\#      FÅllfarbe auswÑhlen.
\#vsf_interior\#   Auswahl des FÅlltyps (Muster, schraffiert, ...).
\#vsf_perimeter\#  Rahmen zeichnen oder nicht.
\#vsf_style\#      FÅllmuster auswÑhlen.
\#vsf_udpat\#      Eigenes FÅllmuster definieren.
\end

screen( "Rasterfunktionen" )
Rasterfunktionen
----------------------------------------------------------------------

Die Rasterfunktionen erlauben es logische Operationen auf rechtwink-
ligen Blîcken auszufÅhren. Dazu gehîrt auch das Kopieren von Speicher-
bereichen in den Bildschirm hinein oder ebenso heraus.

\#v_get_pixel\# Pixelstatus ermitteln (gesetzt oder gelîscht).
\#vr_trnfm\#    Raster in gerÑtespezifische Formate transformieren.
\#vro_cpyfm\#   Bildschirmbereich pixelweise kopieren (opaque).
\#vrt_cpyfm\#   Bildschirmbereich pixelweise kopieren (transparent).
\end

screen( "Eingabefunktionen" )
Eingabefunktionen im öberblick
----------------------------------------------------------------------

\#v_hide_c\#          Grafikcursor abschalten.
\#v_show_c\#          Grafikcursor darstellen.
\#vex_butv\#          Serviceroutine fÅr Maustasteninterrupt verlegen.
\#vex_curv\#          Mauszeiger selbst zeichnen.
\#vex_motv\#          Serviceroutine fÅr Mausbewegungsinterrupt verlegen.
\#vex_timv\#          Serviceroutine des Timerinterrupts verlegen.
\#vq_key_s\#          Tastaturstatus abfragen.
\#vq_mouse\#          Position des Grafikcursors ermitteln.
\#vrq_choice\#        Tastendruck abwarten (REQUEST).
\#vrq_locator\#       Position des Grafikcursor ermitteln (REQUEST).
\#vrq_string\#        String von Tastatur einlesen (REQUEST).
\#vrq_valuator\#      öberwachung von EingabegerÑten (REQUEST).
\#vsc_form\#          Grafikcursor definieren.
\#vsin_mode\#         Umschalten zwischen REQUEST- und SAMPLE-Modus.
\#vsm_choice\#        Ermittelt die zuletzt gedrÅckte Taste (SAMPLE).
\#vsm_locator\#       Position des Grafikcursor ermitteln (SAMPLE).
\#vsm_string\#        String von Tastatur einlesen (SAMPLE).
\#vsm_valuator\#      Ermittlung des Status von EingabegerÑten (SAMPLE).

Die Eingabefunktionen dienen der Interaktion zwischen \#Betriebssystem\#
und Anwenderprogramm. Sie lassen sich in zwei verschiedenen Modi be-
treiben:

˘ REQUEST-Modus:     Es wird nach Aufruf einer der Funktionen solange
                     gewartet, bis das entsprechende Ereignis ein-
                     tritt.
˘ SAMPLE-Modus:      Es wird lediglich der Status des GerÑtes Åber-
                     prÅft, danach kehrt die Funktion sofort wieder
                     zurÅck.
\end

screen( "Auskunftsfunktionen" )
Auskunftsfunktionen im öberblick
----------------------------------------------------------------------

\#vq_cellarray\#      Abfrage der Belegung einer Farbauswahltabelle.
\#vq_color\#          FarbintensitÑten ermitteln.
\#vq_extnd\#          ZusÑtzliche Informationen Åber die Konfiguration
                  einer Arbeitsstation ermitteln.
\#vq_gdos\#           Ermitteln, ob \#GDOS\# geladen ist.
\#vq_vgdos\#          Ermitteln, welche GDOS-Version geladen ist,
                  bespielsweise \#FSMGDOS\#.
\#vq_scan\#           Druckerparameter ermitteln.
\#vqf_attributes\#    FÅllattribute ermitteln.
\#vqin_mode\#         Eingabemodus eines EingabegerÑts abfragen.
\#vql_attributes\#    Linienattribute ermitteln.
\#vqm_attributes\#    Markierungsattribute ermitteln.
\#vqt_advance\#       Position fÅr nÑchstes \#FSM\#-Zeichen ermitteln.
\#vqt_attributes\#    Textattribute ermitteln.
\#vqt_cachesize\#     Ermitteln der Grîûe des \#FSM\#-Caches.
\#vqt_devinfo\#       Status des AusgabegerÑts erfragen.
\#vqt_extent\#        Dimensionen eines Textrechtecks berechnen.
\#vqt_f_extent\#      Dimensionen eines Textrechtecks fÅr \#FSM\#-Fonts
                  berechnen.
\#vqt_fontinfo\#      Informationen Åber einen Zeichensatz ermitteln.
\#vqt_get_tables\#    Adresse der Zeichentransformationstabellen
                  erfragen.
\#vqt_name\#          Namen und Index eines Zeichensatzes ermitteln.
\#vqt_width\#         Dimensionen einer Zeichenzelle berechnen.

Mittels der Auskunftsfunktionen ist es mîgliche weitere Informationen
Åber Einstellungen einzelner GerÑte zu holen.
\end

screen( "Escapefunktionen" )
Escapefunktionen im öberblick
----------------------------------------------------------------------

Mit den Escapefunktionen wird es einem Anwenderprogramm ermîglicht auf
spezielle Eigenschaften einer Arbeitsstation zuzugreifen.

˘ Textfunktionen:

\#vs_curaddress\#     Textcursor in Reihe und Spalte positionieren.
\#v_curdown\#         Textcursor eine Zeile nach unten bewegen.
\#v_curright\#        Textcursor eine Spalte nach rechts bewegen.
\#v_curleft\#         Textcursor eine Spalte nach links bewegen.
\#v_curhome\#         Textcursor in die linke obere Ecke bewegen.
\#v_curtext\#         Text ab Textcursorposition ausgeben.
\#v_curup\#           Textcursor eine Zeile nach oben bewegen.
\#v_eeol\#            Bildschirm ab Textcursor bis Zeilenende lîschen.
\#v_eeos\#            Bildschirm ab Textcursor bis Bildschirmende lîschen.
\#v_enter_cur\#       Textmodus einschalten.
\#v_exit_cur\#        Textmodus verlassen.
\#v_rvon\#            Inverse Darstellung einschalten.
\#v_rvoff\#           Inverse Darstellung abschalten.
\#vq_chcells\#        Zeilen und Spalten des Textbildschirms ermitteln.
\#vq_curaddress\#     Zeile und Spalte des Textcursors ermitteln.

˘ Grafikspezialfunktionen:

\#v_bit_image\#       Bildinformationen auf Drucker ausgeben.
\#v_clear_disp_list\# Druckpuffer lîschen.
\#v_dspcur\#          Grafikcursor versetzen.
\#v_form_adv\#        Seitenvorschub auf Drucker durchfÅhren.
\#v_hardcopy\#        Hardcopy auf Drucker ausgeben.
\#v_output_window\#   Bildschirmbereich auf Drucker ausgeben.
\#v_rmcur\#           Letzten Grafikcursor lîschen.
\#vq_tabstatus\#      VerfÅgbarkeit eines Grafiktabletts,
                  Maus, usw. abfragen.
\#vs_palette\#        Auswahl der Farbpalette.

˘ Polaroid-Camera:

\#vqp_error\#         Fehlercodes des Polaroid-Treibers abfragen.
\#vqp_films\#         VerfÅgbare Filmtypen ermitteln.
\#vqp_state\#         Status des Polaroid-Treibers ermitteln.
\#vsp_message\#       Fehlermeldungen des Polaroid-Treibers unterdrÅcken
                  oder zulassen.
\#vsc_expose\#        Preview-Mîglichkeit fÅr Kamera ein-/ausschalten.
\#vsp_film\#          Filmtyp und Belichtungszeit festlegen.
\#vsp_save\#          Einstellung des Polaroid-Treibers sichern.
\#vsp_state\#         Polaroid-Treiber neu einstellen. 

˘ Grafiktablett:

\#vt_alignment\#      Koordinatensystem des Grafiktabletts ausrichten.
\#vq_tdimensions\#    Ausmaûe des Grafiktabletts in 1/10-Zoll.
\#vt_resolution\#     Auflîsung des Grafiktabletts einstellen.
\#vt_axis\#           Auflîsung des Grafiktabletts einstellen.
\#vt_origin\#         Koordinatenursprung fÅr Grafiktablett setzen.

˘ Metafiles:

\#v_meta_extents\#    Dimensionen eines Metafiles berechnen.
\#v_write_meta\#      Grafik-Pimitive in Metafile ablegen.
\#vm_filename\#       Metafile umbenennen.
\#vm_coords\#         Neues Koordinatensystem fÅr Metafile
\#vm_pagesize\#       Physikalische Seitengrîûe fÅr Metafile

˘ Spezialfunktionen:

\#vs_mute\#           Ein-/Ausschalten der Tonerzeugung.
\#v_escape2000\#      Spezialfunktion fÅr ATARI-Page-Printer.
\#v_fontinit\#        Eigenen Systemzeichensatz auswÑhlen.
\#v_offset\#          Abstand zum linken Bildschirmrand festlegen.
\#v_sound\#           Ton generieren.
\end

screen( capsensitive("v_opnwk") )
Name           Open Workstation

Definition     void  v_opnwk( int *work_in, int *\#handle\#,
                              int *work_out);

Beschreibung   Die Funktion lÑdt einen GerÑtetreiber. Dazu muû sich
               jedoch das \#GDOS\# im Speicher befinden und der
               GerÑtetreiber muû im ASSIGN.SYS File aufgezÑhlt sein.
               Falls alles geklappt hat, erhÑlt man in \#handle\# eine
               positive GerÑtekennung und Null im Fehlerfall.

        work_in         Zeiger auf ein Integerfeld mit den genaueren
                        Spezifikationen des zu ladenden GerÑtetreibers
        work_in[0]      Nummer des GerÑtetreibers wie im ASSIGN.SYS
                        angegeben
        work_in[1]      Linientyp
        work_in[2]      Polylinefarbe
        work_in[3]      Markertyp
        work_in[4]      Markerfarbe
        work_in[5]      Textstil
        work_in[6]      Textfarbe
        work_in[7]      FÅllmustertyp
        work_in[8]      FÅllmusternummer
        work_in[9]      FÅllmusterfarbe
        work_in[10]     welche Koordinaten sollen benutzt werden:
                                0  NDC Koordinaten
                                2  RC Koordinaten
        work_out        Zeiger auf ein Integerfeld, das genauere
                        Informationen Åber den geladenen GerÑtetreiber
                        enthÑlt
        work_out[0]     Anzahl der maximal ansprechbaren
                        Rastereinheiten in der Horizontalen
        work_out[1]     Anzahl der maximal ansprechbaren
                        Rastereinheiten in der Vertikalen
        work_out[2]     Skalierungsflag:
                                0  GerÑt kann exakt skalieren
                                1  GerÑt kann nicht exakt skalieren
        work_out[3]     Breite einer Rastereinheit in Mikrometern
        work_out[4]     Hîhe einer Rastereinheit in Mikrometern
        work_out[5]     Anzahl der Zeichensatzhîhen oder Null, falls
                        die Hîhe kontinuierlich verÑndert werden kann
        work_out[6]     Anzahl der Linientypen
        work_out[7]     Anzahl der LinienstÑrken oder Null, falls die
                        StrichstÑrke kontinuierlich verÑndert werden
                        kann
        work_out[8]     Anzahl der Markertypen
        work_out[9]     Anzahl der Markergrîûen oder Null, falls die
                        Grîûe kontinuierlich verÑndert werden kann
        work_out[10]    Anzahl der ZeichensÑtze
        work_out[11]    Anzahl der FÅllmuster
        work_out[12]    Anzahl der Schraffurarten
        work_out[13]    Anzahl der gleichzeitig darstellbaren Farben
        work_out[14]    Anzahl der verfÅgbaren Grafikgrundfunktionen
                        (GENERAL DRAWING PRIMITIV, GDP)
        work_out[15]    Liste der auf dem GerÑt verfÅgbaren GDP's.
            :           Sind es weniger als zehn wird die Liste
            :           durch -1 beendet. Das \#VDI\# unterstÅtzt
            :           folgende GDP's:
            :
            :                   1   BAR
            :                   2   ARC
            :                   3   PIESLICE
            :                   4   CIRCLE
            :                   5   ELLIPSE
            :                   6   ELLIPTICAL ARC
            :                   7   ELLIPTICAL PIE
            :                   8   ROUNDED RECTANGLE
            :                   9   FILLED ROUNDED RECTANGLE
            :                   10  JUSTIFIED GRAPHICS TEXT
        work_out[24]
        work_out[25]    Liste aller Attribute der GDP's:
            :
            :                   0  Linie
            :                   1  Marker
            :                   2  Text
            :                   3  FÅllbereich
            :                   4  kein Attribut
        work_out[34]
        work_out[35]    das GerÑt ist farbtÅchtig (1) oder nicht (0)
        work_out[36]    das GerÑt kann Text rotieren (1) oder
                        nicht (0)
        work_out[37]    das GerÑt kann eine FÅlloperation
                        ausfÅhren (1) oder nicht (0)
        work_out[38]    das GerÑt unterstÅtzt CELL ARRAY (1) oder
                        nicht (0)
        work_out[39]    Anzahl der verfÅgbaren Farben
        work_out[40]    LOCATOR GerÑt:  1  nur die Tastatur
                                        2  Tastatur und andere GerÑte
        work_out[41]    VALUATOR GerÑt: 1  nur die Tastatur
                                        2  anderes GerÑt
        work_out[42]    Auswahtasten:   1  Funktionstasten auf der
                                           Tastatur
                                        2  zusÑtzliches Tastenfeld
        work_out[43]    Zeicheneingabe: 1  Tastatur
        work_out[44]    GerÑtetyp:      0  reines AusgabegerÑt
                                        1  reines EingabegerÑt
                                        2  Ein/AusgabegerÑt
                                        3  reserviert
                                        4  Metafile Ausgabe
        work_out[45]    kleinste Buchstabenbreite
        work_out[46]    kleinste Buchstabenhîhe
        work_out[47]    grîûte Buchstabenbreite
        work_out[48]    grîûte Buchstabenhîhe
        work_out[49]    kleinste darstellbare LinienstÑrke
        work_out[50]    immer Null
        work_out[51]    grîûte LinienstÑrke
        work_out[52]    immer Null
        work_out[53]    kleinste darstellbare Markerbreite
        work_out[54]    kleinste darstellbare Markerhîhe
        work_out[55]    grîûte Markerbreite
        work_out[56]    grîûte Markerhîhe

Querverweis    \#GDOS\#, \#v_clswk\#
\end

screen( capsensitive("v_clswk") )
Name           Close Workstation - Die Kontrollfunktion v_clswk
               schlieût ein mit \#v_opnwk\# geîffnetes GerÑt

Definition     void    v_clswk( int \#handle\# );

Beschreibung   Die Funktion schlieût ein vorher mit \#v_opnwk\#
               geîffnetes GerÑt mit dem Handle \#handle\#. Vor
               Aufruf dieser Funktion sollten alle mit \#v_opnvwk\#
               geîffneten virtuellen ArbeitsgerÑte mittels \#v_clsvwk\#
               geschlossen werden.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#GDOS\#, \#v_opnwk\#, \#v_opnvwk\#, \#v_clsvwk\#
\end

screen( capsensitive("v_opnvwk") )
Name           Open virtual Screen Workstation - îffnet eine
               Bildschirmarbeitsstation

Definition     void v_opnvwk ( int *work_in, int *\#handle\#,
                               int *work_out );

Beschreibung   Die Funktion îffnet eine Bildschirmarbeitsstation.
               Die Belegung der Parameter ist identisch mit der
               Parameterbelegung in \#v_opnwk\#.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_opnwk\#, \#v_clsvwk\#, \#graf_handle\#
\end

screen( capsensitive("v_clsvwk") )
Name           Close virtual Screen Workstation - schlieût eine
               Bildschirmarbeitsstation

Definition     void    v_clsvwk( int \#handle\# );

Beschreibung   Die Funktion schlieût eine vorher mit \#v_opnvwk\#
               geîffnete Bildschirmarbeitstation mit dem VDI-Handle
               \#handle\#.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_opnvwk\#, \#v_clswk\#
\end

screen( capsensitive("v_clrwk") )
Name           Clear Workstation - lîscht das ArbeitsgerÑt

Definition     void    v_clrwk( int \#handle\# );

Beschreibung   Die Funktion setzt das ArbeitsgerÑt \#handle\# in den
               Leerzustand, d. h. der Bildschirm wird gelîscht, auf
               dem Drucker oder Plotter wird ein Seitenvorschub erzeugt
               und der Datenpuffer wird gelîscht.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_form_adv\#
\end

screen( capsensitive("v_updwk") )
Name           Update Workstation - gepufferte Ausgabekommandos
               ausfÅhren

Definition     void    v_updwk( int \#handle\# );

Beschreibung   Die Funktion veranlaût das AusgabegerÑt \#handle\#, alle
               gepufferten Ausgabekommandos auszufÅhren. Diese
               Funktion ist jedoch nur fÅr alle GerÑte auûer dem
               Bildschirm sinnvoll, da auf dem Bildschirm alle
               Ausgaben sofort ausgefÅhrt werden.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_opnwk\#
\end

screen( capsensitive("vst_load_fonts") )
Name           Load Fonts - ZeichensÑtze laden

Definition     int     vst_load_fonts( int \#handle\#, int select );

Beschreibung   Die Funktion lÑdt eine Reihe weiterer ZeichensÑtze fÅr
               das AusgabegerÑt \#handle\#, die im ASSIGN.SYS File
               angegeben sind.
               Sie ist allerdings nur dann sinnvoll, wenn vorher das
               \#GDOS\# installiert worden ist.
               select ist immer Null.
Ergebnis       Als Ergebnis erhÑlt man die Anzahl der geladenen
               ZeichensÑtze.
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#GDOS\#, \#vst_unload_fonts\#, \#vst_font\#, \#vqt_name\#
\end

screen( capsensitive("vst_unload_fonts") )
Name           Unload Fonts - lîscht geladene ZeichensÑtze

Definition     void    vst_unload_fonts( int \#handle\#, int select );

Beschreibung   Die Funktion gibt den Speicherbereich, der durch
               zusÑtzlich geladene ZeichensÑtze fÅr das GerÑt \#handle\#
               belegt wird, wieder frei. Da man zusÑtzliche
               ZeichensÑtze nur mit \#GDOS\# im Speicher geladen werden
               kînnen, ist auch diese Funktion nur mit \#GDOS\# sinnvoll.
               select  ist immer Null.
Ergebnis       Die Funktion hat kein direktes Funktionsergebnis.
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#GDOS\#, \#vst_load_fonts\#
\end

screen( capsensitive("vs_clip") )
Name           Set clipping Rectangle - setzt Begrenzungsrechteck.

Definition     void vs_clip ( int \#handle\#, int clip_flag,
                              int *\#pxyarray\# );

Beschreibung   Die Funktion begrenzt alle grafischen Ausgaben auf dem
               GerÑt \#handle\# auf das in \#pxyarray\# angegebene
               Rechteck, falls clip_flag gleich Eins ist.
               Ist clip_flag gleich Null, so wird das Clipping wieder
               ausgeschaltet.
Ergebnis       Die Funktion hat kein direktes Funktionsergebnis.
Gruppe         \#Kontrollfunktionen\#
\end

screen( capsensitive("v_pline") )
Name           Polyline - Linienzug zeichnen

Definition     void v_pline( int \#handle\#, int count, int *\#pxyarray\# );

Beschreibung   Die Funktion zeichnet einen Linienzug zwischen count
               Punkten in \#pxyarray\# auf dem AusgabegerÑt \#handle\# unter
               BerÅcksichtigung aller Linienattribute.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#  \#pxyarray\#
\end

screen( capsensitive("v_pmarker") )
Name           Polymarker - makiert Punkte.

Definition     void v_pmarker ( int \#handle\#, int count,
                                int *\#pxyarray\# );

Beschreibung   Die Funktion markiert count Punkte, die in \#pxyarray\#
               angegeben sind, auf dem AusgabegerÑt \#handle\# unter
               BerÅcksichtigung der aktuellen Polymarkerattribute.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsm_type\#   \#vsm_height\#
               \#vsm_color\#  \#pxyarray\#
\end

screen( capsensitive("v_gtext") )
Name           Text - gibt eine Text aus.

Definition     void  v_gtext( int \#handle\#, int x, int y, char *string );

Beschreibung   Die Funktion gibt den string an den Koordinaten x und y
               auf dem durch \#handle\# spezifizierten ArbeitsgerÑt
               aus. Die \#Textattribute\# werden dabei berÅcksichtigt.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.

Gruppe         \#Ausgabefunktionen\#

Querverweis    \#vswr_mode\#    \#vs_color\#    \#vst_alignment\#
               \#vst_height\#   \#vst_point\#   \#vst_rotation\#
               \#vst_font\#     \#vst_color\#   \#vst_effects\#
               \#v_ftext\#
\end

screen( capsensitive("v_ftext") )
Name           Text - gibt eine Text mittels FSM-Font aus.

Definition     void  v_ftext( int \#handle\#, int x, int y, char *string );

Beschreibung   Die Funktion gibt den string an den Koordinaten x und y
               auf dem durch \#handle\# spezifizierten ArbeitsgerÑt
               aus.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.

Gruppe         \#Ausgabefunktionen\#
Querverweis    \#v_gtext\#      \#FSMGDOS\#
\end

screen( capsensitive("v_fillarea") )
Name           Filled Area - fÅllt eine FlÑche.

Definition     void v_fillarea ( int \#handle\#, int count,
                                 int *\#pxyarray\# );

Beschreibung   Die Funktion fÅllt die FlÑche, die durch den
               Polygonzug, der durch count und \#pxyarray\# festgelegt
               wird, eingerahmt wird, auf dem GerÑt \#handle\# unter
               Beachtung aller FÅllattribute.
Ergebnis       Die Funktion hat kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#  \#pxyarray\#
\end

screen( capsensitive("v_cellarray") )
Name           Cell Array - Farbaufbau des Bildschirms in Koordinaten.

Definition     void v_cellarray( int \#handle\#, int *\#pxyarray\#,
                                 int row_length,int el_used,
                                 int num_rows,  int wrt_mode,
                                 int *colarray );

Beschreibung   Die Funktion ermîglicht es, den Farbaufbau des
               Bildschirms nicht von den gezeichneten Objekten
               abhÑngig zu machen, sondern von den Koordinaten des
               Bildschirms. Dazu wird das AusgabegerÑt \#handle\# in
               eine Anzahl von Zellen unterteilt, wobei jeder Zelle
               eine Farbe zugeordnet wird. Erfolgt nun eine Ausgabe
               in der entsprechenden Zelle, so erfolgt diese in der,
               der Zelle zugeordneten Farbe. Die Funktion ist nicht
               auf allen AusgabegerÑten verfÅgbar.
\#pxyarray\#       Koordinaten des Begrenzungsrechtecks
colarray       Farbindexarray, enthÑlt zeilenweise die
               Farbinformation fÅr das ganze Rechteck
row_length     Anzahl der Spalten
num_row        Anzahl der Zeilen
el_used        Anzahl der benutzten EintrÑge im
               Farbindexarray colarray
wrt_mode       Schreibmodus, wie in \#vswr_mode\#, jedoch
               nur fÅr das angegebene Rechteck
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#pxyarray\#
\end

screen( capsensitive("v_contourfill") )
Name           Countour fill - fÅllt eine FlÑche.

Definition     void v_contourfill ( int \#handle\#, int x, int y,
                                    int index );

Beschreibung   Die Funktion fÅllt die FlÑche, innerhalb derer der
               Punkt x,y liegt, und die von Punkten der Farbe index
               umgeben ist, auf dem GerÑt \#handle\# unter Beachtung
               der aktuellen FÅllattribute.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("vr_recfl") )
Name           Fill Rectangle - fÅllt eine RechtecksflÑche.

Definition     void vr_recfl( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Die Funktion fÅllt eine RechtecksflÑche, die durch
               \#pxyarray\# festgelegt wird, auf dem GerÑt \#handle\# unter
               Beachtung der aktuellen FÅllattribute aus.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#v_fillarea\#   \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#
               \#vsf_style\#    \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
               \#pxyarray\#
\end

screen( capsensitive("v_bar") )
Name           Bar - zeichnet ein ausgefÅlltes Rechteck.

Definition     void v_bar( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Die Funktion zeichnet auf dem AusgabegerÑt \#handle\# ein
               ausgefÅlltes Rechteck, dessen Ausmaûe durch \#pxyarray\#
               festgelegt werden, unter BerÅcksichtigung der
               FÅllattribute.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#  \#pxyarray\#
\end

screen( capsensitive("v_arc") )
Name           Arc - zeichnet einen Kreisbogen.

Definition     void v_arc( int \#handle\#, int x, int y, int radius,
                           int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem AusgabegerÑt \#handle\# einen
               Kreisbogen mit den Mittelpunktskoordinaten x, y, dem
               Radius radius von dem Startîffnungswinkel begang bis zu
               dem Winkel endang unter Beachtung der Linienattribute.
               Die Winkel werden dabei in 1/10 Grad Schritten
               angegeben.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#
\end

screen( capsensitive("v_pieslice") )
Name           Pie - zeichnet ein "TortenstÅck".

Definition     void v_pieslice ( int \#handle\#, int x, int y,
                                 int radius, int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem AusgabegerÑt \#handle\# ein
               "TortenstÅck" mit den Mittelpunktskoordinaten x, y, dem
               Radius radius von dem Startîffnungswinkel begang bis zu
               dem Winkel endang unter Beachtung der FÅllattribute.
               Die Winkel werden dabei in 1/10 Grad Schritten
               angegeben.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("v_circle") )
Name           Circle - zeichnet eine KreisflÑche.

Definition     void v_circle( int \#handle\#, int x, int y, int radius );

Beschreibung   Die Funktion zeichnet auf dem GerÑt mit der
               GerÑtekennung \#handle\# mit den Mittelpunktskoordinaten
               x, y und dem Radius radius eine KreisflÑche unter
               Beachtung der aktuellen FÅllattribute.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#  \#vsf_udpat\#   \#vsf_perimeter\#
\end

screen( capsensitive("v_ellipse") )
Name           Ellipse - zeichnet eine EllipsenflÑche.

Definition     void v_ellipse( int \#handle\#, int x, int y, int xradius,
                               int yradius  );

Beschreibung   Auf dem AusgabegerÑt mit der Kennung \#handle\# wird unter
               Beachtung der aktuellen FÅllattribute mit den
               Mittelpunktskoordinaten x, y und den Radien xradius in
               x-Richtung und yradius in y-Richtung eine
               EllipsenflÑche gezeichnet.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("v_ellarc") )
Name           Elliptical Arc - zeichnet einen Ellipsenbogen.

Definition     void v_ellarc( int \#handle\#, int x, int y, int xradius,
                              int yradius, int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem AusgabegerÑt mit der
               Kennung \#handle\# einen Ellipsenbogen mit den
               Mittelpunktskoordinaten x, y und den Radien xradius in
               x-Richtung und yradius in y-Richtung. Der Bogen wird
               dabei bei dem Winkel begang begonnen und endet mit dem
               Winkel endang.
               Beide Winkel werden in 1/10 Grad Schritten angegeben.
               Die aktuellen Linienattribute werden dabei beachtet.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#
\end

screen( capsensitive("v_ellpie") )
Name           Elliptical Pie - zeichnet eine EllipsenbogenflÑche.

Definition     void v_ellpie( int \#handle\#, int x, int y, int xradius,
                              int yradius, int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem AusgabegerÑt mit der
               Kennung \#handle\# eine EllipsenbogenflÑche mit den
               Mittelpunktskoordinaten x, y und den Radien xradius in
               x-Richtung und yradius in y-Richtung. Das FlÑchenstÅck
               beginnt dabei bei dem Winkel begang und endet mit dem
               Winkel endang. Beide Winkel werden in 1/10 Grad
               Schritten angegeben.
               Die aktuellen FÅllattribute werden berÅcksichtigt.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
                \#vsf_color\#  \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("v_rbox") )
Name           Rounded Rectangle - zeichnet ein Rechteck mit
               abgerundeten Ecken

Definition     void v_rbox ( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Die Funktion zeichnet auf dem GerÑt mit der Kennung
               \#handle\# ein Rechteck mit abgerundeten Ecken, dessen
               Lage durch die Koordinaten im \#pxyarray\# festgelegt
               wird. Es werden dabei die aktuellen Linienattribute
               beachtet.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#  \#pxyarray\#
\end

screen( capsensitive("v_rfbox") )
Name           Filled rounded Rectangle - zeichnet eine
               RechtecksflÑche mit gerundeten Ecken.

Definition     void v_rfbox ( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Wie \#v_rbox\#, nur mit dem Unterschied, daû eine
               ausgefÅllte RechtecksflÑche mit abgerundeten Ecken
               unter Beachtung der FÅllattribute gezeichnet wird.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#  \#v_rbox\#
               \#pxyarray\#
\end

screen( capsensitive("v_justified") )
Name           Justified Graphics Text - Positionierter Graphiktext.

Definition     void v_justified( int \#handle\#,int x, int y,
                                 char *string, int length,
                                 int word_space, int char_space );

Beschreibung   Die Funktion gibt den Text auf den string zeigt auf dem
               GerÑt mit der Kennung \#handle\# an der Position x, y aus.+
               Dabei besteht die Mîglichkeit den Text auf die LÑnge+
               length (in Pixeln) durch Dehnung der WortzwischenrÑume
               (word_space ungleich Null) oder derZeichenzwischenrÑume
               (char_space ungleich Null) zu formatieren.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#     \#vs_color\#    \#vst_alignment\#
               \#vst_height\#    \#vst_point\#   \#vst_rotation\#
               \#vst_font\#      \#vst_color\#   \#vst_effects\#
\end

screen( capsensitive("vswr_mode") )
Name           Set writing Mode - bestimmt den Schreibmodus fast aller
               Grafikfunktionen.

Definition     int vswr_mode( int \#handle\#, int mode );

Beschreibung   Diese Funktion bestimmt, wie der Bildschirmhintergrund
               mit dem neuen zu zeichnenden Objekten verknÅpft wird.
               Der GÅltigkeitsbereich des gewÑhlten Schreibmodus
               beschrÑnkt sich dabei auf das GerÑt mit der Kennung
               \#handle\# und den Bereich auûerhalb eines eventuell mit
               der Funktion \#v_cellarray\# gewÑhlten Rechtecks.
mode           MD_REPLACE      1  Replace
               MD_TRANS        2  Transparent
               MD_XOR          3  Xor
               MD_ERASE        4  Reverse Transparent
Ergebnis       Die Funktion liefert den tatsÑchlich eingestellten
               Schreibmodus.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#        \#v_pmarker\#   \#v_gtext\#   \#v_fillarea\#
               \#v_contourfill\#  \#vr_recfl\#    \#v_bar\#     \#v_arc\#,
               \#v_pieslice\#     \#v_circle\#    \#v_ellarc\#  \#v_ellpie\#
               \#v_ellipse\#      \#v_rbox\#      \#v_rfbox\#   \#v_justified\#
\end

screen( capsensitive("vs_color") )
Name           Set Color Representation - legt die FarbintensitÑt fest.

Definition     void vs_color( int \#handle\#, int index, int *rgb_in );

Beschreibung   Die Funktion setzt fÅr das AusgabegerÑt mit der Kennung
               \#handle\# die Farbanteile der einzelnen Grundfarben fÅr
               die Farbe mit der Nummer index auf die Werte, die in
               dem Feld rgb_in stehen.
rgb_in[0]      Rotanteil in Promille
rgb_in[1]      GrÅnanteil in Promille
rgb_in[2]      Blaunanteil in Promille
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#      \#v_pmarker\#      \#v_gtext\#   \#v_fillarea\#
               \#v_cellarray\#  \#v_contourfill\#  \#vr_recfl\#  \#v_bar\#
               \#v_arc\#        \#v_pieslice\#     \#v_circle\#  \#v_ellarc\#
               \#v_ellpie\#     \#v_ellipse\#      \#v_rbox\#    \#v_rfbox\#
               \#v_justified\#  \#vq_color\#

\end

screen( capsensitive("vsl_type") )
Name           Set Polyline Type - setzt den Linientyp.

Definition     int vsl_type( int \#handle\#, int style );

Beschreibung   Die Funktion wÑhlt fÅr das AusgabegerÑt mit der Kennung
               \#handle\# das Aussehen aller Linienausgaben.
style          1     (durchgezogen)
               2     (langer Strich)
               3     (punktiert)
               4     (Strich, Punkt)
               5     (Strich)
               6     (Strich, Punkt, Punkt)
               7     (frei definierbar, \#vsl_udsty\#)
               ab 8  eventuell weitere Linientypen auf verschiedenen
                     AusgabegerÑten.

Ergebnis       Die Funktion liefert den tatsÑchlich eingestellten
               Linientyp.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#   \#vsl_udsty\#
\end

screen( capsensitive("vsl_udsty") )
Name           Set User defined Line Style Pattern - setzt den frei
               definierten Linientyp.

Definition     void vsl_udsty( int \#handle\#, int pattern );

Beschreibung   Die Funktion setzt den Linientyp mit der Indexnummer 7
               fÅr das GerÑt \#handle\# auf den Wert pattern. Das
               hîchstwertige Bit ist dabei der erste Punkt des
               Linienmusters.
Gruppe         \#Attributfunktionen\#
Querverweis    \#vsl_type\#
\end

screen( capsensitive("vsl_width") )
Name           Set Polyline Width - setzt die Linienbreite.

Definition     int vsl_width( int \#handle\#, int width );

Beschreibung   Die Funktion setzt fÅr das AusgabegerÑt mit der Kennung
               \#handle\# die StrichstÑrke auf den Wert width.
Ergebnis       Die Funktion liefert die tatsÑchlich eingestellte
               StrichstÑrke.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#
\end

screen( capsensitive("vsl_color") )
Name           Set Polyline Color Index - setzt die Linienfarbe.

Definition     int vsl_color( int \#handle\#, int color_index );

Beschreibung   Die Funktion wÑhlt fÅr das AusgabegerÑt mit der Kennung
               \#handle\# die Farbe mit der Nummer color_index als
               Linienfarbe aus.
Ergebnis       Die Funktion liefert die tatsÑchlich gesetzte
               Linienfarbe
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#
\end

screen( capsensitive("vsl_ends") )
Name           Set Polyline End Styles - setzt die Linienendeform.

Definition     void vsl_ends ( int \#handle\#, int beg_style,
                               int end_style );

Beschreibung   Die Funktion legt fÅr das GerÑt mit der Kennung \#handle\#
               das Aussehen sowohl des Linienanfangs als auch des
               Linienendes fest.

beg_style      Aussehen am Anfangspunkts
                0  eckig
                1  Pfeil
                2  abgerundet
end_style      wie beg_style, nur fÅr das Linienende
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#
\end

screen( capsensitive("vsm_type") )
Name           Set Polymarker Type - bestimmt die Art der
               Markierungspunkte

Definition     int vsm_type ( int \#handle\#, int symbol );

Beschreibung   Die Funktion wÑhlt den Markertyp symbol fÅr das
               AusgabegerÑt \#handle\# aus und gibt den ausgewÑhlten
               Typ zurÅck.

symbol         1  Punkt (nur eine feste Grîûe)
               2  Plus
               3  Stern
               4  Quadrat
               5  Andreaskreuz
               6  Raute
               eventuell weitere Marker auf anderen GerÑten
Ergebnis       Die Funktion liefert den Code der tatsÑchlich
               ausgewÑhlten Markiwerung.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pmarker\#   \#vsm_height\#
\end

screen( capsensitive("vsm_height") )
Name           Set Polymarker Height - bestimmt die Hîhe von
               Markierungspunkten.

Definition     int vsm_height( int \#handle\#, int height );

Beschreibung   Die Funktion setzt fÅr das AusgabegerÑt mit der Kennung
               \#handle\# die Grîûe des Markers auf den Wert height.
Ergebnis       Die Funktion liefert die tatsÑchlich gewÑhlte Grîûe.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pmarker\#
\end

screen( capsensitive("vsm_color") )
Name           Set Polymarker Color Index - bestimmt die Farbe von
               Markierungspunkten.

Definition     int vsm_color ( int \#handle\#, int color_index );

Beschreibung   Die Funktion setzt die Polymarkerfarbe fÅr das
               AusgabegerÑt \#handle\# auf den Farbwert color_index.
Ergebnis       Die Funktion liefert den tatsÑchlich gewÑhlten
               Farbindex.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pmarker\#
\end

screen( capsensitive("vst_height") )
Name           Set Character Height, absolute Mode - bestimmt die
               Zeichengrîûe von Textausgaben.

Definition     void vst_height ( int \#handle\#, int height,
                                 int *char_width, int *char_height,
                                 int *cell_width, int *cell_height );

Beschreibung   Mit der Funktion wird die absolute Zeichengrîûe von
               Textausgaben auf dem GerÑt mit der Kennung \#handle\#
               festgelegt.
height         gewÅnschte Zeichenhîhe
char_width     gewÑhlte Zeichenbreite
char_height    gewÑhlte Zeichenhîhe
cell_width     Zeichenzellenbreite
cell_height    Zeichenzellenhîhe
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#  \#vst_point\#
\end

screen( capsensitive("vst_point") )
Name           Set Character Height, Points Mode - bestimmt die
               Zeichenhîhe von Textausgaben.

Definition     int vst_point ( int \#handle\#, int point, int *char_width,
                               int *char_height, int *cell_width,
                               int *cell_height );

Beschreibung   Die Funktion setzt die Zeichenzellengrîûe, d. h. den
               Abstand zweier Basislinien, fÅr das GerÑt mit der
               Kennung \#handle\# auf den Wert point, der in 1/72"
               Schritten angegeben wird.
point          gewÅnschte Zellenhîhe
char_width     gewÑhlte Zeichenbreite
char_height    gewÑhlte Zeichenhîhe
cell_width     Zeichenzellenbreite
cell_height    Zeichenzellenhîhe
Ergebnis       Die Funktion liefert die gewÑhlte Zeichenzellenhîhe
               in 1/72" Schritten.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#   \#vst_height\#
\end

screen( capsensitive("vst_rotation") )
Name           Set Character Baseline Vector - Bestimmt den Winkel der
               Textausgaben.

Definition     int vst_rotation( int \#handle\#, int angle );

Beschreibung   Die Funktion legt fÅr das AusgabegerÑt \#handle\# den
               Winkel fest, unter dem alle Textausgaben erscheinen.
               Die vorhandenen Treiber unterstÅtzen allerdings nur
               Winkel in 90 Grad Schritten, obwohl man den Winkel in
               1/10 Grad Schritten angeben muû.
Ergebnis       Die Funktion liefert den tatsÑchlich gewÑhlten Winkel.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( capsensitive("vst_font") )
Name           Set Text Face - bestimmt einen Zeichensatz.

Definition     int vst_font( int \#handle\#, int font );

Beschreibung   Die Funktion wÑhlt fÅr das AusgabegerÑt \#handle\# einen
               Zeichensatz aus. Dabei ist font die Nummer des Zeichensatzes,
               die mit \#vqt_name\# errmittelt werden kann. Die Funktion ist
               also nur zusammen mit dem \#GDOS\# in vollen  Umfang einsatz-
               fÑhig. Falls font gleich Eins ist, wird der Systemzeichensatz
               ausgewÑhlt.
Ergebnis       Die Funktion liefert die Nummer des tatsÑchlich
               gewÑhlten Zeichensatzes.

Beispiel       numSets =  \#vst_load_fonts\#( handle, 0 ); /* fonts laden     */
               id = \#vqt_name\#(handle, 2, name );        /* 2. Zeichensatz  */
               vst_font( handle, id );                 /* auswÑhlen       */
               \#v_gtext\#( handle, 100, 100, name );      /* benutzen        */
               
Gruppe         \#Attributfunktionen\#
Querverweis    \#GDOS\# \#vst_load_fonts\# \#v_gtext\# \#v_justified\#
\end

screen( capsensitive("vst_color") )
Name           Set Graphic Text Color Index - bestimmt die Farbe der
               Textausgaben.

Definition     int vst_color ( int \#handle\#, int color_index );

Beschreibung   Die Funktion setzt die Farbe unter der Textausgaben
               erfolgen fÅr das GerÑt mit der Kennung \#handle\# auf den
               Wert color_index.
Ergebnis       Die Funktion liefert die tatsÑchlich eingestellte Farbe.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( "Textattribute",
		capsensitive("vst_effects") )
Name           Set Graphic Text Special Effects - legt Spezialeffekte
               fÅr Textausgaben fest.

Definition     int vst_effects ( int \#handle\#, int effect );

Beschreibung   Die Funktion legt die Textgestalt fÅr das AusgabegerÑt
               mit der Kennung \#handle\# fest.
effect         Bitvektor, der die Textgestalt festlegt. Um einen
               Effekt zu selektieren, muû das entsprechende Bit
               gesetzt werden. Dadurch sind beliebige Kombinationen
               mîglich.
Bit            0      1      2        3               4     5
Effekt         fett   hell   kursiv   unterstrichen   hohl  schattiert
Ergebnis       Die Funkltion liefert das Bitmuster der tatsÑchlich
               eingestellten Effekte.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( capsensitive("vst_alignment") )
Name           Set Graphic Text Alignment - bestimmt die Ausrichtung
               fÅr Textausgaben.

Definition     void vst_alignment ( int \#handle\#, int hor_in,
                                    int vert_in, int *hor_out,
                                    int *vert_out );

Beschreibung   Mit dieser Funktion wird die Ausrichtung von Grafiktext
               in den Textausgabefunktionen fÅr das GerÑt mit der
               Kennung \#handle\# festgelegt.
hor_in      0  LinksbÅndig (das ist auch der Default-Wert)
            1  Zentriert
            2  RechtsbÅndig
vert_in     0  Basislinie (das ist auch der Default-Wert)
            1  Kleinbuchstabenhîhe
            2  Zeichenoberkante
            3  Zellenunterkante
            4  Zeichenunterkante
            5  Zeichenzellenoberkante
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( capsensitive("vsf_interior") )
Name           Set Fill Interior Style - bestimmt den FÅllmustertyp.

Definition     int vsf_interior( int \#handle\#, int style );

Beschreibung   Die Funktion wÑhlt fÅr das GerÑt \#handle\# den
               FÅllmustertyp aus.
type       0   FIS_HOLLOW     leer
           1   FIS_SOLID      deckend
           2   FIS_PATTERN    gemustert
           3   FIS_HATCH      schraffiert
           4   FIS_USER       frei definierbar
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#      \#vsf_style\#       \#vsf_udpat\#
\end

screen( capsensitive("vsf_style") )
Name           Set Fill Style Index - bestimmt das FÅllmuster.

Definition     int vsf_style ( int \#handle\#, int style_index );

Beschreibung   Die Funktion wÑhlt fÅr ein AusgabegerÑt \#handle\# den
               Musterindex style_index aus. Eine öbersicht Åber die
               FÅllmuster findet sich im Handbuch.
Ergebnis       Die Funktion liefert das tatsÑchlich eingestellte
               FÅllmuster.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#      \#vsf_interior\#
\end

screen( capsensitive("vsf_color") )
Name           Set Fill Color Index - bestimmt die Farbe mit der ein
               Polygon ausgefÅllt wird.

Definition     int vsf_color ( int \#handle\#, int color_index );

Beschreibung   Die Funktion setzt fÅr das GerÑt mit der Kennung \#handle\#
               die FÅllfarbe auf den Wert color_index.
Ergebnis       Die Funktion liefert die tatsÑchlich eingestellte
               Farbe.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#
\end

screen( capsensitive("vsf_perimeter") )
Name           Set Fill Perimeter Visibility - bestimmt, ob eine
               Umrandung um FÅllbereiche gezeichnet wird.

Definition     int vsf_perimeter( int \#handle\#, int per_vis );

Beschreibung   Die Funktion bestimmt, ob bei einer FÅlloperation auf
               dem GerÑt mit der Kennung \#handle\# eine Umrahmung
               gezeichnet wird oder nicht. Falls per_vis gleich Null
               ist, wird keine Umrahmung gezeichnet, sonst schon.
Ergebnis       Die Funktion liefert den tatsÑchlich eingestellten
               Modus.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#
\end

screen( capsensitive("vsf_udpat") )
Name           Set User Defined Fill Pattern - definiert ein neues
               FÅllmuster.

Definition     void vsf_udpat ( int \#handle\#, int *pfill_pat,
                                int planes );

Beschreibung   Die Funktion definiert das frei definierbare
               FÅllmuster mit der Nummer vier aus \#vsf_interior\# fÅr
               das GerÑt mit der Kennung \#handle\#.
planes         Anzahl der Farbebenen
pfill_pat      Zeiger auf ein Feld mit planes Zeilen zu je
               16 EintrÑgen. Dabei gibt jede Zeile das
               FÅllmuster fÅr eine Farbebene wieder. Der
               erste Eintrag in einer Zeile entspricht dabei
               der ersten Zeile des Musters usw.
Gruppe         \#Attributfunktionen\#
Querverweis    \#vsf_interior\#
\end

screen( capsensitive("vro_cpyfm") )
Name           Copy Raster, Opaque - kopiert einen Speicherbereich.

Definition     void vro_cpyfm( int \#handle\#, int vr_mode,
                               int *\#pxyarray\#, \#MFDB\# *psrcMFDB,
                               \#MFDB\# *pdesMFDB);

Beschreibung   Die Funktion kopiert einen Quellspeicherbereich an ein
               Ziel und verknÅpft dabei die Quelle und das Ziel durch
               die in vr_mode decodierte logische VerknÅpfung.

psrcMFDB       Zeiger auf den MFDB der Quelle
pdesMFDB       Zeiger auf den MFDB des Ziels
vr_mode        eine von 16 logischen VerknÅpfungen zwischen
               den Pixeln des Quell- und Zielraster
ALL_WHITE      0     D := 0
S_AND_D        1     D := S AND D
S_AND_NOTD     2     D := S AND (NOT D)
S_ONLY         3     D := S
NOTS_AND_D     4     D := (NOT S) AND D
D_ONLY         5     D := D
S_XOR_D        6     D := S XOR D
S_OR_D         7     D := S OR D
NOT_SORD       8     D := NOT (S OR D)
NOT_SXORD      9     D := NOT (S XOR D)
D_INVERT       10    D := NOT D
NOT_D          11    D := S OR (NOT D)
S_OR_NOTD      12    D := NOT S
NOTS_OR_D      13    D := (NOT S) OR D
NOT_SANDD      14    D := NOT (S AND D)
ALL_BLACK      15    D := 1

pxyarray[0]    x-Koordinate eines Eckpunktes des Quellrasters
pxyarray[1]    y-Koordinate eines Eckpunktes des Quellrasters
pxyarray[2]    x-Koordinate des diagonal gegenÅberliegenden
               Eckpunktes des Quellrasters
pxyarray[3]    y-Koordinate des diagonal gegenÅberliegenden
               Eckpunktes des Quellrasters
pxyarray[4]    x-Koordinate eines Eckpunktes des Zielrasters
pxyarray[5]    y-Koordinate eines Eckpunktes des Zielrasters
pxyarray[6]    x-Koordinate des diagonal gegenÅberliegenden
               Eckpunktes des Zielrasters
pxyarray[7]    y-Koordinate des diagonal gegenÅberliegenden
               Eckpunktes des Zielrasters
Gruppe         \#Rasterfunktionen\#
Querverweis    \#pxyarray\#   \#MFDB\#
\end

screen( capsensitive("vrt_cpyfm") )
Name           Copy Raster, Transparent - kopiert ein Monochromraster
               auf ein Farbraster.

Definition     void vrt_cpyfm( int \#handle\#, int vr_mode, int *\#pxyarray\#,
                               \#MFDB\# *psrcMFDB, \#MFDB\# *pdesMFDB,
                               int *color_index );

Beschreibung   Die Funktion ist Ñhnlich der Funktion \#vro_cpyfm\#, nur
               daû hier ausgehend von einem Monochromraster auf ein
               Farbraster kopiert wird.
               Auch stehen fÅr vr_mode weniger VerknÅpfungen zur
               VerfÅgung, nÑmlich nur diejenigen, die man mit
               \#vswr_mode\# setzen kann.

psrcMFDB       Zeiger auf den MFDB der Quelle
pdesMFDB       Zeiger auf den MFDB des Ziels
color_index[0] Farbnummer der Farbe, die als gesetzt
               interpretiert werden soll
color_index[1] Farbnummer der Farbe, die als nicht
               gesetzt interpretiert werden soll
pxyarray       siehe \#vro_cpyfm\#
vr_mode        siehe \#vswr_mode\#
Gruppe         \#Rasterfunktionen\#
Querverweis    \#pxyarray\#   \#MFDB\#   \#vswr_mode\#   \#vro_cpyfm\#
\end

screen( capsensitive("vr_trnfm") )
Name           Transform Form - wandelt ein Rasterbild um.

Definition     void vr_trnfm( int \#handle\#, \#MFDB\# *psrcMFDB,
                              \#MFDB\# *pdesMFDB );

Beschreibung   Die Funktion konvertiert ein Standardraster, auf dessen
               \#MFDB\# psrcMFDB zeigt, in ein gerÑtespezifisches Raster,
               auf dessen \#MFDB\# pdesMFDB zeigt, oder umgekehrt.
Gruppe         \#Rasterfunktionen\#
Querverweis    \#MFDB\#
\end

screen( capsensitive("v_get_pixel") )
Name           Get Pixel - liefert den Farbwert eines Pixels.

Definition     void v_get_pixel( int \#handle\#, int x, int y, int *pel,
                                 int *index );

Beschreibung   Die Funktion ermittelt, ob ein Pixel x, y auf dem
               AusgabegerÑt \#handle\# gesetzt ist oder nicht und den
               zugehîrigen Farbwert des Pixels.
pel         0  Pixel nicht gesetzt
            1  Pixell gesetzt
index          Farbnummer
Gruppe         \#Rasterfunktionen\#
\end

screen( capsensitive("vsin_mode") )
Name           Set Input Mode - setzt den Eingabemodus

Definition     void vsin_mode( int handle, int dev_type, int mode );

Beschreibung   Die Funktion setzt den Eingabemodus aller Eingaben auf
               dem EingabegerÑt \#handle\# auf Sample (öberprÅfung des
               Zustands und gegebenenfalls der Position) oder Request
               (das GerÑt wartet auf eine Eingabe).
dev_type       Art des EingabegerÑts
            1  EingabegerÑt zur Positionseingabe (Maus)
            2  wertÑndernde Eingabeeinheiten (Cursor)
            3  auswÑhlende Einheiten (Funktionstasten)
            4  alphanumerische EingabegerÑte (Tastatur)
mode           gewÅnschter Modus
            1  Request
            2  Sample
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vrq_locator") )
Name           Input Locator, Request Mode - ermittel die Mausposition,
               wenn eine Taste gedrÅckt wurde.

Definition     void vrq_locator( int \#handle\#, int x, int y, int *xout,
                                 int *yout, int *term );

Beschreibung   Die Funktion stellt den Grafikcursor an der Position x,
               y dar und wartet auf einen Tastendruck. Nach der
               RÅckkehr der Funktion hat man die neue Position des
               Cursors in xout, yout und im Lowbyte von term den ASCII
               Code der gedrÅckten Taste.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vsm_locator") )
Name           Input Locator, Sample Mode - bestimmt die Position des
               Grafikcursors.

Definition     int vsm_locator( int \#handle\#, int x, int y, int *xout,
                                int *yout, int *term );

Beschreibung   Die Funktion bestimmt die neue Position des
               Grafikcursors ohne ihn auf dem GerÑt \#handle\#
               darzustellen. Aus den alten Koordinaten x, y werden
               die neuen Koordinaten xout, yout berechnet. In term
               erhÑlt man die gedrÅckte Taste.
Ergebnis       Die Funktion liefert kodiert Informationen darÅber, ob
               sich die Position verÑndert hat (Bit 0 gesetzt) und
               ob eine Taste gedrÅckt wurde (Bit 1 gesetzt).
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vrq_valuator") )
Name           Input Valuator, Request Mode - stellt WertverÑnderungen
               im REQUEST-Modus fest.

Definition     void vrq_valuator( int \#handle\#, int valuator_in,
                                 int *valuator_out, int *terminator );

Beschreibung   Die Funktion ermittelt fÅr das EingabegerÑt eine
               WertverÑnderung, die sich aus entsprechenden
               TastenbetÑtigungen ergibt. Typische Werte sind +10 fÅr
               die CursoraufwÑrtstaste, -10 fÅr die CursorabwÑrtstaste,
               die zum Parameter valuator_in addiert werden und nach
               dem Aufruf in valuator_out stehen.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vsm_valuator") )
Name           Input Valuator, Sample Mode - stellt WertverÑnderungen
               im SAMPLE-Modus fest.

Definition     void vsm_valuator( int \#handle\#, int val_in,
                                  int *val_out, int *term,
                                  int *status );

Beschreibung   éhnlich der Funktion \#vrq_valuator\# ermittelt die
               Funktion WertverÑnderungen hervorgerufen durch
               TastenbetÑtigung spezieller "Werttasten".

val_in         zu verÑndernder Wert
val_out        entsprechend der betÑtigten Taste verÑnderter
               Wert von val_in
term           ASCII-Code der gedrÅckten Taste
status      0  keine VerÑnderung
            1  Wert verÑndert
            2  Taste betÑtigt
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vrq_valuator\#
\end

screen( capsensitive("vrq_choice") )
Name           Input Choise, Request Mode - liefert den Status der
               Funktionstasten, wenn eine gedrÅckt wurde.

Definition     void vrq_choice( int \#handle\#, int ch_in, int *ch_out );

Beschreibung   Die Funktion wartet darauf, daû eine Auswahltaste
               (Funktionstaste) auf dem EingabegerÑt \#handle\# betÑtigt
               wird. Wird eine andere Taste betÑtigt, so wird der Wert
               ch_in zurÅckgeliefert.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vsm_choice\#
\end

screen( capsensitive("vsm_choice") )
Name           Input Choise, Sample Mode - ermittelt welche
               Funktionstaste zuletzt gedrÅckt wurde.

Definition     int vsm_choice( int \#handle\#, int *choice );

Beschreibung   Die Funktion ÅberprÅft den Zustand der Auswahltasten
               (Funktionstasten) und schreibt den Code in choice.
Ergebnis       Die Funktion liefert eine Eins, falls eine Auswahltaste
               betÑtigt wurde, sonst eine Null.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vrq_choice\#
\end

screen( capsensitive("vrq_string") )
Name           Input String, Request Mode - liest einen String im
               REQUEST-Modus ein.

Definition     void vrq_string( int \#handle\#, int max_length,
                                int echo_mode, int *echo_xy,
                                char *string );

Beschreibung   Die Funktion gestattet die Eingabe von Grafiktext der
               maximalen LÑnge max_length auf dem EingabegerÑt \#handle\#.
               Falls echo_mode gleich Eins ist, wird der eingegebene
               Text auf dem EingabegerÑt unter Beachtung der
               \#Textattribute\# an den Koordinaten echo_xy[0], echo_xy[1]
               dargestellt. Die Funktion wird entweder durch das
               BetÑtigen von RETURN oder bei öberschreittung von
               max_len Eingabezeichen beendet. Der eingegebene Text
               steht in string.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#       \#vst_alignment\#  \#vst_height\#
               \#vst_point\#   \#vst_rotation\#   \#vst_font\#       \#vst_color\#
               \#vst_effects\# \#vsm_string\#
\end

screen( capsensitive("vsm_string") )
Name           Input String, Sample Mode - liest einen String im
               SAMPLE-Modus ein.

Definition     int vsm_string( int \#handle\#, int max_length,
                               int echo_mode, int *echo_xy,
                               char *string );

Beschreibung   Die Funktion gestattet die Eingabe von Grafiktext auf
               dem EingabegerÑt \#handle\#. Die Funktion wird beendet,
               falls die Anzahl der maximalen Eingabezeichen
               max_length Åberschritten wird, die RETURN-Taste
               betÑtigt wurde oder eine nicht zulÑssige Taste gedrÅckt
               wurde. Falls echo_mode Eins ist, wird die Eingabe unter
               Beachtung der \#Textattribute\# auf dem EingabegerÑt an den
               Koordinaten echo_xy[0], echo_xy[1] dargestellt.
Ergebnis       Die Funktion liefert entweder die Anzahl der gelesen
               Zeichen oder Null, falls die Eingabe durch eine
               ungÅltige Taste  abgebrochen wurde. Der eingegebene
               Text steht in string.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vswr_mode\#    \#vs_color\#      \#vst_alignment\#   \#vst_height\#
               \#vst_point\#    \#vst_rotation\#  \#vst_font\#        \#vst_color\#
               \#vst_effects\#  \#vrq_string\#
\end

screen( capsensitive("vsc_form") )
Name           Set Mouse Form - setzt die Mauszeigerform.

Definition     void vsc_form( int \#handle\#, int *pcur_form );

Beschreibung   Die Funktion setzt auf dem GerÑt \#handle\# eine neue
               Mauszeigerform. Die Information Åber das Aussehen des
               Mauszeigers steht dabei in der Datenstruktur, auf die
               pcur_form zeigt. Der Aufbau der Datenstruktur:

               pcur_form[0]      relative x-Koordinate des Hot-Spot
               pcur_form[1]      relative y-Koordinate des Hot-Spot
               pcur_form[2]      reserviert: 1
               pcur_form[3]      Farbindex der Hintergrundmaske
               pcur_form[4]      Farbindex der Vordergrundmaske
               pcur_form[5..20]  Hintergrundmaske
               pcur_form[21..36] Vordergrundmaske

Gruppe         \#Eingabefunktionen\#
Querverweis    \#graf_mouse\#
\end

screen( capsensitive("vex_timv") )
Name           Exchange Timer Interrupt Vector - stellt den
               Interruptvector fÅr den Zeitgeber um.

Definition     void vex_timv( int \#handle\#, int (*tim_addr)(),
                              int (**otim_addr)(), int *tim_conv );

Beschreibung   Die Funktion ermîglicht es, eine eigene Routine in den
               Timerinterrupt einzuhÑngen. Dabei ist tim_addr ein
               Zeiger auf die eigene Funktion, in otim_addr erhÑlt man
               die alte Adresse der Interruptroutine und in tim_conv
               die Anzahl der Millisekunden. Am Ende des Programms muû
               der alte Vektor wieder hergestellt werden.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("v_show_c") )
Name           Show Cursor - schaltet den Grafikcursor ein.

Definition     void v_show_c( int \#handle\#, int reset );

Beschreibung   Die Funktion zeigt auf dem GerÑt \#handle\# den
               Grafikcursor an, falls reset gleich Null ist bzw. hebt
               einen Aufruf der Funktion \#v_hide_c\# auf. Es ist also
               eine Verschachtelung der Aufrufe beider Funktionen
               mîglich.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#v_hide_c\#
\end

screen( capsensitive("v_hide_c") )
Name           Hide Cursor - schaltet den Grafikcursor aus.

Definition     void v_hide_c( int \#handle\# );

Beschreibung   Die Funktion schaltet den Grafikcursor auf dem GerÑt
               mit der Kennung \#handle\# aus.

Gruppe         \#Eingabefunktionen\#
Querverweis    \#v_show_c\#
\end

screen( capsensitive("vq_mouse") )
Name           Sample Mouse Button State - ermittelt Position und
               Status der Maustasten.

Definition     void vq_mouse( int \#handle\#, int *pstatus, int *x,
                              int *y );

Beschreibung   Die Funktion ÅberprÅft den Status der linken Maustaste
               und schreibt ihn in pstatus (0  Taste nicht gedrÅckt,
               1  Taste gedrÅckt).
               ZusÑtzlich erhÑlt man die Position des Mauszeigers in x
               und y.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vq_scan") )
Name           Inquire Printer Scan - Abfrage der Druckerparameter

Definition     void vq_scan( int \#handle\#, int *g_slice,
                             int *g_page, int *a_slice, int *a_page,
                             int *div_fac );

Beschreibung   Die Funktion frÑgt verschiedene druckerspezifische
               Paramater ab. Der Druckertreiber unterteilt eine
               Druckseite in mehrere "Scheiben" (slices), die
               nacheinander formatiert und gedruckt werden, um den
               Speicherplatzbedarf zu senken. Dabei ist g_slice die
               Anzahl dieser Scheiben und g_page die Pixelhîhe einer
               Scheibe. a_slice gibt die Hîhe einer Textzeile in Pixel
               und a_page die Anzahl Textzeilen pro Seite an.
               Durch div_fac mÅssen die anderen Werte ggf. noch
               geteilt werden.
Gruppe         \#Auskunftsfunktionen\#
\end

screen( capsensitive("v_alpha_text") )
Name           Output Alpha Text - Ausgabe von Text im Textmodus

Definition     void v_alpha_text( int \#handle\#, char *string);

Beschreibung   Die Funktion gibt Text im Textmodus aus. Grundlegende
               Steuerzeichen sind fÅr alle Druckertypen genormt:

               DC2 0:    Fett an
               DC2 1:    Fett aus
               DC2 2:    Kursiv an
               DC2 3:    Kursiv aus
               DC2 4:    Unterstrichen an
               DC2 5:    Unterstrichen aus

Gruppe         \#Ausgabefunktionen\#
\end

screen( capsensitive("vex_butv") )
Name           Exchange Button Change Vector - stellt den
               Interruptvektor fÅr einen Maustastendruck um.

Definition     void vex_butv( int \#handle\#, int (*pusrcode)(),
                              int (**psavcode)() );

Beschreibung   Die Funktion gestattet es, eine eigene Routine in den
               Maustastenvektor einzuhÑngen. Dazu Åbergibt man den
               Zeiger auf die eigene Routine in pusrcode und erhÑlt
               den alten Vektor in psavcode. Am Programmende muû der
               alte Vektor wiederhergestellt werden.

Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vex_motv") )
Name           Exchange Mouse Movement Vector - stellt den
               Interruptvektor fÅr Mausbewegungen um.

Definition     void vex_motv( int \#handle\#, int (*pusrcode)(),
                              int (**psavcode)() );

Beschreibung   Die Funktion ermîglicht es, eine eigene Routine in den
               Mousemovementvektor einzuhÑngen, d. h. bei jeder
               Mausbewgung wird dann die neue Routine aufgerufen.
               Dabei ist pusrcode der Zeiger auf die einzuhÑngende
               Routine und in psavecode erhÑlt man den alten Vektor,
               der am Programmende wiederhergestellt werden muû.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vex_curv") )
Name           Exchange Cursor Change Vector - stellt den
               Interruptvector fÅr Cursorbewegungen um.

Definition     void vex_curv( int \#handle\#, int (*pusrcode)(),
                              int (**psavcode)() );

Beschreibung   Die Funktion ermîglicht es, eine eigene Routine in den
               Cursorchangevektor einzuhÑngen. Dabei ist pusrcode ein
               Zeiger auf die einzuhÑngende Routine und in psavcode
               erhÑlt man den alten Vektor, den man am Programmende
               wiederherstellen muû.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vq_key_s") )
Name           Sample Keyboard State Information - ermittelt den
               Status der Kontrolltasten.

Definition     void vq_key_s( int \#handle\#, int *pstatus );

Beschreibung   Die Funktion ÅberprÅft die Tastatur und schreibt den
               Zustand der Sondertasten in pstatus. Das Format ist
               dabei das gleiche wie in ev_bkstate bei \#evnt_button\#.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#evnt_button\#
\end

screen( capsensitive("vq_extnd") )
Name           Extended Inquire Funktion - ermittelt Informationen
               Åber eine Arbeitsstation.

Definition     void vq_extnd( int \#handle\#, int owflag, int *work_out );

Beschreibung   Die Funktion erlaubt es, Åber ein GerÑt mit der Kennung
               \#handle\# einige AuskÅnfte, d. h. Angaben Åber die
               FÑhigkeiten des GerÑts, einzuholen. Ist owflag gleich
               Null, so erhÑlt man in \#work_out\# die gleichen Angaben,
               wie in \#v_opnwk\#, ist dagegen owflag gleich Eins, so
               erhÑlt man in \#work_out\# erweiterte AuskÅnfte.
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#v_contourfill\#   \#vswr_mode\#   \#v_pline\#   \#v_pmarker\#
               \#v_fillarea\#      \#v_opnwk\#
\end

screen( capsensitive("work_out") )
work_out[0]    genaue Spezifikation des Bildschirms
               0  kein Bildschirm
               1  getrennte Grafik/Textbildschirme mit getrennten
                  Kontrollern
               2  gemeinsame Grafik/Textbildschirme mit getrennten
                  Kontrollern
               3  getrennte Grafik/Textbildschirme mit gemeinsamen
                  Kontroller
               4  gemeinsamer Grafik/Textbildschirm mit gemeinsamen
                  Kontroller
work_out[1]    Anzahl der vom GerÑt unterstÅtzten Farben
work_out[2]    Anzahl der vom GerÑt unterstÅtzten Texteffekte
work_out[3]    Vergrîûerungsflag
               0  GerÑt unterstÅtzt vergrîûern nicht
               1  GerÑt unterstÅtzt vergrîûern
work_out[4]    Anzahl der Farbebenen
work_out[5]    falls Null, so unterstÅtzt das GerÑt einen
               "lookup-table", sonst nicht
work_out[6]    Anzahl der mîglichen 16x16 Rasteroperationen / Sekunde
work_out[7]    falls Eins, so unterstÅtzt das GerÑt die
               \#v_contourfill\# Funktion.
work_out[8]    Textrotationsflag
               0  nicht mîglich
               1  in 90 Grad Schritten mîglich
               2  kontinuierliche Drehung mîglich
work_out[9]    Anzahl der unterstÅtzten Schreibmodi ( \#vswr_mode\# )
work_out[10]   welche Eingabemodi stehen zur VerfÅgung
               0  keine
               1  Request Modus
               2  Sample Modus
work_out[11]   Textausrichtung wird
               0  nicht unterstÅtzt
               1  unterstÅtzt
work_out[12]   Farbstiftwechsel wird
               0  nicht unterstÅtzt
               1  unterstÅtzt
work_out[13]   Wechsel des Farbbandes wird am AusgabegerÑt
               0  nicht unterstÅtzt
               1  zeilenweise unterstÅtzt
               2  zeilen- und spaltenweise unterstÅtzt
work_out[14]   Hîchstzahl von Koordinatenpaare fÅr \#v_pline\#,
               \#v_pmarker\#, \#v_fillarea\#
work_out[15]   maximale Grîûe des int_in Feldes (-1 unbegenzt)
work_out[16]   Zahl der verfÅgbaren Maustasten
work_out[17]   verschiedene Linientypen werden fÅr breite Linien
               0  nicht unterstÅtzt
               1  unterstÅtzt
work_out[18]   Anzahl der verfÅgbaren Schreibmodi fÅr breite Linien
work_out[19]   0 (reserviert)
    :
work_out[56]
\end

screen( capsensitive("vq_color") )
Name           Inquire Color Representation - ermittelt die
               IntensitÑt einer Farbe.

Definition     void vq_color( int \#handle\#, int color_index,
                             int set_flag, int *rgb );

Beschreibung   Falls set_flag Null ist, so ermittelt die Funktion die
               vom Anwender gewÅnschte Farbe und und schreibt die
               Farbanteile der Grundfarben fÅr die Farbe color_index
               in das Feld rgb.
               Falls dagegen set_flag Eins ist, so ermittelt die
               Funktion die Farbe, die von der Workstation auch
               tatsÑchlich realisiert werden konnte.

rgb_in[0]      Rotanteil in Promille
rgb_in[1]      GrÅnanteil in Promille
rgb_in[2]      Blaunanteil in Promille

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vs_color\#
\end

screen( capsensitive("vql_attributes") )
Name           Inquire Current Polyline Attributes - ermittelt die
               Attribute fÅr das Zeichnen von Linien.

Definition     void vql_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten Attribute,
               die fÅr alle POLYLINE Operationen auf dem GerÑt \#handle\#
               gÅltig sind.

attrib[0]      aktueller Linientyp
attrib[1]      Linienfarbnummer
attrib[2]      Schreibmodus
attrib[3]      Darstellung des Linienanfangs
attrib[4]      Darstellung des Linienendes
attrib[5]      LinienstrichstÑrke

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#   \#vsl_ends\#
\end

screen( capsensitive("vqm_attributes") )
Name           Inquire Current Polymarker Attributes - ermittelt die
               Attribute fÅr das Zeichnen von Markierungen.

Definition     void vqm_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten
               Linienattribute, die fÅr alle POLYMARKER Operationen
               auf dem GerÑt \#handle\# gÅltig sind.

attrib[0]      aktueller Markertyp
attrib[1]      Markerfarbnummer
attrib[2]      Schreibmodus
attrib[3]      Breite des Markers
attrib[4]      Hîhe des Markers

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#  \#vs_color\#  \#vsm_type\#  \#vsm_height\#  \#vsm_color\#
\end

screen( capsensitive("vqf_attributes") )
Name           Inquire Current Fill Area Attributes - ermittelt die
               Attribute zum AusfÅllen von FlÑchen.

Definition     void vqf_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten
               FÅllattribute, die fÅr alle FILL Operationen auf
               dem GerÑt \#handle\# gÅltig sind.

attrib[0]      FÅllmuster
attrib[1]      FÅllfarbnummer
attrib[2]      FÅllmusterindex
attrib[3]      Schreibmodus
attrib[4]      Umrahmung zeichnen

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#      \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_perimeter\#
\end

screen( capsensitive("vqt_attributes") )
Name           Inquire Current Graphic Text Attributes - ermittelt die
               Attribute fÅr das Schreiben von Texten.

Definition     void vqt_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten
               \#Textattribute\#, die fÅr alle GRAPHICS TEXT
               Operationen auf dem GerÑt \#handle\# gÅltig sind.
attrib[0]      Zeichensatznummer
attrib[1]      Textfarbnummer
attrib[2]      Drehwinkel des Texts (in 1/10 Grad)
attrib[3]      horizontale Ausrichtung
attrib[4]      vertikale Ausrichtung
attrib[5]      Schreibmodus
attrib[6]      Breite eines Zeichens
attrib[7]      Hîhe eines Zeichens
attrib[8]      Zeichenzellenbreite
attrib[9]      Zeichenzellenhîhe
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#     \#vs_color\#   \#vst_height\#   \#vst_point\#
               \#vst_rotation\#  \#vst_font\#   \#vst_color\#    \#vst_effects\#
               \#vst_alignment\#
\end

screen( capsensitive("vqt_extent") )
Name           Inquire Text Extent - ermittelt die LÑnge eines Strings.

Definition     void vqt_extent( int \#handle\#, char *string,
                                int *extent );

Beschreibung   Die Funktion ermittelt fÅr die, in string stehende
               Zeichenkette, ein Rechteck, das den Text unter
               Beachtung aller gesetzten \#Textattribute\# auf dem GerÑt
               \#handle\# voll umgibt und schreibt die Koordinaten der
               Ecken dieses Rechtecks in extent.

                 extent[0]      x-Koordinate der unteren linken Ecke
                 extent[1]      y-Koordinate der unteren linken Ecke
                 extent[2]      x-Koordinate der unteren rechten Ecke
                 extent[3]      y-Koordinate der unteren rechten Ecke
                 extent[4]      x-Koordinate der oberen rechten Ecke
                 extent[5]      y-Koordinate der oberen rechten Ecke
                 extent[6]      x-Koordinate der oberen linken Ecke
                 extent[7]      y-Koordinate der oberen linken Ecke

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#vst_height\#   \#vst_point\#     \#vst_rotation\#
               \#vst_font\#     \#vst_effects\#
\end

screen( capsensitive("vqt_f_extent") )
Name           Inquire FSM Text Extent - ermittelt die LÑnge eines
               Strings im FSM-Zeichensatz.

Definition     void  vqt_f_extent( int \#handle\#, char *string,
                                     int *extent );

Beschreibung   Die Funktion ermittelt fÅr die, in string stehende
               Zeichenkette, ein Rechteck, das den Text unter
               Beachtung aller gesetzten \#Textattribute\# auf dem GerÑt
               \#handle\# und des aktuellen FSM-Zeichensatzes voll
               umgibt und schreibt die Koordinaten der Ecken dieses
               Rechtecks in extent.

                 extent[0]      x-Koordinate der unteren linken Ecke
                 extent[1]      y-Koordinate der unteren linken Ecke
                 extent[2]      x-Koordinate der unteren rechten Ecke
                 extent[3]      y-Koordinate der unteren rechten Ecke
                 extent[4]      x-Koordinate der oberen rechten Ecke
                 extent[5]      y-Koordinate der oberen rechten Ecke
                 extent[6]      x-Koordinate der oberen linken Ecke
                 extent[7]      y-Koordinate der oberen linken Ecke

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#FSMGDOS\#     \#vqt_extent\#
\end

screen( capsensitive("vqt_width") )
Name           Inquire Character Cell Width - ermittelt die Breite
               einer Zeichenzelle.

Definition     int vqt_width( int \#handle\#, char character,
                              int *cell_width, int *left_delta,
                              int *right_delta );

Beschreibung   Die Funktion ermittelt fÅr einen Buchstaben character
               auf dem GerÑt \#handle\# die Zeichenzellenbreite
               cell_width und die ZeichenzwischenrÑume left_delta und
               right_delta. Dabei werden die mit \#vst_effects\# gesetzten
               Textspezialeffekte nicht mit berÅcksichtigt.
Ergebnis       Die Funktion liefert  -1, falls die Ausmaûe aus irgend
               einem Grund nicht berechnet werden konnten.
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vst_effects\#
\end

screen( capsensitive("vqt_name") )
Name           Inquire Face Name and Index - ermittelt den Namen und
               Kurzbeschreibung eines Zeichensatzes.

Definition     int vqt_name( int \#handle\#, int element_num, char *name);

Beschreibung   Die Funktion ermittelt fÅr den Zeichensatz mit der
               Nummer element_num auf dem GerÑt \#handle\# den Namen des
               Zeichensatzes und schreibt ihn in name.

Ergebnis       Die Funktion liefert die Indexnummer des Zeichensatzes.
name[0]        Name des Zeichensatzes
  :
name[15]
name[16]       Kurzbeschreibung des Zeichesatzes
  :
name[31]
name[32]       Flag fÅr \link("FSM")FSM-Font\#

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vst_load_fonts\# \#vst_font\#
\end

screen( capsensitive("vq_cellarray") )
Name           Inquire Cell Array - ermittelt Informationen Åber eine
               dargestellte Farbtabelle.

Definition     void vq_cellarray( int \#handle\#, int *\#pxyarray\#,
                                  int row_length, int num_rows,
                                  int *el_used, int *rows_used,
                                  int *status, int *colarray );

Beschreibung   Die Funktion ermittelt auf dem GerÑt \#handle\# die
               derzeitigen Attribute eines eventuell vorhanden
               CELL ARRAY.
\#pxyarray\#       Begrenzungsrechteck
row_length     Anzahl der Spalten
num_rows       Anzahl der Zeilen
el_used        Anzahl benutzter Zellen in einer Reihe
rows_used      Anzahl benutzter Zeilen
status         0   alles hat ohne Fehler geklappt
               >0  eine Farbe konnte nicht gefunden werden
colarray       Farbindexarray
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#v_cellarray\#
\end

screen( capsensitive("vqin_mode") )
Name           Inquire Input Mode - ermittelt den Eingabemodus.

Definition     void vqin_mode( int \#handle\#, int dew_type,
                               int *input_mode );

Beschreibung   Die Funktion ermittelt den fÅr das GerÑt \#handle\#
               gÅltigen Eingabemodus.
dew_type       Art des EingabegerÑts
            1  EingabegerÑt zur Positionseingabe (Maus)
            2  wertÑndernde Eingabeeinheiten (Cursor)
            3  auswÑhlende Einheiten (Funktionstasten)
            4  alphanumerische EingabegerÑte (Tastatur)
input_mode     eingestellter Modus
            1  Request
            2  Sample
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vsin_mode\#      \#vrq_locator\#  \#vsm_locator\#   \#vrq_valuator\#
               \#vsm_valuator\#   \#vrq_choice\#   \#vsm_choice\#    \#vrq_string\#
               \#vsm_string\#
\end

screen( capsensitive("vqt_fontinfo") )
Name           Inquire Current Face Information - ermittelt
               Informationen Åber ZeichensÑtze.

Definition     void vqt_fontinfo( int \#handle\#, int *minADE,
                                  int *maxADE, int *distances,
                                  int *maxwidth, int *effects );

Beschreibung   Die Funktion gibt ausfÅhrliche Auskunft Åber den
               derzeit aktuellen Zeichensatz auf dem GerÑt \#handle\#.
minADE         Zeichennummer des ersten Zeichens im Zeichensatz
maxADE         Zeichennummer des letzten Zeichens im Zeichensatz
distances[0]   Abstand untere Kante der Zeichenzelle zur Basislinie
distances[1]   UnterlÑnge in Pixeln (Abstand Untergrenze Zeichen zur
               Basislinie)
distances[2]   Obergrenze der Kleinbuchstaben (Halblinie)
distances[3]   Abstand Obergrenze des Zeichens zur Basislinie
distances[4]   Abstand der oberen Kante der Zeichenzelle zur Basislinie
max_width      Zeichenzellenbreite des breitesten Zeichens ohne
               Beachtung von Spezialeffekten
effects[0]     Verbreiterung der Zeichen bei Spezialeffekten
effects[1]     linke Verbreiterung bei Kursivdarstellung
effects[2]     rechte Verbreiterung bei Kursivdarstellung
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vst_effects\#
\end

screen( capsensitive("vq_chcells") )
Name           Inquire Addressable Alpha Character Cells - ermittelt
               die Anzahl der Reihen und Spalten einer Arbeitsstation.

Definition     void vq_chcells( int \#handle\#, int *rows, int *columns );

Beschreibung   Die Funktion ermittelt die auf dem GerÑt \#handle\# mit dem
               Alphacursor ansprechbaren Zeilen rows und Spalten
               columns. Falls keine Adressierung mîglich ist, erhÑlt
               man -1 im entsprechenden Parameter.

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_exit_cur") )
Name           Exit Alpha Mode - schaltet den Textmodus ab.

Definition     void v_exit_cur( int \#handle\# );

Beschreibung   Die Funktion veranlaût das GerÑt mit der Kennung \#handle\#
               den alphanumerischen Darstellungsmodus zu Verlassen und
               wieder auf den Grafikbildschirm zu schalten.

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_enter_cur") )
Name           Enter Alpha Mode - schaltet den Textmodus ein.

Definition     void v_enter_cur( int \#handle\# );

Beschreibung   Die Funktion veranlaût das GerÑt mit der Kennung \#handle\#
               in den alphanumerischen Darstellungsmodus zu schalten
               und setzt den Textcursor in die linke obere Ecke.

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_exit_cur\#
\end

screen( capsensitive("v_curup") )
Name           Alpha Cursor up - bewegt den Alphacursor um eine Zeile
               nach oben.

Definition     void v_curup( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem GerÑt
               \#handle\# eine Zeile nach oben. Falls sich der Cursor
               bereits in der obersten Zeile befindet, so verÑndert
               sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curdown") )
Name           Alpha Cursor down - bewegt den Alphacursor um eine
               Zeile nach unten.

Definition     void v_curdown( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem GerÑt
               \#handle\# eine Zeile nach unten. Falls sich der Cursor
               bereits in der untersten Zeile befindet, so verÑndert
               sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curright") )
Name           Alpha Cursor right - bewegt den Alphacursor um ein
               Zeichen nach rechts.

Definition     void v_curright( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem GerÑt
               \#handle\# eine Spalte nach rechts. Falls sich der
               Cursor bereits in der rechtesten Spalte befindet, so
               verÑndert sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curleft") )
Name           Alpha Cursor left - bewegt den Alphacursor um ein
               Zeichen nach links.

Definition     void v_curleft( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem GerÑt
               \#handle\# eine Spalte nach links. Falls sich der Cursor
               bereits in der linksten Spalte befindet, so verÑndert
               sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curhome") )
Name           Home Alpha Cursor - bewegt den Alphcursor in die linke
               obere Ecke.

Definition     void v_curhome( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem GerÑt
               \#handle\# in die "Home"-Stellung (meist oben links).
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_eeos") )
Name           Erase to End of Alpha Screen - lîscht den Bildschirm ab
               dem Alphacursor.

Definition     void v_eeos( int \#handle\# );

Beschreibung   Die Funktion lîscht auf dem GerÑt mit der Kennung
               \#handle\# den alphanumerischen Bildschirm ab der
               aktuellen Alphacursorposition. Die Position des Cursors
               wird dabei nicht verÑndert.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_eeol") )
Name           Erase to End of Alpha Text Line - lîscht die Zeile ab
               dem Alphacursor.

Definition     void v_eeol( int \#handle\# );

Beschreibung   Die Funktion lîscht auf dem GerÑt mit der Kennung
               \#handle\# die Zeile des alphanumerischen Bildschirm ab
               der aktuellen Alphacursorposition. Die Position des
               Cursors bleibt dabei unverÑndert.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("vs_curaddress"),
		capsensitive("v_curaddress") )
Name           Direct Alpha Cursor Address - setzt den Alphacursor an
               die angegebene Position.

Definition     void v_curaddress( int \#handle\#, int row, int column );
               bzw.
               void vs_curaddress( int \#handle\#, int row, int column );

Beschreibung   Die Funktion setzt den Alphacursor auf dem GerÑt mit
               der Kennung \#handle\# in die Zeile row und die Spalte
               column.
Beschreibung   \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curtext") )
Name           Output Cursor Addressable Alpha Text - gibt einen Text
               ab dem Alphacursor aus.

Definition     void v_curtex( int \#handle\#, char *string );

Beschreibung   Die Funktion gibt den Text, auf den string zeigt, auf
               dem GerÑt mit der Kennung \#handle\# an der aktuellen
               Cursorposition aus.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#   \#v_enter_cur\#   \#v_curup\#     \#v_curdown\#
               \#v_curright\#    \#v_curleft\#     \#v_curhome\#   \#vs_curaddress\#
\end

screen( capsensitive("v_rvon") )
Name           Reverse Video on - schaltet den Invertiermodus ein.

Definition     void v_rvon( int \#handle\# );

Beschreibung   Die Funktion schaltet fÅr das GerÑt mit der Kennung
               \#handle\# in den Reversemodus, d. h. alle
               alphanumerischen Ausgaben werden invertiert.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#   \#v_rvoff\#
\end

screen( capsensitive("v_rvoff") )
Name           Reverse Video off - schaltet den Invertiermodus ab.

Definition     void v_rvoff( int \#handle\# );

Beschreibung   Die Funktion schaltet fÅr das GerÑt mit der Kennung
               \#handle\# den Reversemodus wieder ab, d. h. alle
               alphanumerischen Ausgaben werden wieder normal
               dargestellt.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#   \#v_rvon\#
\end

screen( capsensitive("vq_curaddress") )
Name           Inquire Current Alpha Cursor Address - ermittelt die
               aktuelle Alphacursorposition.

Definition     void vq_curaddress( int \#handle\#, int *row, int *column);

Beschreibung   Die Funktion ermittelt die aktuelle Position des
               Alphacursors auf dem GerÑt \#handle\# und schreibt sie
               in row (Zeile) und column (Spalte).

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("vq_tabstatus") )
Name           Inquire Tablet Status - ermittelt die VerfÅgbarkeit
               einer Eingabeeinheit.

Definition     int vq_tabstatus( int \#handle\# );

Beschreibung   Die Funktion ermittelt fÅr das GerÑt mit der Kennung
               \#handle\#, ob ein Grafiktablet, eine Maus, ein Joystick
               oder ein Ñhnliches Eingabeeinheit verfÅgbar ist. Ist
               ein solche Eingabeeinheit verfÅgbar, so liefert die
               Funktion einen RÅckgabewert von Eins, sonst liefert
               sie Null.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_hardcopy") )
Name           Hardcopy - fÅhrt eine Hardcopy des Bildschirms durch.

Definition     void v_hardcopy( int \#handle\# );

Beschreibung   Die Funktion erstellt auf dem GerÑt mit der Kennung
               \#handle\# eine Hardcopy des Bildschirminhalts.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_dspcur") )
Name           Place Graphic Cursor at Location - positioniert den
               Grafikcursor an die angegebene Position.

Definition     void v_dspcur( int \#handle\#, int x, int y );

Beschreibung   Die Funktion plaziert den Grafikcursor an den
               Koordinaten x, y auf dem GerÑt \#handle\#.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_rmcur") )
Name           Remove last Graphic Cursor - entfernt den Grafikcursor.

Definition     void v_rmcur( int \#handle\# );

Beschreibung   Die Funktion entfernt den Grafikcursor vom
               GerÑt \#handle\#.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_form_adv") )
Name           Form Advance - erzeugt einen Seitenvorschub.

Definition     void v_form_adv( int \#handle\# );

Beschreibung   Die Funktion erzeugt auf dem GerÑt mit der Kennung
               \#handle\# einen Seitenvorschub und der Inhalt des
               Datenpuffers bleibt abei erhalten.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_clrwk\#
\end

screen( capsensitive("v_output_window") )
Name           Output Window - gibt den Fensterinhalt auf dem
               Drucker aus.

Definition     void v_output_window( int \#handle\#, int *xyarray );

Beschreibung   Die Funktion gibt den Inhalt des durch xyarray
               festgelegten Fensters der Arbeitsstation mit der
               Kennung \#handle\# auf dem Drucker aus.

               falls Normalkoordinaten (NDC) verwendet werden:
xyarray[0]     x-Koordinate der linken unteren Ecke
xyarray[1]     y-Koordinate der linken unteren Ecke
xyarray[2]     x-Koordinate der rechten oberen Ecke
xyarray[3]     y-Koordinate der rechten oberen Ecke

               falls Rasterkoordinaten (RC) verwendet werden:
xyarray[0]     x-Koordinate der linken oberen Ecke
xyarray[1]     y-Koordinate der linken oberen Ecke
xyarray[2]     x-Koordinate der rechten unteren Ecke
xyarray[3]     y-Koordinate der rechten unteren Ecke
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_updwk\#
\end

screen( capsensitive("v_clear_disp_list") )
Name           Clear Display List - lîscht die Druckerpufferliste.

Definition     void v_clear_disp_list( int \#handle\# );

Beschreibung   Die Funktion lîscht die Druckerpufferliste eines
               angeschlossenen Druckers Ñhnlich der Funktion \#v_clrwk\#.
               Es wird jedoch im Unterschied dazu kein Seitenvorschub
               erzeugt. Die Funktion sollte nur mit \#GDOS\# verwendet
               werden.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#v_clrwk\#
\end

screen( capsensitive("v_bit_image") )
Name           Output Bit Image File - gibt ein Bitimagefile auf
               dem Drucker aus.

Definition     void v_bit_image( int handle, const char *filename,
                                 int aspect, int x_scale, int y_scale,
                                 int h_align, int v_align,
                                 int *xyarray );

Beschreibung   Die Funktion liest ein Bit-Image-File mit dem Pfadnamen
               filename und gibt den Bildinhalt auf dem Drucker \#handle\#
               aus. Wichtig ist, daû die Funktion nur bei residenten
               \#GDOS\# richtig arbeitet.

aspect         gibt an, wie der Abbildungsmaûstab interpretiert
               werden soll:
            0  ignorieren
            1  Pixel berÅcksichtigen (das VerhÑltnis Breite/Hîhe
               bleibt konstant)
            2  Seite berÅcksichtigen (rechnet eventuell verschiedene
               Seitengrîûen ineinander um)
x_scale        Skalierung der X-Achse
y_scale        Skalierung der Y-Achse
               bei öbergabe von Koordinaten wird nîtigenfalls der
               Maûstab verÑndert.
            0  gebrochen, beachtet den Abbildungsmaûstab aspect
            1  ganzzahlig, nutzt das angegebene Rechteck in xyarray
               voll aus unter VerÑnderung des angegeben Maûstabs
h_align        Horizontale Ausrichtung
            0  linksbÅndig
            1  zentriert
            2  rechtsbÅndig
v_align        Vertikale Ausrichtung
            0  obenbÅndig
            1  zentriert
            2  untenbÅndig
xyarray[0]     x-Koordinate der linken oberen Ecke des Ausgabefensters
xyarray[1]     y-Koordinate der linken oberen Ecke des Ausgabefensters
xyarray[2]     x-Koordinate der rechten unteren Ecke des
               Ausgabefensters
xyarray[3]     y-Koordinate der rechten unteren Ecke des
               Ausgabefensters
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("vs_palette") )
Name           Select Palette - wÑhlt eine Farbpalette aus.

Definition     void vs_palette( int \#handle\#, int palette );

Beschreibung   Die Funktion wÑhlt eine Farbpalette fÅr das GerÑt
               \#handle\# aus.

palette     0  Rot, GrÅn, Braun
            1  Cyan, Magenta, Weiû
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("vqp_films") )
Name           Inquire Palette Film Types - ermittelt Informationen
               Åber einen Film.

Definition     void vqp_films( int \#handle\#, char *film_names );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder. FÅr dieses AusgabegerÑt
               ermittelt die Funktion dann die Namen, den Hersteller
               und die Empfindlichkeit in ASA der zur VerfÅgung
               stehenden Filme.

film_names     Zeiger auf einen 126 Byte groûen Zeichenbuffer in den 5
               EintrÑge zu je 25 Zeichen gemacht werden.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("vqp_state") )
Name           Inquire Palette Driver State - ermittelt den
               GerÑtezustand des Polaroidbildrecorders.

Definition     void vqp_state( int \#handle\#, int *port, char *film_name,
                               int *lightness, int *interlace,
                               int *planes, int *indexes );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum
               anderen einen Polaroidbildrecorder und ermittelt dann
               fÅr dieses AusgabegerÑt den GerÑtezustand.

port           Nummer des Ports (0  erster Port)
film_name      Nummer des Filmnamen (0 bis 4)
lightness      Helligkeit (-3 bis 3, wobei eine Stufe einer Drittel
               Blende entspricht)
interlace      Bild wird mit (1) oder ohne (0) Zeilensprung abgetastet
planes         Farbanzahl =  2^planes, wobei planes zwischen
               1 und 4 liegt
indexes        Festlegung der Farben der Farbpalette. Es wird ein
               Speicherplatz von 16 Bytes benîtigt. Jede Farbe wird
               durch eine Zahl (fÅr die Zeilen der Farbmatrix) und
               einen Buchstaben von A bis H (fÅr die Spalten der
               Farbmatrix) gekennzeichnet.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#  \#vsp_state\#  \#vsp_save\#  \#vsp_message\#  \#vqp_films\#
\end

screen( capsensitive("vsp_state") )
Name           Set Palette Driver State - setzt den Ausgabezustand
               des Polaroidrecorders.

Definition     void vsp_state( int \#handle\#, int port, int film_num,
                               int lightness, int interlace,
                               int planes, int *indexes );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und wÑhlt dann fÅr dieses
               GerÑt einen Ausgabezustand.

port           Nummer des Ports (0  erster Port)
film_name      Nummer des Filmnamen (0 bis 4)
lightness      Helligkeit (-3 bis 3, wobei eine Stufe einer Drittel
               Blende entspricht)
interlace      Bild wird mit (1) oder ohne (0) Zeilensprung abgetastet
planes         Farbanzahl =  2^planes, wobei planes zwischen
               1 und 4 liegt
indexes        Festlegung der Farben der Farbpalette. Es wird ein
               Speicherplatz von 16 Bytes benîtigt. Jede Farbe wird
               durch eine Zahl (fÅr die Zeilen der Farbmatrix) und
               einen Buchstaben von A bis H (fÅr die Spalten der
               Farbmatrix) gekennzeichnet.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#         \#vsc_expose\#   \#vqp_state\#  \#vsp_save\#
               \#vsp_message\#  \#vqp_films\#
\end

screen( capsensitive("vsp_save") )
Name           Save Palette Driver State - speichert den GerÑtestatus
               des Polaroidbildrecorders.

Definition     void vsp_save( int \#handle\# );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und speichert fÅr dieses
               GerÑt den GerÑtestatus auf Diskette.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#       \#vqp_state\#   \#vsp_state\#   \#vsp_message\#
               \#vqp_films\#  \#vsc_expose\#
\end

screen( capsensitive("vsc_expose") )
Name           Disable or Enable Film Exposure for Frame Preview -
               Ein-/Ausschalten des Previews einer Kamera.

Definition     void vsc_expose( int \#handle\#, int state );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und schaltet den Preview-
               Modus, d.h. die Belichtung, einer Kamera ein bzw. aus,
               sofern diese das gestattet.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#         \#vsp_save\#   \#vqp_state\#   \#vsp_state\#
               \#vsp_message\#  \#vqp_films\#
\end

screen( capsensitive("vsp_message") )
Name           Suppress Palette Message - unterdrÅckt Fehlermeldungen
               des Polaroidbildrecorders.

Definition     void vsp_message( int \#handle\# );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und verhindert dann, daû
               der Recorder Fehlermelungen abschickt.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#vqp_error\#
\end

screen( capsensitive("vqp_error") )
Name           Palette Error Inquire - liefert die Nummer eines
               augetretenen Fehlers.

Definition     int vqp_error( int \#handle\# );

Beschreibung   Die Funktion benîtigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und liefert als
               Funktionsergebnis die Nummer des aufgetretenen Fehlers.
Ergebnis       Die Funktion liefert:
           0   kein Fehler
           1   Verschluû offen
           2   kein Port ausgewÑhlt
           3   Palette am gewÑhlten Port nicht verfÅgbar
           4   Verbindung unterbrochen
           5   Operationssystem erlaubt keine Speicherzuteilung
           6   Pufferspeicher reicht nicht aus
           7   Speicher nicht frei
           8   GerÑtetreiber-File fehlt
           9   GerÑtetreiber-File hat falsches Format
           10  Film zu Ende
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("v_meta_extents") )
Name           Update Metafile Extents - aktualisiert das Metafile.

Definition     void v_meta_extents( int \#handle\#, int min_x, int min_y,
                                    int max_x, int max_y );

Beschreibung   Die Funktion setzt die minimalen bzw. maximalen Werte
               fÅr eine, Zeichnung, die im Metafile gespeichert wird,
               auf die Werte min_x, min_y und max_x, max_y. Wichtig
               ist, daû die Funktion nur zusammen mit \#GDOS\# richtig
               arbeitet.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#vm_filename\#   \#v_write_meta\#
\end

screen( capsensitive("v_write_meta") )
Name           Write Metafile Item - schreibt ein Objekt ein ein
               Metafile.

Definition     void v_write_meta( int \#handle\#, int num_intin,
                                  int num_ptsin, int *intin,
                                  int *ptsin );

Beschreibung   Die Funktion schreibt ein benutzterdefiniertes Objekt
               in ein Metafile. Dabei erhÑlt jedes zu speichernde
               Objekt einen vom Benutzter festgelegten Opcode, der
               grîûer oder gleich 101 sein muû. Wichtig ist, daû die
               Funktion nur mit residentem \#GDOS\# korrekt arbeitet.
num_intin      Anzahl der EintrÑge im intin Feld
num_ptsin      Anzahl der EintrÑge im ptsin Feld
intin[0]       benutzterdefinierter Opcode
intin[1]       benutzterdefinierte Information
  :
intin[num_intin - 1]
ptsin[0]       benutzterdefinierte Information
  :
ptsin[num_ptsin - 1]
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#v_meta_extents\#
\end

screen( capsensitive("vm_coords") )
Name           VDI meta file coordinates - Eigenes Koordinatensystem
               fÅr Metafiles.

Definition     void vm_coords( int \#handle\#, int llx, int lly,
                               int urx, int ury );

Prototyp in    vdi.h

Beschreibung   Die VDI-Routine vm_coords legt ein neues Koordinaten-
               sytem fÅr die Seite im Metafile fest, wobei llx
               und lly die linke untere Ecke und die Parameter
               urx und ury die rechte obere Ecke beschreiben.
Ergebnis       Die Funktion liefert kein Ergebnis
Querverweis    \#v_write_meta\#
\end

screen( capsensitive("vm_filename") )
Name           Change GEM VDI File Name - Ñndert den Namen eines
               Metafiles.

Definition     void vm_filename( int \#handle\#, const char *filename );

Prototyp in    vdi.h

Beschreibung   Die Funktion benennt ein mit \#v_opnwk\# geîffnetes
               Metafile, das standardmÑûig den Namen GEMFILE.GEM
               erhÑlt, in den durch filename spezifizierten Namen um.
               Wichtig ist, daû fÅr das korrekte Arbeiten der Funktion
               das \#GDOS\# resident sein muû.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#v_opnwk\#   \#v_meta_extents\#   \#v_write_meta\#
\end

screen( capsensitive("vm_pagesize") )
Name           VDI page size - legt die physikalische Seitengrî·e
               fÅr Metafiles fest.

Definition     void vm_pagesize( int \#handle\#, int pgwidth,
                                 int pgheight );

Prototyp in    vdi.h

Beschreibung   Die VDI-Routine vm_pagesize legt die physikalische
               Seitengrîûe fÅr ein Metafile fest, wobei pgwidth
               die Breite und pgheight die Hîhe der Seite fest-
               legen. Beide Parameter werden in Zehntelmillimeter
               angegeben.
Ergebnis       Die Funktion liefert kein Ergebnis
Querverweis    \#v_write_meta\#, \#Escapefunktionen\#
\end

screen( capsensitive("v_offset") )
Name           Set Line Offset - setzt den linken Rand.

Definition     void v_offset( int \#handle\#, int offset);

Beschreibung   Die Funktion setzt fÅr das GerÑt mit der Kennung
               \#handle\# den oberen Rand auf den Wert offset
               (in Rasterzeilen).
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_fontinit") )
Name           Init System Font - initialisiert einen Zeichensatz.

Definition     void v_fontinit( int \#handle\#, int fh_high, int fh_low);

Beschreibung   Die Funktion installiert den Zeichensatz, dessen
               Adresse durch fh_high und fh_low decodiert wird, als
               neuen Systemzeichensatz. Dabei ist zu beachten, daû der
               Zeichensatz eine feste Zeichenbreite von 8 Pixeln
               aufweist.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("vq_gdos") )
Name           Inquire GDOS - ermittelt ob GDOS installiert ist.

Definition     int vq_gdos( void );

Beschreibung   Die Funktion ermittelt, ob GDOS installiert ist.
Ergebnis       Die Funktion liefert den Funktionswert Null, falls
               das \#GDOS\# nicht resident ist, sonst liefert die
               Funktionen einen von Null verschiedenen RÅckgabewert.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#    \#vq_vgdos\#
\end

screen( capsensitive("vq_vgdos") )
Name           Inquire GDOS version - ermittelt welche GDOS Version
               installiert ist.

Definition     long  vq_vgdos( void );

Beschreibung   Die Funktion ermittelt, welche GDOS Version installiert
               ist.
Ergebnis       Die liefert die Versionsnummer der installierten GDOS
               Version oder -2 zurÅck. FÅr \#FSMGDOS\# ist dies die Nummer
               0x5F46534D und fÅr FONTGDOS 0x5F464E54. FÅr andere GDOS
               Treiber ergibt sich eine anderer Wert ungleich -2.

Gruppe         \#Escapefunktionen\#
Querverweis    \#FSMGDOS\#   \#GDOS\#    \#vq_gdos\#
\end

screen( capsensitive("v_escape2000") )
Name           Escape 2000 - Spezialfunktion fÅr ATARI-Page-Printer.

Definition     void v_escape2000( int handle, int times );

Beschreibung   Diese Spezialfunktion ist fÅr den ATARI-Page-Printer.
               Dieser druckt times Kopien der laufenden Seite
               aus.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("vt_resolution") )
Name           set tablet axis resolution in lines/inch - Auflîsung
               des Grafiktabletts einstellen in Zeilen pro Inch.

Definition     void vt_resolution( int handle, int xres, int yres, 
                                   int *xset, int *yset );

Beschreibung   Die Funktion setzt die horizontale und vertikale
               Auflîsung xres und yres des Grafiktablets.
               xset und yset enthalten nach dem Aufruf die alten
               Werte.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#     \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_axis\#  \#vt_origin\#     \#vq_tdimensions\#
\end

screen( capsensitive("vt_axis") )
Name           set tablet axis resolution in lines - Auflîsung
               des Grafiktabletts einstellen in Zeilen.

Definition     void    vt_axis( int handle, int xres, int yres, 
                                int *xset, int *yset );

Beschreibung   Die Funktion setzt die horizontale und vertikale
               Auflîsung xres und yres des Grafiktablets.
               xset und yset enthalten nach dem Aufruf die alten
               Werte.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_resolution\#  \#vt_origin\#     \#vq_tdimensions\#
\end

screen( capsensitive("vt_origin") )
Name           set tablet x and y origin - Koordinatenursprung
               fÅr Grafiktablett setzen.

Definition     void vt_origin( int handle, int xorigin,
                               int yorigin );

Beschreibung   Die Funktion setzt den Koordinatenursprung
               xorigin und yorigin des Grafiktabletts.
Ergebnis       Die Funktion hat kein Ergebnis.
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_resolution\#  \#vt_axis\#       \#vq_tdimensions\#
\end

screen( capsensitive("vq_tdimensions") )
Name           return tablet x and y dimensions - Ausmaûe des
               Grafiktabletts in 1/10-Zoll.

Definition     void vq_tdimensions( int handle, int *xdimension,
                                    int *ydimension );

Beschreibung   Die Funktion liefert die Ausmaûe des Grafik-
               tabletts in xdimension und ydimension in 1/10-Zoll.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_resolution\#  \#vt_axis\#       \#vt_origin\#
\end

screen( capsensitive("vt_alignment") )
Name           set tablet alignment - Koordinatensystem des Grafik-
               tabletts ausrichten.

Definition     void vt_alignment( int handle, int dx, int dy );

Beschreibung   Die Funktion dient der Ausrichtung des Koordinaten-
               systems innerhalb eines Ausschnitts des Grafik-
               tabletts.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vq_tdimensions\#
               \#vt_resolution\#  \#vt_axis\#       \#vt_origin\#
\end

screen( capsensitive("vsp_film") )
Name           set camera film type and exposure time - Filmtyp
               und Belichtungszeit festlegen.

Definition     void vsp_film( int handle, int index,
                              int lightness );

Beschreibung   Die Funktion legt Filmtyp und Belichtungszeit fest.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("v_sound") )
Name           generate specified tone - Ton generieren.

Definition     void v_sound( int handle, int frequency,
                              int duration );

Beschreibung   v_sound erzeugt einen Ton der Hîhe frequency Hertz
               und der Dauer duration in Timer-Ticks.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#    \#vs_mute\#
\end

screen( capsensitive("vs_mute") )
Name           set/clear tone muting flag - Ein-/Ausschalten der
               Tonerzeugung.

Definition     int  vs_mute( int handle, int action );

Beschreibung   vs_mute schaltet die Tonerzeugung ein (action == 1)
               bzw. aus (action == 0) und liefert deren Status
               zurÅck. FÅr action == -1 wird nur der Status abgefragt.
Ergebnis       Die Funktion liefert den Status der Tonerzeugung.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#    \#v_sound\#
\end

screen( capsensitive("vqt_advance") )
Name           Inquire FSM text advance placement vector - Position
               fÅr nÑchstes FSM-Zeichen ermitteln.

Definition     void  vqt_advance( int handle, int ch, int *advx,
                                   int *advy, int *remx, int *remy );

Beschreibung   vqt_advance liefert den x- und y-Offset in advx und
               advy, der benîtigt wird, um das nÑchste Zeichen ch
               eines Strings an die richtige Position zu schreiben.
               ZusÑtzlich liefern remx und remy die Restwerte fÅr
               modulo 16384 der x- und y-Offsets, so daû die Ausmaûe
               der Zeichenbox mit \#v_ftext\# und \#vqt_f_extent\# besser
               berechnet werden kînnen.
               Diese Funktion wird gebraucht, wenn der Winkel fÅr
               Textrotation ein anderer als 0, 90, 180 oder 270 Grad
               ist. 
Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#    \#vst_rotation\#
\end

screen( capsensitive("vst_arbpt") )
Name           Set character cell height by arbitrary points - Setzen
               der Zeichenzellenhîhe in Punkten.

Definition     int vst_arbpt( int handle, int point, int *chwd,
                               int *chht, int *cellwd, int *cellht );

Beschreibung   vst_arbpt setzt die aktuelle Zeichenhîhe in Printer-
               Punkten. Im Gegensatz zu vst_point erlaubt vst_arbpt
               die Skalierung in jeder Punktgrîûe, unabhÑngig davon,
               welche Angaben in EXTEND.SYS stehen. Diese Funktion
               arbeitet ausschlieûlich mit FSM-Outline-Fonts.

Ergebnis       Als Resultat erhÑlt man die gesetzte Zeichenhîhe
               in Punkten.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#        \#FSMGDOS\#
               \#vst_point\#   \#vst_setsize\#
\end

screen( capsensitive("vqt_devinfo") )
Name           Inquire device status info - Status des AusgabegerÑts
               erfragen.

Definition     void  vqt_devinfo( int handle, int devnum,
                                   int *devexits, char *devstr );

Beschreibung   vqt_devinfo prÅft, ob der ein Treiber fÅr das durch
               devnum spezifizierte GerÑt durch \#GDOS\# installiert
               wurde. In diesem Fall erhÑlt devexits den Wert 1,
               sonst Null. In den ausreichend groûen String devstr
               wird im Erfolgsfall der Name des Treibers kopiert.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
\end

screen( capsensitive("v_flushcache") )
Name           Flush FSM cache - FSM Cache lîschen.

Definition     int  v_flushcache( int handle );

Beschreibung   v_flushcache lîscht den Inhalt des FSM-Cache, der
               Bitmaps von FSM-Zeichen enthÑlt.

Ergebnis       Falls ein Fehler auftrat, erhÑlt man -1 als Resultat,
               sonst 0.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#         \#FSMGDOS\#
               \#v_loadcache\#  \#v_savecache\#   \#vqt_cachesize\#
\end

screen( capsensitive("vqt_cachesize") )
Name           Get FSM chache size - Ermitteln der Grîûe des FSM
               Caches.

Definition    void  vqt_cachesize( int handle, int which_cache,
                                    long *size );

Beschreibung   Als Resultat liefert vqt_cachesize im Parameter size
               die LÑnge des grîûten verfÅgbaren Blocks in den
               FSM-Caches. Man kann somit die maximale Grîûe der
               Zeichen abschÑtzen, die FSMGDOS ausgeben kann.
               Hat which_cache den Wert 0, so erhÑlt man die Grîûe
               des Bitmap-Cache, fÅr 1 die des Datenstruktur-Cache.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
               \#v_loadcache\#  \#v_savecache\#   \#v_flushcache\#
\end

screen( capsensitive("vqt_get_tables") )
Name           Get FSM gascii tables - Adresse der Zeichentrans-
               formationstabellen erfragen.

Definition     void  vqt_get_tables( int handle, int **gascii,
                                      int **style );

Beschreibung   Wenn Zeichen mittels \#v_gtext\# ausgegeben werden,
               werden sie in ein Wortformat Åbersetzt, das durch
               den Fontgenerator weiterverarbeitet werden kann.
               Die öbersetzungen sind in der gascii-Tabelle
               vorhanden. Sie enthÑlt 223 EintrÑge, beginnend mit
               dem ASCII-Zeichen 32. Die zweite Tabelle, style,
               gibt Auskunft darÅber aus welcher Font-Datei das
               Zeichen erzeugt wurde. Es gibt drei Mîglichkeiten:

                        0      Standardzeichensatz
                        1      Symbolzeichensatz
                        2      HebrÑischer Zeichensatz

               Diese Informationen sind nÅtzlich, da FSM-Fonts
               auch Zeichen enthalten, die im normalen Atari-
               Zeichensatz nicht enthalten sind.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#v_gtext\#
\end

screen( capsensitive("v_loadcache") )
Name           Load FSM cache - FSM-Cache laden.

Definition     int  v_loadcache( int handle, char *filename,
                                  int mode );

Beschreibung   v_loadcache lÑdt den Inhalt des FSM-Cache aus
               einer Datei mit dem Namen filename. mode gibt an,
               ob der alte Inhalt Åberschrieben werden soll (1)
               oder die geladenen Information an den alten Inhalt
               angehÑngt werden soll (0).

Ergebnis       Falls ein Fehler auftrat, erhÑlt man -1 als Resultat,
               sonst 0.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
               \#v_flushcache\#  \#v_savecache\#   \#vqt_cachesize\#
\end

screen( capsensitive("v_savecache") )
Name           Save FSM cache to disk - FSM-Cache speichern.

Definition     int  v_savecache( int handle, char *filename );

Beschreibung   v_savecache speichert den Inhalt des Cache unter dem
               Namen filename im aktuellen Verzeichnis.

Ergebnis       Falls ein Fehler auftrat, erhÑlt man -1 als Resultat,
               sonst 0.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
               \#v_flushcache\#  \#v_loadcache\#   \#vqt_cachesize\#
\end

screen( capsensitive("vst_setsize") )
Name           Set character cell width by arbitrary points - Setzen
               der Zeichenzellenbreiten in Punkten.

Definition     int  vst_setsize( int handle, int point,
                                  int *chwd, int *chht,
                                  int *cellwd, int *cellht );

Beschreibung   vst_setsize setzt die Zeichenbreite in Printer-
               Punkten. Zu beachten ist, daû der nÑchste Aufruf
               von vst_point, vst_arbpt oder vst_height die
               durch vst_setsize gesetzte Breite aufhebt und
               die vom jeweiligen Zeichen verlangte Breite
               einstellt. Diese Funktion arbeitet ausschlieûlich
               mit FSM-Outline-Fonts.

Ergebnis       Als Resultat erhÑlt man die gesetzte Zeichenzellen-
               breite in Punkten.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#        \#FSMGDOS\#
               \#vst_point\#   \#vst_height\#   \#vst_arbpt\#
\end

screen( capsensitive("vst_skew") )
Name           Set FSM skew - Setzen des Neigungsgrades fÅr Kursivschrift.

Definition     int  vst_skew( int handle, int skew );

Beschreibung   vst_skew setzt den Neigungsgrad fÅr Kursivschrift.
               Der neue Neigungsgrad skew wird in zehntel Grad
               angegeben und darf zwischen -900 und +900 variieren.
               Negative Werte fÅhren zu einer Linksneigung, wÑhrend
               positive Werte eine Rechtsneigung verursachen. Diese
               Funktion arbeitet ausschlieûlich mit FSM-Outline-
               Fonts.

Ergebnis       Als Resultat erhÑlt man den gesetzten Neigungsgrad.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#vst_effects\#
\end

screen( capsensitive("v_killoutline") )
Name           Kill FSM outline - Speicher zur Outline-Generierung
               freigeben.

Definition     void  v_killoutline( int handle,
                                     \#fsm_component_t\# *component );

Beschreibung   component ist die Adresse einer von \#v_getoutline\#
               generierten Outline. Der Speicher, den diese belegt,
               wird mittels v_killoutline wieder freigegeben.
               Diese Funktion sollte stets aufgerufen werden, sobald
               eine Outline nicht mehr benîtigt wird. Andernfalls
               lÑuft man Gefahr, keinen freien Speicher mehr zu
               haben.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#v_getoutline\#
\end

screen( capsensitive("v_getoutline") )
Name           Get FSM outline - Outline eines Zeichens berechnen.

Definition     void  v_getoutline( int handle, int ch,
                                    \#fsm_component_t\# **component );

Beschreibung   v_getoutline generiert zum Zeichen ch gehîrige Outline.
               Die Adresse des Buffers, in dem die Outline zu finden
               ist, wird unter der Adresse component abgelegt.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#v_killoutline\#
\end

screen( capsensitive("vst_scratch") )
Name           Set scratch buffer allocation mode - Bestimmen der
               Grîûe des Scratch-Buffers.

Definition     void  vst_scratch( int handle, int mode );

Beschreibung   vst_scratch setzt den Modus zur Berechnung der
               Grîûe des Scratch-Buffers. Der Scratch-Buffer
               dient der Generierung von Texteffekten. Da \#FSM\#-
               ZeichensÑtze frei skallierbar sind, kann dem
               Scratch-Buffer keine eindeutige Grîûe zugeordnet
               werden. Deshalb kann man einen Modus mode zur
               Grîûenbestimmung setzen:

                      0      BerÅcksichtigung auch von FSM-
                             ZeichensÑtzen (Standardeinstellung).
                      1      Grîûe richtet sich nach den
                             Bitmap-ZeichensÑtzen. Texteffekte
                             fÅr FSM-ZeichensÑtze sollten nicht
                             genutzt werden.
                      2      Es wird kein Scratch-Buffer angelegt
                             und es kînnen somit auch keine
                             Texteffekte ausgefÅhrt werden.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#vst_effects\#
\end

screen( capsensitive("vst_error") )
Name           Set FSM error mode - Setzen der FSMGDOS
               Fehlerbehandlung.

Definition     void  vst_error( int handle, int mode, int *errorvar );

Beschreibung   Wenn mode den Wert 1 enthÑlt, werden FSMGDOS Fehler
               direkt auf dem Bildschirm ausgegeben. Dies ist auch
               die Standardeinstellung. Falls Mode gleich Null ist,
               wird im Fehlerfall ein Fehlercode in die Variable 
               mit der Adresse errorvar geschrieben. Diese sollte
               mit Null initiallisiert werden. Vor der Benutzung
               der folgenden Funktionen unter FSMGDOS sollte
               die Variable abgefragt werden:

                   \#v_gtext\#            \#v_ftext\#
                   \#v_justified\#        \#vst_point\#
                   \#vst_height\#         \#vst_font\#
                   \#vst_arbpt\#          \#vqt_advance\#
                   \#vst_setsize\#        \#vqt_fontinfo\#
                   \#vqt_name\#           \#vqt_width\#
                   \#vqt_extent\#         \#vqt_f_extent\#
                   \#v_opnwk\#            \#v_opnvwk\#
                   \#vst_load_fonts\#     \#vst_unload_fonts\#

               Folgende Fehlercodes sind definiert:

                   0      Kein Fehler.
                   1      Zeichen nicht im Zeichensatz vorhanden.
                   8      Fehler beim Lesen der Zeichensatzdatei.
                   9      Fehler beim ôffnen der Zeichensatzdatei.
                   10     Falsches Dateiformat.
                   11     Kein freier Speicher mehr oder Cache voll.
                   -1     Unbestimmter Fehler.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
\end

screen( capsensitive("v_bez_on") )
Name           Enable Bezier capabilities - Bezier-Spline-Erzeugung
               an.

Definition     int  v_bez_on( int handle );

Beschreibung   Dieser Funktion aktiviert die Bezier-Spline-
               Erzeugung des GDOS. Obwohl mittels handle eine
               spezielle Arbeitsstation spezifiziert wird,
               gilt die Aktivierung fÅr alle Arbeitsstationen.

Ergebnis       Als Ergebnis erhÑlt man die maximale Bezier-Tiefe,
               ein Maû fÅr die Geschmeidigkeit des erzeugten
               Splines. Der Wert aus dem Intervall von 0 bis 7
               ist ein Exponent von 2 und gibt die Anzahl der
               Segmente an, aus denen ein Spline zusammengesetzt
               ist.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#v_bez_off\#     \#v_bez\#      \#v_bez_fill\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_bez_off") )
Name           Disable Bezier capabilities - Bezier-Spline-Erzeugung
               aus.

Definition     void  v_bez_off( int handle );

Beschreibung   Diese Funktion deaktiviert die Bezier-Spline-
               Erzeugung fÅr alle Arbeitsstationen. Speicher, der
               von GDOS zur Erzeugung der Splines angefordert
               wurde, wird freigegeben.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez\#      \#v_bez_fill\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_set_app_buff") )
Name           Reserve Bezier workspace - Speicher fÅr Bezier-
               Spline-Erzeugung reservieren.

Definition     void  v_set_app_buff( int handle, int **address,
                                      int nparagraphs );

Beschreibung   Mit dieser Funktion kann man einen Speicher fÅr
               die Bezier-Spline-Erzeugung setzen. Die Adresse
               des Buffers wird Åber address angegeben und die
               Grîûe in Paragraphen ( 16-Byte-Blîcke ) Åber
               nparagraphs. Werden Bezier-Funktionen aufgerufen,
               werden in diesem Buffer die Spline-Daten abgelegt.
               Andernfalls kann er auch vom Programm benutzt
               werden. Vor Programmende sollte man mit
               v_set_app_buff einen Null-Zeiger als Buffer
               mit Grîûe 0 setzen.
               Wird kein Buffer mittels v_set_app_buff gesetzt,
               legt GDOS einen eigenen Buffer (ca.8 KByte) an.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez\#
               \#v_bez_fill\#   \#v_bez_qual\#
               \#GDOS\#
\end

screen( capsensitive("v_bez") )
Name           Output Bezier - Bezier-Spline zeichnen.

Definition     void  v_bez( int handle, int count, int *xyarr,
                             char *bezarr, int *extent,
                             int *totpts, int *totmoves );

Beschreibung   v_bez zeichnet einen Bezier-Spline. count gibt
               die Anzahl der Knoten an.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.
               In totpts wird die Anzahl der Punkte im
               resultierenden Polygon abgelegt, in totmoves
               die Anzahl der ZÅge.

Gruppe         \#Ausgabefunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez_fill\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_bez_fill") )
Name           Output filled Bezier - Bezier-Spline zeichnen
               und fÅllen.

Definition     void  v_bez_fill( int handle, int count,
                                  int *xyarr, char *bezarr,
                                  int *extent, int *totpts,
                                  int *totmoves );

Beschreibung   v_bez_fill zeichnet einen Bezier-Spline und
               fÅllt diesen anschlieûend aus. count gibt die
               Anzahl der Knoten an.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.
               In totpts wird die Anzahl der Punkte im
               resultierenden Polygon abgelegt, in totmoves
               die Anzahl der ZÅge.

Gruppe         \#Ausgabefunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_bez_qual") )
Name           Set Bezier quality - QualitÑt der Bezier-Spline-
               Erzeugung setzen.

Definition     int  v_bez_qual( int handle, int prcnt,
                                   int *actual );

Beschreibung   Diese Funktion setzt einen neuen Geschwindigkeit/
               QualitÑts-Faktor prcnt, angegeben in Prozent.

Ergebnis       Man erhÑlt den bisherigen Geschwindigkeit/
               QualitÑts-Faktor. Dieser Wert wird auch unter
               der Adresse actual abgelegt.

Gruppe         \#Attributfunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez\#
               \#v_bez_fill\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( "Gleitkomma-Befehle" )
Gleitkomma-Befehle...
----------------------------------------------------------------------

... sind in der PCFLTLIB.LIB- bzw. \#PC881LIB.LIB\#-Bibliothek zusammen-
gefaût. Will man diese Bibliotheken dazulinken, mÅssen sie in der
\link("%%GLOBAL%%")Projektdatei\# vor PCSTDLIB.LIB stehen, da z.B. \#printf\# in beiden
Bibliotheken enthalten ist, aber nur PCFLTLIB.LIB bzw. PC881LIB.LIB
auch Gleitkommazahlen ausgegeben kann.

\#printf\#   <stdio.h> -+ Formatierte Ausgabe auf StandardausgabegerÑt
                    | bei Flieûkommazahlen
\#fprintf\#  <stdio.h>  |
\#sprintf\#  <stdio.h>  |
\#vfprintf\# <stdio.h>  |
\#vprintf\#  <stdio.h>  |
\#vsprintf\# <stdio.h> -+
\#scanf\#    <stdio.h> -+ Formatierte Eingabe Åber StandardeingabegerÑt
                    | bei Flieûkommazahlen
\#sscanf\#   <stdio.h>  |
\#fscanf\#   <stdio.h>  |
\#vfscanf\#  <stdio.h>  |
\#vscanf\#   <stdio.h>  |
\#vsscanf\#  <stdio.h> -+
\#ecvt\#     <math.h>  Konvertiert eine Flieûkommazahl in einen String
\#fcvt\#     <math.h>  Konvertiert eine Flieûkommazahl in einen String
\#gcvt\#     <math.h>  Konvertiert eine Flieûkommazahl in einen String
\#atof\#     <math.h>  Umwandlung von ASCII-String in Flieûkommazahl
\#xdcnv\#    <math.h>  Flieûkommaformat konvertieren
\#dxcnv\#    <math.h>  Flieûkommaformat konvertieren
\#fpumode\#  <math.h>  Flieûkomma-Koprozessorstatus ermitteln/setzen

Querverweis   \#Libraries\#   \#Mathematische Routinen\#
\end

screen( "Pure-C-Spezialfunktionen" )
Pure-C-Spezialfunktionen
----------------------------------------------------------------------

\#chdir\#      <ext.h> Wechselt das momentan gesetzte Directory.
\#coreleft\#   <ext.h> ermittelt den grîûten freien Speicherblock.
\#delay\#      <ext.h> wartet die angegebene Anzahl von Millisekunden.
\#filelength\# <ext.h> LÑnge einer Datei ermitteln.
\#findfirst\#  <ext.h> Ersten Eintrag im Verzeichnis ermitteln.
\#findnext\#   <ext.h> NÑchsten Eintrag im Verzeichnis ermitteln.
\#fstat\#      <ext.h> Informationen zu einer Datei ermitteln.
\#ftimtotm\#   <ext.h> Konvertiert eine ftime-Struktur in eine
                   tm-Struktur.
\#getch\#      <ext.h> Tastendruck einlesen.
\#getche\#     <ext.h> Tastendruck einlesen und ausgeben.
\#getcurdir\#  <ext.h> momentanes Dir. eines Laufwerks ermitteln.
\#getcwd\#     <ext.h> momentanes Directory als vollst. Suchweg.
\#getdate\#    <ext.h> Datum ermitteln.
\#getdfree\#   <ext.h> freien Platz einer Diskette/Festplatte
                   ermitteln.
\#getdisk\#    <ext.h> liefert das momentan gesetzte Laufwerk.
\#getftime\#   <ext.h> énderungsdatum einer Datei ermitteln.
\#gettime\#    <ext.h> Uhrzeit ermitteln.
\#isatty\#     <ext.h> GerÑt abfragen.
\#kbhit\#      <ext.h> Tastatur abfragen.
\#putch\#      <ext.h> Zeichen direkt auf Bildschirm schreiben.
\#random\#     <ext.h> Zufallszahl ermitteln.
\#setdate\#    <ext.h> Datum setzen.
\#setdisk\#    <ext.h> Laufwerk setzen.
\#setftime\#   <ext.h> énderungsdatum einer Datei festlegen.
\#settime\#    <ext.h> Uhrzeit setzen.
\#sleep\#      <ext.h> AusfÅhrung des Programms einen bestimmten
                   Zeitraum anhalten.
\#stat\#       <ext.h> Informationen zu einer Datei oder einem
                   Directory ermitteln.

Querverweis   \#Libraries\#
\end

screen( "Standard-Funktionen" )
Die Gruppen der Standard-Funktionen
----------------------------------------------------------------------

     \#Datum und Uhrzeit\#
     \#Directory-Routinen\#
     \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#
     \#I/O-Routinen\#
     \link("Behandlung variabler Argument")Behandlung variabler Argumente\#
     \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#
     \#Umwandlungsroutinen\#
     \#Mathematische Routinen\#
     \#Prozess-Routinen\#
     \#SprÅnge\#
     \link("String- und Speichermanipulat")String- und Speichermanipulation\#
     \#Verschiedene Routinen\#

Querverweis    \#Libraries\#
\end

screen( "Datum und Uhrzeit" )
Datum und Uhrzeit
----------------------------------------------------------------------

Setzen, Lesen, Konvertieren von Datum/Uhrzeit des Systems.

\#asctime\#   <time.h> Datum/Uhrzeit in ASCII-String umwandeln.
\#clock\#     <time.h> Ermittelt die Systemzeit.
\#ctime\#     <time.h> Datum und Uhrzeit in String umwandeln.
\#difftime\#  <time.h> Zeitunterschied berechnen.
\#getdate\#   <ext.h>  Datum ermitteln.
\#gettime\#   <ext.h>  Uhrzeit ermitteln.
\#gmtime\#    <time.h> Greenwich Meantime berechnen.
\#localtime\# <time.h> Datum/Uhrzeit in Zeitstruktur tm umwandeln.
\#mktime\#    <time.h> Datum konvertieren in Sekundenformat.
\#setdate\#   <ext.h>  Datum setzen.
\#settime\#   <ext.h>  Uhrzeit setzen.
\#strftime\#  <time.h> Datum in frei wÑhlbaren String umwandeln.
\#time\#      <time.h> Datum/Uhrzeit ermitteln.

Querverweis  \#Standard-Funktionen\#
\end

screen( "Directory-Routinen" )
Directory-Routinen
----------------------------------------------------------------------

Suche von Dateien in Verzeichnissen.

\#findfirst\# <ext.h> Ersten Eintrag im Verzeichnis ermitteln.
\#findnext\#  <ext.h> NÑchsten Eintrag im Verzeichnis ermitteln.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Dynamische Verwaltung des Spe" )
Dynamische Verwaltung des Speichers
----------------------------------------------------------------------

Routinen zur dynamischen Verwaltung des Speichers

\#calloc\#  <stdlib.h> Speicherbereich blockweise reservieren
\#free\#    <stdlib.h> Speicherbereich freigeben
\#malloc\#  <stdlib.h> Speicherbereich reservieren
\#realloc\# <stdlib.h> Speicherbereich anpassen

Querverweis   \#Standard-Funktionen\#
\end

screen( "I/O-Routinen" )
I/O-Routinen
----------------------------------------------------------------------

Ein-/Ausgaben sowohl auf Maschinenebene als auch durch Aufrufe des
Betriebssystems.

\#clearerr\# <stdio.h> Fehler- und EOF-Flags zurÅcksetzen.
\#close\#    <stdio.h> Datei schlieûen.
\#creat\#    <stdio.h> Datei anlegen.
\#fclose\#   <stdio.h> Datei schlieûen.
\#feof\#     <stdio.h> Dateiende (EOF) abfragen.
\#ferror\#   <stdio.h> Fehler ermitteln.
\#fflush\#   <stdio.h> Dateipuffer leeren.
\#fgetc\#    <stdio.h> Zeichen aus Datei lesen (Funktion).
\#fgetpos\#  <stdio.h> Datei-Position speichern
\#fgets\#    <stdio.h> Einlesen eines Strings aus Datei.
\#fileno\#   <stdio.h> Handle einer Datei erfragen.
\#fopen\#    <stdio.h> ôffnen einer Datei.
\#fprintf\#  <stdio.h> Formatierte Ausgabe Åber Datei.
\#fputc\#    <stdio.h> Ausgabe eines Zeichens auf Datei (Funktion).
\#fputs\#    <stdio.h> Ausgabe eines Strings auf Datei.
\#fread\#    <stdio.h> Einlesen eines Puffers von Datei.
\#freopen\#  <stdio.h> Datei-Handle mit neuem Dateinamen verknÅpfen.
\#fscanf\#   <stdio.h> Formatierte Eingabe Åber Datei.
\#fseek\#    <stdio.h> Datei-Position Ñndern.
\#fsetpos\#  <stdio.h> Gespeicherte Datei-Position anspringen.
\#ftell\#    <stdio.h> Datei-Position ermitteln.
\#fwrite\#   <stdio.h> Ausgabe eines Puffers auf Datei.
\#getc\#     <stdio.h> Zeichen von Datei einlesen (Makro).
\#getch\#    <ext.h>   Tastendruck einlesen.
\#getchar\#  <stdio.h> Eingabe eines Zeichens Åber StandardeingabegerÑt.
\#getftime\# <ext.h>   énderungsdatum einer Datei ermitteln.
\#gets\#     <stdio.h> String Åber StandardeingabegerÑt einlesen.
\#kbhit\#    <ext.h>   Tastatur abfragen.
\#lseek\#    <stdio.h> Datei-Position versetzen.
\#open\#     <stdio.h> Datei îffnen.
\#perror\#   <stdio.h> Fehlermeldung ausgeben.
\#printf\#   <stdio.h> Formatierte Ausgabe auf StandardausgabegerÑt.
\#putc\#     <stdio.h> Ausgabe eines Zeichens in Datei (Makro).
\#putch\#    <ext.h>   Zeichen direkt auf Bildschirm schreiben.
\#putchar\#  <stdio.h> Zeichen auf StandardausgabergerÑt schreiben.
\#puts\#     <stdio.h> String auf StandardausgabegerÑt ausgeben.
\#read\#     <stdio.h> Direktes Einlesen eines Dateiabschnitts.
\#remove\#   <stdio.h> Datei lîschen.
\#rename\#   <stdio.h> Datei umbenennen.
\#rewind\#   <stdio.h> Datei-Position an den Anfang setzen.
\#scanf\#    <stdio.h> Formatierte Eingabe Åber StandardeingabegerÑt.
\#setbuf\#   <stdio.h> Puffergrîûe einer Datei Ñndern.
\#setftime\# <ext.h>   énderungsdatum einer Datei festlegen.
\#setvbuf\#  <stdio.h> Puffergrîûe fein einstellen.
\#sprintf\#  <stdio.h> Formatierte Ausgabe in String.
\#sscanf\#   <stdio.h> Formatierte Eingabe von String.
\#strerror\# <string.h>liefert Strings mit Systemfehlermeldungen.
\#tmpnam\#   <stdio.h> Dateinamen fÅr temporÑre Datei erzeugen.
\#tmpfile\#  <stdio.h> TemporÑre Datei anlegen.
\#ungetc\#   <stdio.h> Zeichen an die Eingabedatei zurÅckgeben.
\#vfprintf\# <stdio.h> Formatierte Ausgabe mit variabler Argumentliste
                   auf Datei.
\#vfscanf\#  <stdio.h> Formatierte Eingabe aus einer Datei.
\#vprintf\#  <stdio.h> Formatierte Ausgabe mit variabler Argumentliste
                   auf das StandardausgabegerÑt.
\#vscanf\#   <stdio.h> Formatierte Eingabe vom StandardeingabegerÑt.
\#vsprintf\# <stdio.h> Formatierte Ausgabe mit variabler Argumentliste
                   in einen String.
\#vsscanf\#  <stdio.h> Formatierte Eingabe aus einer Datei.
\#write\#    <stdio.h> Direktes Schreiben eines Dateiabschnitts.
\#unlink\#   <stdio.h> Datei lîschen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Behandlung variabler Argument" )
Behandlung variabler Argumente
----------------------------------------------------------------------

Diese Routinen ermîglichen den Zugriff auf Parameter in Funktionen
mit variabler Parameter-Liste.

\#va_arg\#   <stdarg.h> Zugriff auf einen Parameter in einer varibalen
                    Argumentliste.
\#va_end\#   <stdarg.h> Ende der Behandlung variabler Argumente.
\#va_start\# <stdarg.h> Startpunkt der variablen Argumentliste festlegen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Zeichen-Klassifizierungs-Rout" )
Zeichen-Klassifizierungs-Routinen
----------------------------------------------------------------------

PrÅfung einzelner Zeichen auf ØBuchstabeÆ, ØZifferÆ, ØHex-DigitÆ usw.

\#isalnum\#  <ctype.h> PrÅfung auf alphanumerisches Zeichen.
\#isalpha\#  <ctype.h> PrÅfung auf Buchstaben.
\#isascii\#  <ctype.h> PrÅfung auf ASCII-Zeichen.
\#iscntrl\#  <ctype.h> PrÅfung auf Control-Zeichen.
\#isdigit\#  <ctype.h> PrÅfung auf dezimale Ziffer.
\#isgraph\#  <ctype.h> PrÅfung auf Grafik-Zeichen.
\#islower\#  <ctype.h> PrÅfung auf Kleinbuchstaben.
\#isodigit\# <ctype.h> PrÅfung auf oktale Ziffer.
\#isprint\#  <ctype.h> PrÅfung auf druckbares Zeichen.
\#ispunct\#  <ctype.h> PrÅfung auf Interpunktionszeichen
\#isspace\#  <ctype.h> PrÅfung auf Leerzeichen.
\#isupper\#  <ctype.h> PrÅfung auf Groûbuchstabe.
\#isxdigit\# <ctype.h> PrÅfung auf hexadezimale Ziffer.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Umwandlungsroutinen" )
Umwandlungsroutinen
----------------------------------------------------------------------

Interpretation von Stringinhalten als numerische Werte und umgekehrt,
sowie Umwandlung zwischen Groû- und Kleinbuchstaben.

\#atof\#    <stdlib.h> Umwandlung von ASCII-String in Flieûkommazahl.
\#atoi\#    <stdlib.h> Umwandlung von ASCII-String in Integer-Zahl.
\#atol\#    <stdlib.h> Umwandlung von ASCII-String in Long-Integer-Zahl.
\#ecvt\#    <stdlib.h> Umwandlung von Flieûkommazahl in einen ASCII-String.
\#ftoa\#    <stdlib.h> Umwandlung von Flieûkommazahl in einen ASCII-String.
\#itoa\#    <stdlib.h> Umwandlung von Integer-Zahl in ASCII-String.
\#ltoa\#    <stdlib.h> Umwandlung von Long-Integer-Zahl in ASCII-String.
\#strtod\#  <stdlib.h> Umwandlung von String in double-Zahl.
\#strtol\#  <stdlib.h> Umwandlung von String in Long-Integer-Zahl.
\#strtoul\# <stdlib.h> Umwandlung von String in Long-Integer-Zahl
                   ohne Vorzeichen.
\#toascii\# <ctype.h>  Umwandlung von Zeichen in ASCII.
\#tolower\# <ctype.h>  Umwandlung von Buchstaben in Kleinbuchstaben.
\#toupper\# <ctype.h>  Umwandlung von Buchstaben in Groûbuchstaben.
\#ultoa\#   <stdlib.h> Umwandlung von Long-Integer-Zahl ohne
                   Vorzeichen in ASCII-String.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Mathematische Routinen" )
Mathematische Routinen
----------------------------------------------------------------------

Funktionen der hîheren Mathematik, Trigonometrie und Interpretation
von Stringinhalten als numerische Werte.

\#abs\#    <stdlib.h> Absolut-Wert einer Integer-Zahl berechnen.
\#acos\#   <math.h>   Arcus Cosinus einer Zahl berechnen.
\#acosh\#  <math.h>   Arcus Cosinus hyperbolicus einer Zahl berechnen.
\#asin\#   <math.h>   Arcus Sinus einer Zahl berechnen.
\#asinh\#  <math.h>   Arcus Sinus einer Zahl berechnen.
\#atan\#   <math.h>   Arcus Tangens einer Zahl berechnen.
\#atanh\#  <math.h>   Arcus Tangens hyperbolicus einer Zahl berechnen.
\#atan2\#  <math.h>   Arcus Tangens eines Quotientens berechnen.
\#ceil\#   <math.h>   Auf nÑchst grîûere ganze Zahl runden.
\#cos\#    <math.h>   Cosinus einer Zahl berechnen.
\#cosh\#   <math.h>   Cosinus hyperbolicus einer Zahl berechnen.
\#div\#    <stdlib.h> Quotient und Rest einer Integer-Division berechnen.
\#exp\#    <math.h>   Exponentialfunktion einer Zahl berechnen.
\#fabs\#   <math.h>   Absolut-Wert einer Flieûkomma-Zahl berechnen.
\#floor\#  <math.h>   Auf nÑchst kleinere ganze Zahl runden.
\#fmod\#   <math.h>   Quotient und Rest einer Flieûkomma-Division
                  berechnen.
\#frexp\#  <math.h>   Flieûkommazahl in Mantisse und binÑren
                  Exponenten aufteilen.
\#labs\#   <stdlib.h> Absolut-Wert einer Long-Integer-Zahl berechnen.
\#ldexp\#  <math.h>   Zahl mit 2er-Exponenten multiplizieren.
\#ldiv\#   <stdlib.h> Quotient und Rest einer Long-Integer-Division
                  berechnen.
\#log\#    <math.h>   NatÅrlichen Logarithmus einer Zahl berechnen.
\#log10\#  <math.h>   Dekadischen Logarithmus einer Zahl berechnen.
\#modf\#   <math.h>   Flieûkommazahl in Mantisse und Exponenten aufteilen.
\#pow\#    <math.h>   Potenz berechnen.
\#round\#  <math.h>   Runden von Flieûkommazahlen
\#sin\#    <math.h>   Sinus einer Zahl berechnen.
\#sincos\# <math.h>   Sinus und Cosinus gleichzeitig.
\#sinh\#   <math.h>   Sinus hyperbolicus einer Zahl berechnen.
\#sqrt\#   <math.h>   Quadratwurzel einer Zahl berechnen.
\#tan\#    <math.h>   Tangens einer Zahl berechnen.
\#tanh\#   <math.h>   Tangens hyperbolicus einer Zahl berechnen.
\#trunc\#  <math.h>   Nachkommastellen "abschneiden"

Querverweis   \#Standard-Funktionen\#  \#__NFPUIN__\#
\end

screen( "Prozess-Routinen" )
Prozess-Routinen
----------------------------------------------------------------------

Aufruf/Start und Beendigung von Prozessen.

\#abort\#  <stdlib.h>  Programm-Abbruch.
\#atexit\# <stdlib.h>  Routinen beim Programm-Abbruch installieren.
\#exit\#   <stdlib.h>  Programm beenden.
\#exec\#   <process.h> Programm laden und ausfÅhren.
\#system\# <stdlib.h>  Befehl an TOS Åbergeben.

Querverweis   \#Standard-Funktionen\#
\end

screen( "SprÅnge" )
SprÅnge
----------------------------------------------------------------------

Die folgenden beiden Routinen bieten die Mîglichkeit eines nicht-
lokalen goto.

\#longjmp\# <setjmp.h> Unbedingten Sprung sofort durchfÅhren.
\#setjmp\#  <setjmp.h> Sprungziel aufsetzen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Verschiedene Routinen" )
Verschiedene Routinen
----------------------------------------------------------------------

Verschiedene Routinen, die zum Sprachstandard gehîren und sich
(zumindest teilweise) nicht einer der anderen Kategorien zuordnen
lassen.

\#assert\#     <assert.h> Fehlersuche mit gÅltigen C-AusdrÅcken.
\#bsearch\#    <stdlib.h> BinÑrsuche in Array durchfÅhren.
\#getenv\#     <stdlib.h> Environment-Variablen ermitteln.
\#qsort\#      <stdlib.h> Array mit Quicksort sortieren.
\#rand\#       <stdlib.h> Random-Funktion aufrufen.
\#srand\#      <stdlib.h> Random-Funktion neu starten.
\#setmatherr\# <math.h>   Routine zur Behandlung von Rechenfehlern
\#offsetof\#   <stddef.h> Abstand eines Strukturelements vom Struktur-
                         anfang ermittlen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "String- und Speichermanipulat" )
String- und Speichermanipulation
----------------------------------------------------------------------

Vergleich, Kopie, Verschieben und Absuchen von Strings/
Speicherbereichen sowie Verbinden von Stringteilen.

\#memchr\#  <string.h> Zeichen in Speicherbereich suchen.
\#memcpy\#  <string.h> Speicherbereiche kopieren (nicht Åberlappend).
\#memcmp\#  <string.h> Speicherbereiche vergleichen.
\#memmove\# <string.h> Speicherbereiche kopieren (Åberlappend).
\#memset\#  <string.h> Speicherbereich initialisieren.
\#strcat\#  <string.h> Strings zusammenhÑngen.
\#strchr\#  <string.h> Zeichen in String suchen.
\#strcmp\#  <string.h> Strings vergleichen.
\#strcpy\#  <string.h> String kopieren.
\#strcspn\# <string.h> LÑnge des Bereichs ermitteln, der kein Zeichen
                   eines zweiten Strings enthÑlt.
\#strdup\#  <string.h> String duplizieren.
\#stricmp\# <string.h> Strings vergleichen ohne Groû - Kleinschreibung.
\#strcmpi\# <string.h> identisch mit \#stricmp\#
\#strlen\#  <string.h> LÑnge eines Strings ermitteln.
\#strlwr\#  <string.h> String in Kleinbuchstaben umwandeln.
\#strncat\# <string.h> Strings bis zu n Zeichen zusammenhÑngen.
\#strncmp\# <string.h> Strings bis zu n Zeichen vergleichen.
\#strncpy\# <string.h> Bis zu n Zeichen in String kopieren.
\#strnicmp\#<string.h> Strings bis zu n Zeichen vergleichen ohne
                   Groû - Kleinschreibung.
\#strncmpi\#<string.h> identisch mit \#strnicmp\#
\#strset\# <string.h>  String mit Zeichen fÅllen.
\#strnset\# <string.h> Stringteil mit Zeichen fÅllen.
\#strpbrk\# <string.h> String nach Zeichen eines zweiten Strings absuchen.
\#strrchr\# <string.h> Letzte Position eines Zeichens in einem String
                   ermitteln.
\#strrev\#  <string.h> String invertieren.
\#strspn\#  <string.h> LÑnge eines Strings ermitteln, der nur die
                   Zeichen eines zweiten Strings enthÑlt.
\#strstr\#  <string.h> String in einem String suchen.
\#strtod\#  <string.h> String als \link("%%GLOBAL%%")double\# interpretieren.
\#strtol\#  <string.h> String als \link("%%GLOBAL%%")long\# interpretieren.
\#strtoul\# <string.h> String als \link("%%GLOBAL%%")unsigned\# \link("%%GLOBAL%%")long\# interpretieren.
\#strtok\#  <string.h> String in Abschnitte (Token) unterteilen.
\#strupr\#  <string.h> String in Groûbuchstaben umwandeln.

Querverweis   \#Standard-Funktionen\#
\end

screen( capsensitive("abort") )
Name           ØabortÆ-beendet einen Prozeû.

Definition     void  abort( void );

Prototyp in    stdlib.h

Beschreibung   abort gibt die Meldung ABNORMAL PROGRAM TERMINATION
               via stderr aus und bricht das Programm Åber einen
               Aufruf von _exit ab. Registrierte \#atexit\#()-
               Prozeduren werden nicht ausgefÅhrt. Der durch abort
               zurÅckgelieferte Exit-Code hat den Wert 3.

Ergebnis       Diese Funktion liefert naturgemÑû keinen Wert zurÅck.

Gruppe         \#Prozess-Routinen\#

Querverweis    \#assert\#   \#exec\#   \#exit\#
\end

screen( capsensitive("abs") )
Name           ØabsÆ-absoluter Wert.

Definition     int  abs( int i );

Prototyp in    stdlib.h

Beschreibung   abs liefert den Absolutwert des \link("%%GLOBAL%%")int\#-Arguments i.
               Es handelt es sich um einen ØechtenÆ Funktionsaufruf.

Ergebnis       abs liefert ein Resultat vom Datentyp \link("%%GLOBAL%%")int\# im Bereich
               von 0..32767. Der Wert -32768 hat fÅr den Datentyp
               \link("%%GLOBAL%%")int\# keine positive Entsprechung - abs(-32768) liefert
               deshalb den Wert -32768 zurÅck.

Gruppe         \#Mathematische Routinen\#

Querverweis:   \#labs\#   \#fabs\#   \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")#undef\#
\end

screen( capsensitive("acos") )
Name           Øarcus cosineÆ- Arcuscosinus.

Definition     double  acos( double x );

Prototyp in    math.h

Beschreibung   acos ist die Umkehrfunktionen zu \#cos\#.
               acos erwarten einen Wert im Bereich von -1..+1 und
               liefert den dazugehîrigen Winkel in der Einheit rad
               zurÅck. Argumente auûerhalb dieses Bereichs erzeugen
               das Funktionsergebnis 0 und setzen \#errno\# auf den Wert
               EDOM.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Ergebnis       acos liefert Werte im Bereich von 0..„.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("asctime") )
Name           ØASCII timeÆ- konvertiert Datum/Uhrzeit in einen
               ASCII-String.

Definition     char  *asctime( struct tm *tblock );

Prototyp in    time.h

Beschreibung   asctime erwartet als Argument einen Zeiger auf die
               Struktur \#tm\#.

Ergebnis       asctime liefert einen Zeiger auf einen statischen
               String ( der mit jedem Aufruf dieser Funktion neu
               gesetzt wird ) mit 26 Zeichen der das folgende
               Format hat:

               Mon Nov 21 11:31:54 1983\\n\\0

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#   \#getdate\#   \#time\#
\end

screen( capsensitive("asin") )
Name           Øarcus sineÆ Arcussinus.

Definition     double  asin( double x );

Prototyp in    math.h

Beschreibung   Erwartet einen "Sinuswert" (Bereich -1..+1) und liefert
               den dazugehîrigen Winkel in Rad zurÅck (-„/2 .. „/2).
               asin ist die Umkehrfunktionen zu \#sin\#.

Ergebnis       Argumente auûerhalb dieses Bereichs erzeugen das
               Funktionsergebnis 0 und setzen \#errno\# auf den Wert
               EDOM.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("assert") )
Name           ØassertionÆ- prÅft eine  Bedingung und bricht das
               Programm ab, wenn sie nicht zutrifft.

Definition     #include <stdio.h>
               void  assert( int test );

Prototyp in    assert.h

Beschreibung   assert ist ein Makro, das bei der Compilierung zu
               einer  if-Anweisung erweitert wird. Wenn test zur
               Laufzeit des Programms den Wert false ergibt,
               wird die Meldung.

               Assertion failed: test file <Datei> Line <Zeile>

               Åber einen Aufruf von \#fprintf\# ausgegeben, danach
               erfolgt ein Abbruch des Programms via \#abort\#().
               Die ausgegebene Zeilennummer steht fÅr die Zeile,
               in der sich der Aufruf von assert im Quelltext
               befindet. Wenn das Symbol NDEBUG vor der Aufnahme von
               assert.h im Quelltext (oder via  Defines) definiert
               ist, entfernt der \link("%%GLOBAL%%")PrÑprozessor\# sÑmtliche Aufrufe von
               assert.
Ergebnis       assert hat kein direktes Funktionsergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#abort\#   \#exit\#
\end

screen( capsensitive("atan") )
Name           Øarc tangentÆ- Arcustangens.

Definition     double  atan( double x );

Prototyp in    math.h

Beschreibung   atan ist die Umkehrfunktion zu \#tan\#.
               atan erwartet einen "Tangenswert" und liefert den
               dazugehîrigen Winkel in Rad (-„/2 .. „/2).
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("atan2") )
Name           Øarc tangentÆ- Arcustangens  von y/x.

Definition     double  atan2( double y, double x );

Prototyp in    math.h

Beschreibung   atan2 liefert den Arcustangens von y/x und erzeugt auch
               dann noch korrekte Resultate, wenn der sich ergebende
               Winkel nahe bei „/2 oder -„/2 liegt (den Polstellen der
               Tangensfunktion, fÅr Werte von x nahe Null).
               Wenn x und y gleich Null sind, wird \#errno\# auf
               den Wert EDOM gesetzt.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Ergebnis       Erwartet zwei "Tangenswerte" und liefert den
               dazugehîrigen Winkel in Rad (-„ .. „).

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("atexit") )
Name           Øat exitÆ- legt Routinen fest, die am Ende eines
               Programms aufgerufen werden sollen.

Definition     int  atexit( void (*func)( void ));

Prototyp in    stdlib.h

Beschreibung   öber atexit festgelegte Funktionen werden nach dem
               normalen Ende eines Programms in der Form
               *func(ohne Parameter)aufgerufen. Jeder Aufruf von
               atexit registriert eine weitere Funktion.
               Der Aufruf registrierter Funktionen geschieht in der
               durch die Aufrufe von atexit festgelegten Reihenfolge
               nach dem Prinzip Ølast in - first outÆ - die als letzte
               mit atexit festgelegte Funktion wird also zuerst
               aktiviert. Maximal kînnen 32 ØExit-FunktionenÆ
               festgelegt werden (atexit != 0).

Ergebnis       atexit liefert den Wert 0 zurÅck, wenn die angegebene
               Funktion in den ØStackÆ aufgenommen werden konnte;
               falls bereits 32 Funktionen registriert sind (und damit
               kein weiterer Platz mehr zur VerfÅgung steht), ist das
               Ergebnis -1.

Gruppe         \#Prozess-Routinen\#

Querverweis    \#exec\#   \#exit\#
\end

screen( capsensitive("atof") )
Name           ØASCII to floatÆ- konvertiert einen ASCII-String
               in eine Flieûkommazahl.

Definition     double  atof( const char *str );

Prototyp in    stdlib.h

Beschreibung   atof interpretiert den Åber str angegebenen \#String\#
               als  Flieûkommazahl und liefert das Ergebnis dieser
               Interpretation als \link("%%GLOBAL%%")double\# zurÅck.

Ergebnis       Wenn der zu interpretierende String  nicht numerisch
               auswertbar ist, dann ist das Ergebnis 0.0.
               Bei einem öberlauf wird plus oder minus HUGE_VAL
               (in math.h definiert) zurÅckgegeben und \#errno\# auf
               den den Wert ERANGE gesetzt.

Gruppe         \#Umwandlungsroutinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atoi\#   \#atol\#
\end

screen( capsensitive("ftoa") )
Name           Øfloat to ASCIIÆ- konvertiert eine Flieûkommazahl
               in einen ASCII-String.

Definition     int  ftoa( double *value, char *resStr, int ndig,
                           int format, int *dec, int *sign );

Prototyp in    math.h

Beschreibung   ftoa konvertiert value in einen nullterminierten
               String mit ndig Ziffern und liefert einen Zeiger zu
               diesem String in resStr zurÅck. Der String enthÑlt
               ausschlieûlich Ziffern: Åber *dec wird die Position
               des Dezimalpunkts relativ zum Beginn des Strings
               zurÅckgeliefert (negative Werte bedeuten hier:
               Dezimalpunkt links vom Stringanfang). Wenn value
               negativ ist, dann setzt ftoa *sign auf einen Wert
               ungleich Null (fÅr positive Werte von value ist
               *sign == 0). Im Unterschied zu \#ecvt\# unterstÅtzt
               ftoa mehrere Formate (anzugeben in format):
                0:  e-\#Format\#
                1:  f-\#Format\#
               -1:  g-\#Format\#

Ergebnis       ftoa liefert bei fehlerfreier AusfÅhrung 0, ansonsten
               einen Wert !=0.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#itoa\#   \#ltoa\#   \#ecvt\#
\end

screen( "String" )
Der String kann die folgenden Elemente enthalten - allerdings nur
in der gezeigten Reihenfolge:

               ˘ fÅhrende Leerzeichen und/oder Tabs;
               ˘ ein (optionales) Vorzeichen;
               ˘ eine Folge von Ziffern (Stellen vor dem Komma),
                 danach einen Dezimalpunkt und weitere Ziffern
                 (zumindest einer dieser beiden Teile muû
                 vorhanden sein);
               ˘ einen (optionalen) Exponenten, der mit einem e oder
                 E eingeleitet wird und ein (optionales) Vorzeichen
                 sowie einen (obligatorischen) Integer enthÑlt.
                 atoi und atol interpretieren einen String als
                 signed int bzw. als signed long. Dezimalpunkte und
                 Exponenten sind nicht zulÑssig - die Liste gÅltiger
                 Elemente verkÅrzt sich hier auf:
               ˘ fÅhrende Leerzeichen und/oder Tabs;
               ˘ ein (optionales) Vorzeichen;
               ˘ eine Ziffernfolge.

               Bei allen Funktionen endet die Interpretation mit
               dem ersten nichtnumerischen Zeichen (also auch
               mit einem Øweiûen LeerzeichenÆ innerhalb der
               Ziffernfolge), eine PrÅfung auf eventuelle öberlÑufe
               findet nicht statt.

Querverweis    \#atof\#, \#atoi\#, \#atol\#, \#scanf\#
\end

screen( capsensitive("atoi") )
Name           ØASCII to intÆ- konvertiert einen ASCII-String
               in einen Integer.

Definition     int  atoi( const char *str );

Prototyp in    stdlib.h

Beschreibung   atoi interpretiert den Åber str angegebenen \#String\#
               als Integer und liefert das Ergebnis dieser
               Interpretation als int zurÅck.

Ergebnis       Wenn der zu interpretierende \#String\# nicht
               numerisch auswertbar ist, dann ist das Ergebnis 0.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#atof\#   \#atol\#
\end

screen( capsensitive("atol") )
Name           ØASCII to longÆ- konvertiert einen ASCII-String
               in einen \link("%%GLOBAL%%")long\#.

Definition     long  atol( const char *str );

Prototyp in    stdlib.h

Beschreibung   atol interpretiert den Åber str angegebenen \#String\#
               als long und liefert das Ergebnis dieser
               Interpretation als long zurÅck.

Ergebnis       Wenn der zu interpretierende \#String\# Åberhaupt nicht
               numerisch auswertbar ist, dann ist das Ergebnis 0.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#atof\#   \#atoi\#
\end

screen( capsensitive("bsearch") )
Name           Øbinary searchÆ- binÑres Absuchen einer Liste.

Definition     void  *bsearch( const void *key, const void *base,
                                size_t nmemb, size_t size, 
                                int (*compar)( ));

Prototyp in    stdlib.h

Beschreibung   bsearch sucht ein beliebiges Array ab, dessen Elemente
               in aufsteigender Reihenfolge sortiert sein mÅssen.
               Die Anzahl der Elemente dieses Arrays ist durch nmemb
               festgelegt. bsearch fÅhrt lediglich eine Suche aus.
               Der Parameter size gibt die Grîûe eines
               Tabelleneintrags (in Bytes) an. Der Parameter base muû
               auf das erste Element des Arrays zeigen, nmemb auf
               einen Integer, der die Indexnummer des momentan
               hîchsten Array-Elements enthÑlt. size gibt die Grîûe
               eines einzelnen  Elements (in Byte) an, key zeigt auf
               die zu suchende Information. Der Parameter compar zeigt
               auf eine vom Programmierer erstellte Routine, der
               jeweils zwei Argumente in Form von Zeigern zum
               Vergleich Åbergeben werden: key (die zu suchende
               Information) und elem (das Element, mit dem der
               Vergleich  stattfinden soll). Die Routine muû die
               folgenden Werte zurÅckliefern:
               *key > *elem        Integer < 0
               *key == *elem           0
               *key < *elem        Integer > 0
               Auf welche Art und Weise die Vergleichsroutine
               arbeitet, ist allein Sache des Programmierers - Grenzen
               gibt es keine.

Ergebnis       Diese Funktion liefert einen Zeiger auf das erste
               Element des Arrays zurÅck, das mit den gesuchten
               Daten identisch ist. Falls der gesuchte Eintrag nicht
               existiert, liefert bsearch den Wert \link("%%GLOBAL%%")NULL\#.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#qsort\#   \#size_t\#
\end

screen( capsensitive("calloc") )
Name           Øcore allocationÆ- belegt Platz im Hauptspeicher.

Definition     void  *calloc( size_t nitems, size_t size );

Prototyp in    stdlib.h

Beschreibung   öber diese Funktionen wird der Heap verwaltet.
               calloc belegt einen Speicherbereich von nitems * size
               Bytes und liefert einen Zeiger auf die Startadresse
               dieses Bereichs zurÅck. Im Gegensatz zu \#malloc\# werden
               sÑmtliche Speicherzellen des neu belegten Bereichs auf
               den Wert 0 initialisiert.

Ergebnis       calloc liefert einen typenlosen Zeiger, der explizit
               auf den verwendeten Zeigertyp konvertiert werden
               sollte. Wenn kein Speicherbereich ausreichender Grîûe
               zur VerfÅgung steht, dann ist das Funktionsergebnis
               \link("%%GLOBAL%%")NULL\#, es findet keine Belegung statt.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#free\#   \#malloc\#   \#size_t\#
\end

screen( capsensitive("ceil") )
Name           ØceilingÆ(Decke)- rundet   das Argument zur
               nÑchst grîûeren Integerzahl.

Definition     double  ceil( double x );

Prototyp in    math.h

Beschreibung   ceil rundet in Richtung hîherer Integerwerte auf:
               ceil( 3.2 )    ergibt 4.0
               ceil( -1.8 )   ergibt -1.0
               (-1.0 ist ein grîûerer Wert als -1.8).

Ergebnis       ceil liefert ihr ganzzahliges Ergebnis als \link("%%GLOBAL%%")double\#
               zurÅck.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#floor\#   \#abs\#
\end

screen( capsensitive("chdir") )
Name           Øchange directoryÆ - wechselt das momentan gesetzte
               Directory

Definition     int  chdir( char *path );

Prototyp in    ext.h

Beschreibung   chdir setzt das durch path bezeichnete Directory als
               Standard-Directory. Das Laufwerk wird dabei nicht
               gewechselt.

Ergebnis       Wenn das angegebene Directory gesetzt werden konnte,
               liefert chdir den Wert 0; ansonsten wird -1
               zurÅckgeliefert und \#errno\# bekommt den Wert ENOENT.

Gruppe         \#Pure-C-Spezialfunktionen\#
\end

screen( capsensitive("coreleft") )
Name           Øcore leftÆ -  ermittelt den grîûten zur VerfÅgung
               stehenden Speicherblock

Definition     size_t  coreleft( void );

Prototyp in    ext.h

Beschreibung   coreleft ermittelt den grîûten zur VerfÅgung stehenden
               Speicherblock im RAM, der z.B. mittels \#malloc\# oder
               \#calloc\# reserviert werden kann.

Ergebnis       coreleft liefert die gefundene Anzahl in Byte.

Gruppe         \#Pure-C-Spezialfunktionen\#
\end

screen( capsensitive("clearerr") )
Name           Øclear errorÆ- setzt die Fehlerbedingung
               ØDateiendeÆ fÅr eine bestimmte Datei zurÅck.

Definition     void  clearerr( FILE *stream );

Prototyp in    stdio.h

Beschreibung   clearerr setzt das Fehler-Flag und das Dateiende-
               Flag der Åber stream angegebenen Datei zurÅck.
               (Das Dateiende-Flag wird beim Erreichen des
               Dateiendes automatisch gesetzt und bleibt es solange,
               bis entweder clearerr, \#fseek\# oder \#rewind\#
               angewendet werden oder die Datei geschlossen wird.)

Ergebnis       clearerr setzt das Fehler- und das Dateiende-Flag
               der angegebenen Datei zurÅck und hat ansonsten
               kein Ergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#
\end

screen( capsensitive("clock") )
Name           Øclock ticksÆ - ermittelt die Systemzeit.

Definition     clock_t  clock( void );

Prototyp in    time.h

Beschreibung   Die Funktion clock ermittelt die Systemzeit. Damit
               lassen sich sehr exakte Zeitmessungen durchfÅhren.
               Diese Funktion wird meistens fÅr Benchmarks verwendet.
               \#clock_t\# ist in time.h als long definiert. Die 
               Anzahl der "ticks" fÅr eine Sekunde ist mit \#CLK_TCK\#
               definiert.

Ergebnis       Die Funktion clock liefert -1, wenn die Zeit nicht
               ermittelt werden konnte, ansonsten die Systemzeit.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#time\#
\end

screen( capsensitive("close") )
Name           ØcloseÆ -  schlieût eine Datei.

Definition     int  close( int handle );

Prototyp in    stdio.h

Beschreibung   Die Funktion schlieût eine mit handle bezeichnete
               Datei. (Ein ØHandleÆ wird durch \#creat\# oder \#open\#
               erzeugt, d.h. einer Datei zugeordnet.)

Ergebnis       Die Funktion liefert den Wert 0 zurÅck, wenn die
               Operation fehlerfrei ausgefÅhrt werden konnte.
               Ansonsten ist das Ergebnis -1. Es wird jeweils ein
               gÅltiger Handle erwartet, der stellvertretend fÅr eine
               offene Datei steht. Falls dem nicht so ist, bekommt
               \#errno\# den Wert EBADF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#   \#fclose\#   \#fopen\#
\end

screen( capsensitive("cos") )
Name           ØcosineÆ - liefert den Cosinus des Arguments zurÅck.

Definition     double  cos( double x );

Prototyp in    math.h

Beschreibung   cos erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * „, 90 Grad = „/2, 180 Grad = „, 270 Grad = 1.5 * „,
               360 Grad = 2 * „ usw.) als Argument und liefert den
               dazugehîrigen Cosinus zurÅck. öbergebene Werte werden
               automatisch auf den Bereich 0..2*„ reduziert.
               Der Wert von „ (3.1415...) ist in math.h als Konstante
               mit dem Namen M_PI definiert

Ergebnis       Mîgliche Ergebnisse liegen im Bereich von -1 .. 1.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#acos\#
\end

screen( capsensitive("cosh") )
Name           Øcosine hyperbolicÆ - liefert den hyperbolischen
               Cosinus des Arguments zurÅck.

Definition     double  cosh( double x );

Prototyp in    math.h

Beschreibung   cosh berechnet den Cosinus hyperbolicus des Arguments,

Ergebnis       Bei fehlerfreier AusfÅhrung liefert die Funktion
               das entsprechende Ergebniss. Bei öberlÑufen wird
               HUGE_VAL (mit korrektem Vorzeichen) zurÅckgeliefert und
               \#errno\# bekommt den Wert ERANGE.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("acosh") )
Name           Øarcus cosine hyperbolicÆ - liefert den hyperbolischen
               Arcuscosinus des Arguments zurÅck.

Definition     double  acosh( double x );

Prototyp in    math.h

Beschreibung   acosh berechnet den Arcuscosinus hyperbolicus des
               Arguments.

Ergebnis       acosh erwartet einen Wert im Bereich von [1.0,
               +infinity] und liefert den dazugehîrigen Wert im Be-
               reich von [0.0,+infinity].
               Argumente auûerhalb des gÅltigen Bereichs erzeugen
               das Funktionsergebnis 0 und setzen \#errno\# auf den Wert
               EDOM.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("creat") )
Name           ØcreateÆ - erzeugt eine neue Datei bzw. Åberschreibt
               eine bereits vorhandene Datei.

Definition     int  creat( const char *filename );

Prototyp in    stdio.h

Beschreibung   creat erzeugt eine neue Datei, existiert bereits
               die durch filename bezeichnete Datei wird der vorherige
               Inhalt gelîscht. Attribute, die fÅr diese Datei
               definiert wurden, bleiben unverÑndert.
               Falls die Datei nur gelesen werden kann, bricht creat
               mit einem Fehler ab, die Datei bleibt unverÑndert.

Ergebnis       Wenn die angegebene Datei fehlerfrei erîffnet werden
               konnte, liefert die Funktion einen ØHandleÆ (d.h. einen
               positiven Integerwert) zurÅck. Im Fehlerfall wird das
               Ergebnis -1 geliefert und \#errno\# bekommt einen der
               folgenden Werte:
               ENOENT       EMFILE       EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#close\#    \#open\#   \#read\#   \#write\#
\end

screen( capsensitive("ctime") )
Name           Øconvert timeÆ - konvertiert Datum und Uhrzeit in
               einen String.

Definition     char  *ctime( time_t *timer );

Prototyp in    time.h

Beschreibung   ctime erwartet einen Zeiger auf Datum und Uhrzeit des
               Systems. \#time_t\# wird beispielsweise von der Funktion
               \#time\# geliefert. Das Ergebnis von ctime ist ein
               String mit 26 Zeichen, der das folgende Format hat:

               Mon Nov 21 11:31:54 1983\\n\\0

               Alle Felder dieses Strings haben eine konstante LÑnge.

Ergebnis       ctime und liefert einen Zeiger auf einen statischen
               String zurÅck, der mit jedem Aufruf dieser Funktion
               erneut gesetzt wird.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#getdate\#   \#time\#   \#asctime\#
\end

screen( capsensitive("difftime") )
Name           Ødifference timeÆ - berechnet den Unterschied zwischen
               zwei Zeitangaben in Sekunden.

Definition     double  difftime( time_t time1, time_t time2 );

Prototyp in    time.h

Beschreibung   difftime berechnet die zwischen time1 und time2
               liegende Zeit in Sekunden.

Ergebnis       difftime liefert die Differenz zweier Zeiten als
               \link("%%GLOBAL%%")double\# in der Einheit Sekunden zurÅck.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#getdate\#   \#ctime\#   \#asctime\#   \#time\#   \#time_t\#
\end

screen( capsensitive("div") )
Name           ØdivideÆ - dividiert zwei Integerwerte und liefert
               nicht nur den Quotienten, sondern auch den
               Divisionsrest zurÅck.

Definition     div_t  div( int numer, int denom );

Prototyp in    stdlib.h

Beschreibung   div dividiert die als numer (Dividend) und denom
               (Divisor) Åbergebenen Integerwerte und liefert
               eine Struktur des Typs \#div_t\# zurÅck.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#ldiv\#
\end

screen( capsensitive("ecvt") )
Name           Øe-convertÆ - konvertiert eine Flieûkommazahl in einen
               String.

Definition     char  *ecvt( double value, int ndig, int *dec,
                             int *sign );

Prototyp in    stdlib.h

Beschreibung   ecvt konvertiert value in einen nullterminierten
               String mit ndig Ziffern und liefert einen Zeiger zu
               diesem String zurÅck. Der String enthÑlt ausschlieûlich
               Ziffern: Åber dec wird die Position des Dezimalpunkts
               relativ zum Beginn des Strings zurÅckgeliefert
               (negative Werte bedeuten hier: Dezimalpunkt links vom
               Stringanfang). Wenn value negativ ist, dann setzt ecvt
               sign auf einen Wert ungleich Null (fÅr positive Werte
               von value ist sign == 0). Die unterste Ziffer wird
               gerundet.

Ergebnis       ecvt liefert einen Zeiger zu einem benutzten und
               statischen String zurÅck.

PortabilitÑt   Auf UNIX verfÅgbar, jedoch nicht im ANSI-Standard
               enthalten.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#ftoa\#   \#fcvt\#   \#gcvt\#   \#sprintf\#
\end

screen( capsensitive("fcvt") )
Name           Øf-convertÆ - konvertiert eine Flieûkommazahl in einen
               String.

Definition     char  *fcvt( double value, int ndig, int *dec,
                             int *sign );

Prototyp in    stdlib.h

Beschreibung   fcvt konvertiert value in einen nullterminierten
               String mit ndig Ziffern und liefert einen Zeiger zu
               diesem String zurÅck. Der String enthÑlt ausschlieûlich
               Ziffern: Åber dec wird die Position des Dezimalpunkts
               relativ zum Beginn des Strings zurÅckgeliefert
               (negative Werte bedeuten hier: Dezimalpunkt links vom
               Stringanfang). Wenn value negativ ist, dann setzt fcvt
               sign auf einen Wert ungleich Null (fÅr positive Werte
               von value ist sign == 0). Die Zahl wird gemÑû der in
               ndig angegebenen Genauigkeit gerundet.

Ergebnis       fcvt liefert einen Zeiger zu einem benutzten und
               statischen String zurÅck.

PortabilitÑt   Auf UNIX verfÅgbar, jedoch nicht im ANSI-Standard
               enthalten.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#ftoa\#   \#ecvt\#   \#gcvt\#   \#sprintf\#
\end

screen( capsensitive("gcvt") )
Name           Øg-convertÆ - konvertiert eine Flieûkommazahl in einen
               String.

Definition     char  *gcvt( double value, int ndec, char *buf );

Prototyp in    stdlib.h

Beschreibung   gcvt konvertiert value in einen nullterminierten
               String und speichert ihn in buf. Es werden ndec
               signifikante Ziffern im FORTRAN-F-Format erzeugt,
               sofern mîglich. Ansonsten wird der Wert im
               \link("Format-String (printf)")printf-E-Format\# zurÅckgegeben.

Ergebnis       gcvt liefert einen Zeiger auf den erzeugten String
               zurÅck.

PortabilitÑt   Auf UNIX verfÅgbar, jedoch nicht im ANSI-Standard
               enthalten.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#ftoa\#   \#ecvt\#   \#fcvt\#   \#sprintf\#
\end

screen( capsensitive("exec") )
Name           ØexecuteÆ - Laden und Starten eines anderen Programms.

Definition     int  exec( char *pathname, char *cmdlstr,
                           char *envstr, int *retcode);

Prototyp in    process.h

Beschreibung   Die Funktion exec lÑdt und startet andere Programme, die
               als child prosess bezeichnet werden.
Hinweis        exec schlieût keine Dateien - sÑmtliche durch den
               parent process geîffneten Dateien stehen auch dem child
               zur VerfÅgung. Der Parameter pathname gibt den Namen
               des child process an.
               Eventuelle Parameter fÅr dieses Programm kînnen in
               cmdlstr Åbergeben werden. Mit envstr kînnen
               Environment-Werte fÅr den child-process gesetzt werden.

Ergebnis       Konnte die exec-Funktion nicht ausgefÅhrt werden, dann
               wird -1 zurÅckgeliefert, und \#errno\# bekommt einen der
               folgenden Werte:
               EACCES   EMFILE   ENOENT   ENOMEM   EPLFMT

Gruppe         \#Prozess-Routinen\#

Querverweis    \#abort\#   \#atexit\#   \#exit\#   \#system\#
\end

screen( capsensitive("exit"),
		capsensitive("_exit") )
Name           ØexitÆ - beendet das laufende Programm

Definition     void  exit( int status );
               void  _exit( int status );

Prototyp in    stdlib.h

Beschreibung   exit beendet das laufende Programm. Vor dem RÅcksprung
               zum parent process werden sÑmtliche Dateipuffer
               geschrieben, offene Dateien geschlossen und
               ( via \#atexit\# ) festgelegte Funktionen aufgerufen.
               Diese Funktion beendet das Programm mit dem als status
               angegebenen Exit-Code, der beispielsweise vom parent
               process geprÅft werden kann. Der Wert 0 steht
               hier normalerweise fÅr eine fehlerfreie AusfÅhrung,
               Werte ungleich Null sollten Fehler signalisieren.
               Im unterschied zu exit werden bei _exit Funktionen,
               die mit \#atexit\# installiert wurden nicht aufgerufen.

Ergebnis       Weder exit noch _exit haben ein direktes Funktionsergebnis.

Gruppe         \#Prozess-Routinen\#

Querverweis    \#abort\#   \#atexit\#
\end

screen( capsensitive("exp") )
Name           ØexponentialÆ - berechnet e ^ x.

Definition     double  exp( double x );

Prototyp in    math.h

Bescheibung    exp liefert das Ergebnis der Berechnung e^x zurÅck,
               wobei e fÅr die Basis des natÅrlichen Logarithmus steht
               (2.718281...).

Ergebnis       Bei einem öberlauf liefert exp HUGE_VAL und setzt
               \#errno\# auf den Wert ERANGE. Im Falle eines Unterlaufs
               ist das Resultat 0.0 und errno wird nicht geÑndert.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#frexp\#   \#ldexp\#   \#log\#   \#pow\#   \#sqrt\#
\end

screen( capsensitive("fabs") )
Name           Øfloat absÆ - absoluter Wert einer Flieûkommazahl.

Definition     double  fabs( double x );

Prototyp in    math.h

Beschreibung   fabs liefert den Absolutwert des \link("%%GLOBAL%%")double\#-Arguments x
               zurÅck.

Ergebnis       fabs liefert den Absolutwert des \link("%%GLOBAL%%")double\#-Arguments x.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis:   \#labs\#   \#abs\#
\end

screen( capsensitive("fclose") )
Name           Øfile closeÆ - schlieût eine Datei.

Definition     int  fclose( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fclose schlieût die durch stream angegebene Datei,
               wobei zuvor ein entsprechender Aufruf von \#fflush\#
               erfolgt. Durch das System automatisch belegte Puffer
               werden durch fclose freigegeben.

Ergebnis       fclose liefert bei fehlerfreier AusfÅhrung den Wert 0.
               Im Falle eines Fehlers liefert fclose den Wert EOF
               zurÅck.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fflush\#   \#close\#   \#fopen\#   \#setbuf\#   \#Fclose\#
\end

screen( capsensitive("feof") )
Name           Øfile eofÆ - prÅft, ob das Ende einer Datei
               erreicht ist.

Definition     int  feof( FILE *stream );

Prototyp in    stdio.h

Beschreibung   feof ist ein Makro und prÅft das Dateiende-Flag der
               Åber stream angegebenen Datei. (Dieses Flag wird
               beim Erreichen des Dateiendes automatisch gesetzt und
               bleibt es solange, bis entweder \#clearerr\#, \#fseek\#
               oder \#rewind\# angewendet werden oder die Datei
               geschlossen wird.)

Ergebnis       feof liefert einen Wert ungleich 0 zurÅck, wenn
               das Dateiende-Flag des angegebenen stream gesetzt
               ist, ansonsten den Wert 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#
\end

screen( capsensitive("ferror") )
Name           Øfile errorÆ - prÅft Fehlerbedingungen bei der
               Bearbeitung von Dateien.

Definition     int  ferror( FILE *stream );

Prototyp in    stdio.h

Beschreibung   ferror ist ein Makro, der die Åber stream angegebenen
               Datei auf Schreib- und Lesefehler prÅft. (Das Fehler-
               Flag einer Datei bleibt nach einem Fehler solange
               gesetzt, bis entweder \#clearerr\# oder \#rewind\#
               angewendet oder die Datei geschlossen wird.).

Ergebnis       ferror liefert einen Wert ungleich 0 zurÅck, wenn
               das Fehlerflag des angegebenen stream gesetzt ist,
               ansonsten den Wert 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#getc\#   \#gets\#   \#open\#   \#putc\#   \#puts\#
\end

screen( capsensitive("fflush") )
Name           Øfile flushÆ - erzwingt das physikalische Schreiben
               eines Dateipuffers.

Definition     int  fflush( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fflush erzwingt bei Ausgabedateien ein Schreiben
               eventueller Pufferinhalte, sorgt also bei
               Diskettendateien dafÅr, daû ausgegebene Daten auch
               physikalisch geschrieben werden. Bei Eingabedateien
               wird ein eventueller Pufferinhalt gelîscht - der
               nÑchste Lesebefehl erzwingt eine physikalische
               Leseaktion. Die durch stream bezeichnete Datei bleibt
               offen.

Ergebnis       fflush liefert bei fehlerfreier AusfÅhrung den Wert 0.
               Im Falle eines Fehlers liefert fflush den Wert EOF
               zurÅck.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fclose\#   \#close\#   \#fopen\#   \#setbuf\#
\end

screen( capsensitive("fgetc") )
Name           Øfile get characterÆ - liest ein Zeichen aus einer Datei.

Definition     int  fgetc( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fgetc verhÑlt sich exakt wie \#getc\#, nur daû
               es sich hier um eine echte Funktion handelt.

Ergebnis       fgetc liefert bei fehlerfreier AusfÅhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurÅck, wobei keine Vorzeichen-
               erweiterung stattfindet. Bei öberschreitung des
               Dateiendes (beim Lesen der Tastatur: der Eingabe von
               control-z) wird der Wert EOF zurÅckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#getc\#    \#ungetc\#   \#ferror\#   \#fopen\#   \#fread\#
               \#fseek\#   \#gets\#     \#putc\#     \#read\#    \#scanf\#
\end

screen( capsensitive("fgetpos") )
Name           Øfile get positionÆ - aktuelle Datei-Position
               speichern.

Definition     int  fgetpos( FILE *stream, fpos_t *pos );

Prototyp in    stdio.h

Beschreibung   Die Funktion fgetpos speichert die aktuelle Position
               in der Datei stream im Parameter pos. Der gespeicherte
               Wert ist speziell kodiert und kann lediglich von der
               Funktion \#fsetpos\# verwendet werden.

Ergebnis       Die Funktion liefert den Wert 0, wenn die Datei-
               Position ermittelt werden konnte, ansonsten einen
               Fehlercode und \#errno\# wird auf EBADF oder EINVAL
               gesetzt.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fsetpos\#
\end

screen( capsensitive("fgets") )
Name           Øfile get stringÆ - liest einen String aus einem
               Stream.

Definition     char  *fgets( char *str, int n, FILE *fp );

Prototyp in    stdio.h

Beschreibung   fgets liest eine Zeichenfolge die mit einen
               Zeilenvorschub endet vom Stream fp und speichert
               diese in der durch str angegebenen Stringvariablen.
               Der String darf maximal n Zeichen umfassen,
               ansonsten wird der String abgeschnitten. Der
               Zeilenvorschub bleibt im String erhalten. Ein
               Null-Byte wird anghÑngt, um das Stringende zu
               markieren.

Ergebnis       fgets liefert bei fehlerfreier AusfÅhrung einen
               Zeiger auf str zurÅck. Wenn beim Lesen das
               Dateiende Åberschritten wird oder ein Fehler
               auftritt, ist das Resultat \link("%%GLOBAL%%")NULL\#.

Gruppe         \#I/O-Routinen\#

Querverweis    \#gets\#   \#ferror\#   \#fopen\#   \#fread\#   \#getc\#
               \#puts\#   \#scanf\#
\end

screen( capsensitive("fileno") )
Name           Øfile numberÆ - liefert den Handle einer Datei zurÅck

Definition     int  fileno( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fileno ist ein Makro und liefert den Handle der öber
               stream angegebenen Datei zurÅck. Wenn stream mehr als
               ein Handle zugeordnet ist, wird der Handle zurÅckge-
               liefert, der bei der Erîffnung vergeben wurde.

Ergebnis       Solange stream eine offene Datei bezeichnet, wird der
               Handle als Integer zurÅckgeliefert. Spezielle Werte fÅr
               Fehler gibt es nicht - wenn stream keine offene Datei
               bzeichnet, ist das Ergebnis von fileno undefiniert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#gets\#   \#ferror\#   \#fopen\#   \#fread\#   \#getc\#
               \#puts\#   \#scanf\#
\end

screen( capsensitive("filelength") )
Name           Øfile lengthÆ - ermittelt die LÑnge einer Datei.

Definition     long  filelength( int handle );

Prototyp in    ext.h

Beschreibung   filelength liefert die LÑnge der Åber handle
               angegebenen Datei in Bytes zurÅck.

Ergebnis       filelength liefert bei fehlerfreier AusfÅhrung den Wert
               in Bytes. Im Falle eines Fehlers ist das Resultat -1
               und \#errno\# erhÑlt den Wert EBADF.

Gruppe         \#Pure-C-Spezialfunktionen\#

Querverweis    \#fseek\#   \#fstat\#
\end

screen( capsensitive("findfirst") )
Name           Øfind first entryÆ - sucht ein Directory nach
               einem Dateieintrag ab.

Definition     int  findfirst( const char *filename,
                                struct ffblk *fileRec, int attrib );
Prototyp in    ext.h

Beschreibung   findfirst sucht ein Directory nach dem ersten
               Vorkommen des Dateieintrags filename ab.
               filename kann optional eine Laufwerksbezeichnung
               und/oder einen Suchweg enthalten, Jokerzeichen
               (* und ?) sind erlaubt. findfirst sucht im Åber
               filename angegebenen Directory bzw. dem momentan
               gesetzten Directory. Der erste Eintragsvergleich,
               der positiv ausfÑllt, setzt die Åber fileRec
               angegebene Struktur \#ffblk\# mit den entsprechenden
               Informationen. öber den Parameter attrib wird das
               Attribut des zu suchenden Eintrags angegeben.
               Die folgenden Konstanten sind in ext.h definiert und
               kînnen Åber OR-Operationen miteinander kombiniert
               werden:

               FA_RDONLY    0x01 schreibgeschÅtzt
               FA_HIDDEN    0x02 versteckt
               FA_SYSTEM    0x04 Systemdatei
               FA_LABEL     0x08 Label (Diskettenname)
               FA_DIREC     0x10 Directory
               FA_ARCH      0x20 Archivierungs-Bit

Ergebnis       Die Funktion liefert den Wert 0 zurÅck, wenn
               ein passender Eintrag  gefunden wurde.
               Wenn kein Eintrag vorhanden ist oder der angegebene
               filename aus irgendeinem Grund ungÅltig ist, wird -1
               als  Ergebnis geliefert und \#errno\# bekommt einen der
               Werte ENOENT oder ENMFILE.

Gruppe         \#Directory-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#findnext\#
\end

screen( capsensitive("findnext") )
Name           Øfind nextÆ - sucht ein Directory
               (nach Aufruf von \#findfirst\#) nach weiteren
               EintrÑgen ab.

Definition     int  findnext( struct ffblk *fileRec );

Prototyp in    ext.h

Beschreibung   findnext sucht nach weiteren EintrÑgen innerhalb
               eines Directories:
               ˘ als Argument muû die Struktur des Typs \#ffblk\#
               Åbergeben werden, die durch \#findfirst\# gesetzt
               wurde.
               ˘ findnext liefert bei jedem Aufruf einen
               weiteren Dateieintrag Åber \#ffblk\# zurÅck

Ergebnis       Die Funktion liefert den Wert 0 zurÅck, wenn
               ein weiterer Eintrag  gefunden wurde.
               Wenn kein weiterer Eintrag mehr vorhanden ist,
               wird -1 als  Ergebnis geliefert und \#errno\# bekommt
               einen der Werte ENOENT oder ENMFILE.

Gruppe         \#Directory-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#findfirst\#
\end

screen( capsensitive("stat") )
Name           ØstatusÆ - liefert Informationen Åber eine Datei oder
               ein Directory.

Definition     int  stat( char *path, \link("st_dev")struct stat\# *statbuf );

Prototyp in    ext.h

Beschreibung   stat setzt die Mitglieder einer Struktur des Typs
               \#stat\# mit Informationen Åber die durch path ange-
               gebene Datei und ist auch auf Directories anwendbar.

Ergebnis       stat liefert bei fehlerfreier AusfÅhrung den Wert 0
               zurÅck. Im Falle eines Fehlers ist das Resultat -1 und
               \#errno\# erhÑlt den Wert ENOENT.

Querverweis    \#fstat\#
\end

screen( capsensitive("fstat") )
Name           Øfile statusÆ - liefert Informationen Åber eine Datei.

Definition     int  fstat( int handle, struct \#stat\# *statbuf );

Prototyp in    ext.h

Beschreibung   fstat setzt die Mitglieder einer Struktur des Typs
               \#stat\# mit Informationen Åber die durch handle ange-
               gebene Datei und ist nur auf offene Dateien anwendbar.

Ergebnis       fstat liefert bei fehlerfreier AusfÅhrung den Wert 0
               zurÅck. Im Falle eines Fehlers ist das Resultat -1 und
               \#errno\# erhÑlt den entsprechenden Wert EBADF.

Querverweis    \#stat\#
\end

screen( capsensitive("getcurdir") )
Name           get current directory - ermittelt das momentan
               gesetzte Directory eines Laufwerks.

Definition     int  getcurdir( int drive, char *directory );

Prototyp in    ext.h

Beschreibung   getcurdir ermittelt das als Standard gesetzte Directory
               auf dem durch drive angegebenen Laufwerk. Wenn drive
               den Wert 0 hat, wird das momentan gesetzte Laufwerk
               verwendet, ansonsten gilt A = 1, B = 2 usw.
               Der durch directory bezeichnete String mu· eine LÑnge
               von MAXDIR (106 Zeichen) haben - hier trÑgt getcurdir
               den Namen des gesetzten Directories ein (ohne
               fÅhrende/folgende umgekehrte SchrÑgstriche und
               ohne Laufwerksbezeichner/Doppelpunkt). Die Konstante
               MAXDIR ist in ext.h definiert.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert getcurdir den
               Wert 0 zurÅck, ansonsten den Wert -1.

Beispiel       #include <ext.h>
               #include <stdio.h>
               #include <string.h>

               char *pathnow (char *path)
               {
                   strcpy (path, " :\\");
                   path[0] = 'A' + getdisk();  /* Laufwerk */
                   getcurdir(0, path+3);
                   return(path);
               }

               main()
               {
                   char mypath[MAXDRIVE+MAXPATH];
                   printf("Momentan gesetztes Directory: %s\\n",
                          pathnow(mypath));
               }

PortabilitÑt   Pure- und Turbo-C-spezifisch.

Querverweis    \#chdir\#, \#getcwd\#
\end

screen( capsensitive("getcwd") )
Name           get current working directory - liefert das momentan
               gesetzte Directory als vollstÑndigen Suchweg zurÅck.

Definition     char *getcwd(char *buf, int buflen);

Prototyp in    ext.h

Beschreibung   getcwd liefert das momentan gesetzte Directory
               (inklusive des Laufwerks) als String zurÅck, dessen
               MaximallÑnge durch den Parameter buflen gesetzt wird
               (hier wird man normalerweise die Konstante MAXPATH
               verwenden).
               Wenn der als buf Åbergebene Zeiger den Wert NULL hat,
               belegt getcwd Åber einen Aufruf von malloc selbstÑndig
               einen Bereich von buflen Bytes. Durch diese Automatik
               gibt es zwei mîgliche Arten des Aufrufs:

               char *bufpoint;
               char pathbuf[MAXPATH];

               getcwd(pathbuf,MAXPATH);
               bufpoint = getcwd(NULL,MAXPATH);

               Ein durch die zweite Form des Aufrufs automatisch
               belegter Speicherbereich kann via free wieder
               freigegeben werden.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert getcwd einen Zeiger
               auf den gesetzten String zurÅck. Im Falle eines Fehlers
               ist das Funktionsergebnis NULL, \#errno\# wird auf einen der
               folgenden Werte gesetzt:
               ENODEV GerÑt nicht bereit/nicht vorhanden
               ENOMEM nicht genug Platz im Hauptspeicher
                      (Fehlermeldung von malloc)
               ERANGE Ergebnis au·erhalb des Bereichs
                      (ungÅltige Angabe fÅr buflen).

PortabilitÑt   Pure- und Turbo-C-spezifisch.

Querverweis    \#free\#, \#getcurdir\#, \#malloc\#
\end

screen( capsensitive("getdisk") )
Name           get disk - liefert das momentan gesetzte Laufwerk.

Definition     int  getdisk( void );

Prototyp in    ext.h

Beschreibung   getdisk ermittelt die Nummer des momentan gesetzten
               Laufwerks als Integer (0 entspricht Laufwerk A,
               1 entspricht Laufwerk B usw.).

Beispiel       Siehe \#getcurdir\#

Ergebnis       getdisk liefert das momentan gesetzte Laufwerk zurÅck.

PortabilitÑt   Pure- und Turbo-C-spezifisch.

Querverweis    \#setdisk\# \#getcurdir\#
\end

screen( capsensitive("getdfree") )
Name           get disk free - ermittelt den freien Platz auf einer
               Diskette/Festplatte.

Definition     void  getdfree( unsigned char drive, \link("df_sclus")struct dfree\# *dtable );

Prototyp in    ext.h

Beschreibung   getdfree verwendet die Funktion, um Informationen Åber
               den freien Platz auf dem durch drive angegebenen Lauf-
               werk in einer Struktur des Typs dfree zurÅckzuliefern.
               Wenn drive den Wert 0 hat, wird das momentan gesetzte
               Laufwerk bearbeitet, ansonsten gilt A = 1, B = 2 usw.

Ergebnis       getdfree hat kein direktes Funktionsergebnis. Im Falle
               eines Fehlers bekommt das Mitglied df_sclus den Wert
               -1 zugewiesen.

PortabilitÑt   Pure- und Turbo-C-spezifisch.
\end

screen( capsensitive("signal") )
Name           ØsignalÆ - legt fest, wie das Programm auf Software-
               oder Hardware-Signale (AusnahmezustÑnde) reagiert.

Definition     \#sigfunc_t\# signal( int sig, \#sigfunc_t\# func );

Prototyp in    signal.h

Beschreibung   Hardware-Ausnahme-ZustÑnde wie illegale Befehle,
               Bus- oder Adreûfehler, ØInterruptsÆ (z.B. vom
               Timer-Baustein), aber auch Software-ØInterruptsÆ wie
               der TRAP-Befehl lîsen ein Software-Signal (technisch:
               eine ØExceptionÆ) aus, auf die ein Pure-C-Programm in
               zwei Schritten reagiert:

               1. PrÅfung, welche Aktion auf dieses Signal hin
                  ausgefÅhrt werden soll, d.h. Auslesen einer Tabelle;
               2. AusfÅhrung dieser Aktion, d.h. Aufruf einer
                  entsprechenden Routine.

               öber die Funktion signal() kann der Programmierer in
               diesen Ablauf eingreifen - mit ihr lassen sich nicht
               nur EintrÑge der "Aktions-Tabelle" verÑndern, sondern
               auch eigene Routinen installieren.

               signal.h definiert zwei Standard-Routinen (SIG_DFL,
               SIG_IGN) und zwei "magische" Konstanten (SIG_ERR,
               SIG_SYS) zur Behandlung von Signalen. Dabei sind
               SIG_DFL und SIG_IGN sowohl Parameter als auch Ergebnis,
               SIG_SYS nur Parameter und SIG_ERR nur Ergebnis von
               signal():

               SIG_DFL  (Øsignal defaultÆ) - beendet das Programm
               SIG_IGN  (Øsignal ignoreÆ) - ignoriert das Signal,
                        das Programm wird fortgesetzt
               SIG_SYS  (Øsignal systemÆ) - setzt den Prozessor-
                        ØException-VektorÆ fÅr dieses Signal auf den
                        ursprÅnglichen Wert zurÅck, der vor dem
                        erstmaligen Aufruf von signal() gesetzt war
               SIG_ERR  (Øsignal errorÆ) - wird benutzt, um eine
                        Fehlerbedingung bei der AusfÅhrung von signal()
                        anzuzeigen (d.h. einen Fehler beim Setzen eines
                        Eintrags)

               Die momentan definierten Signaltypen zusammen mit der
               "Standard-Aktion" des Programms sind:
               1. Alle ØExceptionsÆ der 68000 CPU von Nr. 2 bis 79
                  sind fÅr signal() definiert, dabei sind die fÅr den
                  Atari relevanten als Konstanten in signal.h
                  vorhanden. Damit ist es mîglich, statt mit "Bomben"
                  individuell auf jede Fehler-Situation zu reagieren;
                  trotzdem fÅhren alle ØExceptionsÆ standardmÑûig zur
                  Åblichen Aktion: also Bomben, Betriebssystemaufruf
                  oder ØInterruptÆ-Behandlung.
                  Von ANSI Åbernommen wurden die Signale:

                  SIGSEGV  (Øsegment violationÆ) - hier: Bus-Fehler.
                  SIGILL   (Øillegal operationÆ) - hier: Illegaler Befehl.

                  ACHTUNG: Bei Bus- und Adreûfehlern ist die Adresse des 
                           folgenden Befehls nicht eindeutig feststellbar
                           (auf dem 68000), eine nochmalige AusfÅhrung des
                           fehlerhaften Befehls ist auch nicht sinnvoll,
                           daher darf eine Routine zur Behandlung dieser
                           Fehler auf keinen Fall mit rts beendet werden;
                           nur ein longjmp() oder die Terminierung des
                           Programms sind erlaubt.

                  Bei den "richtigen" ØInterruptsÆ (SIGSPURI, SIGAUTO1
                  - SIGAUTO7, SIGMFP0 - SIGMFP15) sollte man beachten,
                  da· das TOS im wesentlichen nicht reentrant ist,
                  deshalb sollten Betriebssystemaufrufe in diesen FÑllen
                  unterbleiben; auûerdem ist auf KÅrze zu achten, ANSI
                  erlaubt z.B. nur eine Zuweisung an einen "atomaren"
                  Datentyp (in signal.h als sig_atomic_t definiert).
                  Wichtig ist auch, daû der interne Handler beim Auf-
                  treten einer ØExceptionÆ erst signal(act_sig, SIG_DFL)
                  ausfÅhrt (dazu unten mehr).
                  
                  HINWEIS: Das ØInterrupt-In-ServiceÆ-Bit im MFP wird 
                           automatisch auf jeden Fall nach AusfÅhrung
                           der Benutzer-Routine gelîscht. Bestimmte MFP-
                           ØInterruptsÆ mÅssen erst mit Jenabint() ein-,
                           bzw. mit Jdisint() ausgeschaltet werden!
                  
                  2. Daneben gibt es noch vier zusÑtzlich von ANSI vorge-
                  schriebene Signale, die bis auf SIGABRT und SIGINT von
                  dieser Implementation nicht erzeugt werden.
                  Diese verhalten sich wie folgt:

                  SIGABRT  (ØabortÆ) - gibt "ABNORMAL PROGRAM TERMINA"
                           "TION" Åber GEMDOS aus und beendet das Pro-
                           gramm via _exit( 3 ). Wird auch durch abort()
                           erzeugt.
                  SIGINT   (ØinterruptÆ) - der Benutzer hat CTRL-d ge-
                           drÅckt, um das Programm zu unterbrechen;
                           beendet das Programm durch _exit( 2 ).
                  SIGFPE   (Øfloating point errorÆ) - tritt nur durch
                           raise() auf; fÅhrt zur Beendigung des Pro-
                           gramms durch _exit( 2 ).
                  SIGTERM  (ØterminationÆ) - tritt nur durch raise()
                           auf; fÅhrt zur Beendigung des Programms
                           durch _exit( 2 ).

                  3. ZusÑtzlich sind noch zwei unter UNIX Åbliche Signale
                  definiert, die standardmÑûig SIG_DFL ausfÅhren:
                  SIGALRM und SIGKILL.
               
               Der Ablauf im Detail
               Wenn eine ØExceptionÆ auftritt (d.h. die vom Prozessor
               unterstÅtzten Signale, also alle bis auf SIGINT, SIGTERM,
               SIGFPE, SIGABRT, SIGALRM und SIGKILL) wird, solange keine
               eigene Routine installiert wurde, direkt die Åbliche
               Aktion ausgefÅhrt (also Bomben, Betriebssystemaufruf,
               ØInterruptÆ-Behandlung).
               FÅr alle Signale, egal wie erzeugt, gilt:
               
               Die Laufzeitbibliothek prÅft, ob fÅr den aufgetretenen
               Signaltyp eine Behandlungsroutine installiert ist.
               - wenn nein, wird das Programm beendet, so als ob
                 SIG_DFL gesetzt ist.
               - wenn ja, dann wird der "Aktions-Eintrag" fÅr diesen
                 Signaltyp auf SIG_DFL zurÅckgesetzt und die Behand-
                 lungsroutine mit dem Signaltyp als Parameter aufge-
                 rufen - das nÑchste Signal derselben Art hat also
                 die Beendigung des Programms zur Folge.


Ergebnis       Bei fehlerfreier AusfÅhrung liefert signal() den
               vorherigen "Aktions-Eintrag" zurÅck (d.h. einen
               Zeiger auf die Routine, die zuvor als Behandlungs-
               routine fÅr dieses Signal gesetzt war). Im Falle
               eines Fehlers ist das Ergebnis von signal() der
               Zeiger SIG_ERR, errno bekommt den Wert EINVAL.

PortabilitÑt   ANSI C, UNIX

Querverweis    \#abort\#, \#_exit\#, \#longjmp\#, \#errno\#, \#raise\#,
               \#sigfunc_t\#
\end

screen( capsensitive("raise") )
Name           raise - Verschicken eines Software-Signals.

Definition     int  raise( int sig );

Prototyp in    signal.h

Beschreibung   raise schickt das Signal sig an das Program.
               Wenn das Programm eine Signal-Behandlung fÅr
               das Signal sig installiert hat, wird die Signal-
               Behandlungsroutine ausgefÅhrt. Andernfalls
               wird die \link("signal")Standardbehandlung\# durchgefÅhrt.

Ergebnis       raise liefert bei fehlerfreier AusfÅhrung den
               Wert 0 zurÅck (natÅrlich nur, wenn die dadurch
               aufgerufene Behandlungsroutine das Programm nicht
               abbricht oder an einer anderen Stelle fortsetzt);
               fÅr undefinierte Werte von sig ist das Resultat
               von Null verschieden.

Querverweis    \#abort\#, \#_exit\#, \#longjmp\#, \#errno\#, \#signal\#,
               \#sigfunc_t\#
\end

screen( capsensitive("sleep") )
Name           sleep - hÑlt die AusfÅhrung des Programms fÅr einen
               bestimmten Zeitraum an.

Definition     void  sleep( unsigned seconds );

Prototyp in    ext.h

Beschreibung   sleep hÑlt die AusfÅhrung fÅr die durch seconds
               angegebene Anzahl von Sekunden an und verwendet die Uhr
               des Systems, ist also maschinenunabhÑngig.

Ergebnis       sleep hat kein direktes Funktionsergebnis.

PortabilitÑt   Auf UNIX-Systemen verfÅgbar.

Querverweis    \#clock\#, \#delay\#
\end

screen( capsensitive("delay") )
Name           delay - wartet die angegebene Anzahl von Millisekunden.

Definition     void  delay( unsigned milliseconds );

Prototyp in    ext.h

Beschreibung   delay arbeitet im Gegensatz zu einer normalen
               Leerschleife unabhÑngig vom verwendeten Computermodell:
               beim Start des Programms wird mit Hilfe der Systemuhr
               festgestellt, wie schnell der Prozessor arbeitet, und
               ein entsprechender ZÑhler festgelegt. Dieser ZÑhler ist
               allerdings eine AnnÑherung: ein Aufruf wie
                   delay(60000);
               lÑ·t den Computer je nach Modell zwischen 59 und 61
               Sekunden warten - hundertprozentig genau ist delay also
               nicht.

Ergebnis       delay liefert keinen Wert zurÅck.

PortabilitÑt   Pure- und Turbo-C-spezifisch.

Querverweis    \#sleep\#
\end

screen( capsensitive("floor") )
Name           ØfloorÆ - rundet in Richtung auf die nÑchst-
               niedrigere ganze Zahl.

Definition     double  floor( double x );

Prototyp in    math.h

Beschreibung   floor rundet in Richtung niedrigerer Integerwerte ab:
               floor( 3.2 )   ergibt 3.0
               floor( -1.8 )  ergibt -2

Ergebnis       floor liefert ihr ganzzahliges Ergebnis als \link("%%GLOBAL%%")double\#
               zurÅck.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#ceil\#   \#abs\#
\end

screen( capsensitive("fmod") )
Name           Øfloat modulusÆ - berechnet den Restwert der
               Division x/y.

Definition     double  fmod( double x, double y );

Prototyp in    math.h

Beschreibung   fmod liefert den Rest der Division x/y zurÅck,
               berechnet also x Modulo y. Ein Aufruf mit den
               Werten 23.345 und 1 ergibt 0.345, ein Aufruf mit
               den Werten 17.4 und 10 ergibt 7.4 usw. Etwas
               mathematischer formuliert: fmod liefert den
               Wert f der Gleichung x = iy + f zurÅck, wobei
               i einen Integer darstellt und f die Bedingung
               0 <= f < y erfÅllt.

Ergebnis       fmod liefert den Divisionsrest von x/y als \link("%%GLOBAL%%")double\#.
               FÅr y = 0 erhÑlt man 0.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#modf\#
\end

screen( capsensitive("fopen") )
Name           Øfile openÆ - erîffnet eine Datei.

Definition     FILE  *fopen( const char *filename, const char *\#mode\# );

Prototyp in    stdio.h

Beschreibung   fopen erîffnet die durch filename bezeichnete Datei und
               ordnet ihr einen Stream zu. ZurÅckgeliefert wird ein
               Zeiger auf diesen Stream, Åber den weitere Operationen
               mit dieser Datei ausgefÅhrt werden kînnen.

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung einen
               Zeiger auf einen Stream zurÅck. Im Falle eines
               Fehlers wird der Wert \link("%%GLOBAL%%")NULL\# zurÅckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#   \#fclose\#   \#ferror\#   \#fread\#   \#fseek\#
               \#getc\#    \#gets\#     \#open\#     \#putc\#    \#puts\#
               \#rewind\#  \#setbuf\#   \#freopen\#  \#Fopen\#
\end

screen( "mode" )
Der Parameter mode in \#fopen\# kann einen der folgenden Werte annehmen:

"r"    READ: Erîffnung im \#Textmodus\# ausschlieûlich fÅr Lese-
       operationen - die angegebene Datei muû existieren.
"w"    WRITE: Erzeugung einer Datei im \#Textmodus\# fÅr
       Schreiboperationen - falls die Datei bereits existiert, wird
       ihr vorheriger Inhalt gelîscht.
"rb"   wie "r", jedoch im \#BinÑrmodus\#
"wb"   wie "w", jedoch im \#BinÑrmodus\#
"a"    APPEND: Erîffnung fÅr Schreiboperationen. Falls die Datei
       bereits existiert, werden zusÑtzliche Informationen an das
       momentane Dateiende angefÅgt, ansonsten wird sie automatisch
       erzeugt.
"r+"   Erîffnung einer Datei fÅr Lese- und Schreiboperationen - die
       Datei muû bereits existieren.
"w+"   Erîffnung einer neuen Datei fÅr Lese- und Schreiboperationen.
       Falls die Datei bereits existiert, wird ihr vorheriger Inhalt
       gelîscht.
"a+"   Erîffnung einer Datei zum Lesen und ØAnhÑngenÆ neuer Daten
       durch Schreiboperationen. Falls die Datei bereits existiert,
       bleibt ihr alter Inhalt erhalten - falls nicht, wird sie
       automatisch erzeugt.

Mit r+ und w+ erîffnete Dateien kînnen sowohl gelesen als auch
beschrieben werden - zwischen einem Wechsel von ØLesenÆ nach
ØSchreibenÆ und umgekehrt muû allerdings ein \#fseek\# oder \#rewind\#
stattfinden.
Leseoperationen, bei denen das Dateiende erreicht wird, bilden eine
Ausnahme: hier kann direkt eine Schreiboperation folgen.Der vorherige
Inhalt von mit a oder a+ erîffneten Dateien ist gegen
Schreiboperationen geschÅtzt - ein rewind oder fseek ist zwar mîglich,
jede Schreiboperation setzt die momentane Position aber automatisch
wieder auf das momentane Dateiende. Anders gesagt:
Neu geschriebene Daten werden grundsÑtzlich angehÑngt - zum
öberschreiben bereits existierender DatensÑtze muû die Datei mit r+
erîffnet werden.

Querverweis     \#fopen\#   \#freopen\#
\end

screen( "Textmodus",
		"BinÑrmodus" )
StandardmÑûig ist bei \#fopen\# der Textmodus eingestellt.
Wenn im String der zusÑtzliche Parameter b erscheint,
wird die Datei im BinÑrmodus erîffnet. Das bedeutet, daû die
standardmÑûige öbersetzung von CR/LF-Kombinationen in '\\n', wie sie
im Text-Modus vorgenommen wird, nicht stattfindet.

Textmodus:     $0D (CR) wird nicht gelesen.
               FÅr jedes $0A (LF) wird $0D0A (CR LF) geschrieben.
BinÑrmodus:    Es wird Byte fÅr Byte gelesen und geschrieben.

Querverweis    \#fopen\#   \#freopen\#
\end

screen( capsensitive("fprintf") )
Name           Øfile print formattedÆ - formatierte Ausgabe zu einer
               Datei.

Definition     int  fprintf( FILE *stream, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ØdruckenÆ in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (Øfile printfÆ) - wie \#printf\#, die Ausgabe geschieht
               in den angegebenen Stream

Ergebnis       SÑmtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurÅck.
               Im Falle eines Fehlers ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fread\#    \#putc\#      \#puts\#       \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#  \#vsprintf\#   \#sprintf\#
\end

screen( capsensitive("fputc") )
Name           Øfile put characterÆ - Ausgabe eines Zeichens
               zu einer Datei.

Definition     int  fputc( int ch, FILE *fp );

Prototyp in    stdio.h

Beschreibung   Die Funktion fputc gibt das Zeichen ch zu dem durch fp
               angegebenen stream aus.

Ergebnis       fputc liefert das Åbergebene Zeichen ch auch als
               Funktionsergebnis zurÅck. Im Falle eines Fehlers
               liefert die Funktionen den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#   \#fopen\#    \#fread\#   \#getc\#     \#printf\#
               \#puts\#     \#setbuf\#   \#putc\#    \#putchar\#  \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("fputs") )
Name           Øfile put stringÆ - Ausgabe eines Strings zu einer
               Datei.

Definition     int  fputs( const char *s, FILE *fp );

Prototyp in    stdio.h

Beschreibung   fputs schreibt den nullterminierten String s in den
               via fp angegebenen stream, wobei kein automatischer
               Zeilenvorschub angehÑngt wird und das abschlieûende
               Null-Byte des Strings nicht kopiert wird.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert fputs den Wert
               des zuletzt geschriebenen Zeichens zurÅck. Im Falle
               eines Fehlers liefert die Funktion den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#puts\#   \#ferror\#   \#fopen\#   \#fread\#   \#gets\#
               \#open\#   \#printf\#   \#putc\#    \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("fread") )
Name           Øfile readÆ - liest Daten von einer Datei.

Definition     size_t  fread( void *ptr, size_t elem_Size,
                               size_t count, FILE *stream );

Prototyp in    stdio.h

Beschreibung   fread liest count Datenelemente, die jeweils die Grîûe
               elem_Size haben, von der durch stream bezeichneten
               Datei in den Speicherbereich, auf den ptr zeigt.
               Die Funktionen liest count * elem_Size Bytes. ptr kann
               auf beliebige Datenkonstrukte (typischerweise Arrays)
               zeigen - solange es sich um einen typisierten Zeiger
               handelt, ist die Angabe von elem_Size durch
               sizeof(*ptr) mîglich.

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung
               die Anzahl der gelesenen Elemente (nicht: Bytes)
               zurÅck. Im Falle eines Fehlers oder dem Erreichen
               des Dateiendes, wird die Anzahl von Elementen zurÅck-
               geliefert, die noch fehlerfrei gelesen werden konnte.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fwrite\#   \#fopen\#   \#fgetc\#   \#gets\#    \#printf\#
               \#putc\#     \#puts\#    \#read\#    \#scanf\#   \#write\#
               \#size_t\#   \#Fread\#
\end

screen( capsensitive("free") )
Name           ØfreeÆ - gibt einen dynamisch belegten Speicherblock
               wieder frei.

Definition     void  free( void *ptr );

Prototyp in    stdlib.h

Beschreibung   free gibt einen zuvor mit \#malloc\#, \#calloc\# oder
               \#realloc\# belegten Block wieder frei, wobei der
               Åbergebene Zeiger ptr auf die Startadresse dieses
               Bereichs zeigen muû.

Ergebnis       free hat kein direktes Funktionsergebnis.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#setbuf\#
\end

screen( capsensitive("freopen") )
Name           Øfile re-openÆ - wechselt die einem stream zugeordnete
               Datei.

Definition     FILE  *freopen( const char *filename, const char *\#mode\#,
                                FILE *stream );

Prototyp in    stdio.h

Beschreibung   freopen erîffnet die durch filename angegebene Datei
               und ordnet sie der Datei stream zu. Anders gesagt:
               freopen wechselt die stream zugeordnete Datei.
               In den meisten FÑllen wird diese Funktion auf stdin,
               stdout und stderr zur Umleitung von Ein-/Ausgaben
               verwendet.
               Achtung: Die ØalteÆ Datei wird immer geschlossen
                        - unabhÑngig davon, ob die Erîffnung der
                        neuen Datei fehlerfrei verlÑuft oder nicht.

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung einen
               Zeiger auf einen stream zurÅck (der identisch mit dem
               alten stream ist). Im Falle eines Fehlers wird der
               Wert \link("%%GLOBAL%%")NULL\# zurÅckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#    \#fclose\#   \#ferror\#   \#fread\#   \#fseek\#
               \#getc\#     \#gets\#     \#open\#     \#putc\#    \#puts\#
               \#rewind\#   \#setbuf\#   \#fopen\#
\end

screen( capsensitive("frexp") )
Name           Øfloat remnant/exponentÆ - liefert die Mantisse und
               den binÑren Exponenten einer Flieûkommazahl in zwei
               getrennten Werten zurÅck.

Definition     double  frexp( double value, int *exponent );

Prototyp in    math.h

Beschreibung   frexp berechnet aus value eine Mantisse x
               (absoluter Wert grîûer 0.5 und kleiner 1.0) zusammen
               mit einen Eponenten der Basis 2, bildet also eine
               (binÑr) normalisierte Flieûkommazahl. Anders gesagt:
               frexp erfÅllt die Gleichung value = x * 2 ^ n.

Ergebnis       Die Mantisse x wird als Funktionsergebnis zurÅck-
               geliefert.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("fscanf") )
Name           Øfile scan formattedÆ - formatiertes Lesen einer
               Datei.

Definition     int  fscanf( FILE *stream, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   fscanf liest stream in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               Åber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       fscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurÅck, wobei mit *
               unterdrÅckte Felder nicht gezÑhlt werden.
               Wenn Åberhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, Åber das Ende einer Datei bzw. Åber das
               Ende eines Strings hinaus zulesen (\#sscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#sscanf\#  \#vfscanf\#
\end

screen( capsensitive("vfscanf") )
Name           Øfile scan formattedÆ - formatiertes Lesen einer
               Datei.

Definition     #include <stdarg.h>
               int  vfscanf( FILE *stream, const char *format,
                             \#va_list\# param );

Prototyp in    stdio.h

Beschreibung   Die v...scanf-Funktionen verhalten sich Ñhnlich wie
               ihre ...scanf-GegenstÅcke, sie akzeptieren jedoch
               einen Pointer auf eine Liste von Argumenten anstelle
               der Liste selber.
               vfscanf liest stream in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               Åber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert.

Ergebnis       vfscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurÅck, wobei mit *
               unterdrÅckte Felder nicht gezÑhlt werden.
               Wenn Åberhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, Åber das Ende einer Datei bzw. Åber das
               Ende eines Strings hinaus zulesen (\#sscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

PortabilitÑt   vfscanf ist auf UNIX-Systemen verfÅgbar.

Gruppe         \#I/O-Routinen\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#sscanf\#  \#fscanf\#
\end

screen( capsensitive("fseek") )
Name           Øfile seekÆ - setzt die momentane Position
               innerhalb einer Datei fÅr folgende Lese und/oder
               Schreibaktionen.

Definition     int  fseek( FILE *stream, long offset, int mode );

Prototyp in    stdio.h

Beschreibung   fseek setzt innerhalb der durch stream bezeichneten
               Datei die Position. Der Parameter offset gibt jeweils
               die zu setzende Entfernung in Bytes an, die Art der
               Positionierung wird Åber drei in stdio.h definierte
               Konstanten fÅr mode festgelegt:

               SEEK_SET  (Wert 0) - relativ zum Dateianfang.
               SEEK_CUR  (Wert 1) - relativ zur vorherigen Position.
               SEEK_END  (Wert 2) - relativ zum Dateiende.

               In Dateien, die fÅr Lese- und Schreiboperationen
               erîffnet worden sind, kann nach fseek zwischen
               ØLesenÆ und ØSchreibenÆ gewechselt werden. Mit
               \#ungetc\# zurÅckgestellte Zeichen sind nach fseek
               nicht mehr erreichbar.

PortabilitÑt   fseek ist auf allen UNIX-Systemen verfÅgbar und in
               ANSI C definiert.

Ergebnis       fseek liefert bei fehlerfreier AusfÅhrung den Wert 0
               zurÅck, ansonsten einen Wert ungleich 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#getc\#   \#lseek\#   \#setbuf\#   \#ungetc\#
               \#Fseek\#
\end

screen( capsensitive("fsetpos") )
Name           Øfile set positionÆ - Datei-Position auf alten
               Wert zurÅcksetzen.

Definition     int  fsetpos( FILE *stream, fpos_t *pos );

Prototyp in    stdio.h

Beschreibung   Die Funktion fsetpos setzt den Datei-Zeiger der Datei
               stream auf eine mit \#fgetpos\# gespeicherte Position pos.
               Das End-Of-File-Flag wird gelîscht. Mit \#ungetc\#
               zurÅckgestellte Zeichen sind nach fsetpos nicht mehr
               erreichbar.

Ergebnis       Die Funktion liefert den Wert 0, wenn die Datei-Position
               ermittelt werden konnte, ansonsten einen Fehlercode.
               \#errno\# wird auf einen Wert ungleich 0 gesetzt.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fgetpos\#
\end

screen( capsensitive("ftell") )
Name           Øfile tellÆ - ermittelt die momentane Position
               innerhalb einer Datei.

Definition     long  ftell( FILE *stream );

Prototyp in    stdio.h

Beschreibung   ftell liefert die momentane Position innerhalb der
               durch stream bezeichneten Datei zurÅck (relativ
               zum Dateianfang, ZÑhlung in einzelnen Bytes).

Ergebnis       Im BinÑrmodus liefert ftell die momentane Position
               innerhalb der angegebenen Datei als long zurÅck, im
               Textmodus jedoch nur eine "magic number", die nur fÅr
               \#fseek\# verwendet werden kann.
               Falls sich bei dieser Operation ein Fehler ereignen
               sollte, hat das Funktionsergebnis den Wert -1L und
               \#errno\# erhÑlt einen positiven Wert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fseek\#   \#rewind\#
\end

screen( capsensitive("fwrite") )
Name           Øfile writeÆ - schreibt Daten in eine Datei.

Definition     size_t  fwrite( const void *ptr, size_t elem_Size,
                                size_t count, FILE *stream );

Prototyp in    stdio.h

Beschreibung   fwrite ist das GegenstÅck zu \#fread\# und schreibt
               count Datenelemente mit jeweils elem_Size Bytes (die
               von einem Speicherbereich gelesen werden, dessen
               Startadresse durch ptr gegeben ist). Die Funktion
               schreibt count * elem_Size Bytes. ptr kann auf
               beliebige Datenkonstrukte (typischerweise Arrays)
               zeigen - solange es sich um einen typisierten Zeiger
               handelt, ist die Angabe von elem_Size durch
               \link("%%GLOBAL%%")sizeof\#(*ptr) mîglich.

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung die
               Anzahl der geschriebenen Elemente (nicht: Bytes)
               zurÅck. Im Falle eines Fehlers, wird die Anzahl von
               Elementen zurÅckgeliefert, die noch fehlerfrei
               geschrieben werden konnten.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fread\#   \#fopen\#   \#fgetc\#   \#gets\#    \#printf\#
               \#putc\#    \#puts\#    \#read\#    \#scanf\#   \#write\#
               \#size_t\#   \#Fwrite\#
\end

screen( capsensitive("getc") )
Name           Øget characterÆ - liest ein Zeichen von einem stream.

Definition     int  getc( FILE *stream );

Prototyp in    stdio.h

Beschreibung   getc ist ein Makro, der das jeweils nÑchste Zeichen aus
               der durch stream bezeichneten Datei liest und
               zurÅckliefert.

Ergebnis       getc liefert bei fehlerfreier AusfÅhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurÅck, wobei keine Vorzeichen-
               erweiterung stattfindet.
               Bei öberschreitung des Dateiendes (beim Lesen der
               Tastatur: der Eingabe von control-z) wird der Wert
               EOF zurÅckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ungetc\#   \#ferror\#   \#fopen\#   \#fread\#   \#fseek\#
               \#gets\#     \#putc\#     \#read\#    \#scanf\#   \#getchar\#
               \#getch\#    \#getche\#   \#fgetc\#
\end

screen( capsensitive("getch") )
Name           Øget characterÆ - liest ein Zeichen von der Tastatur.

Definition     int  getch( void );

Prototyp in    ext.h

Beschreibung   getch liest ein Zeichen von der Tastatur, ohne es auf
               dem Bildschirm auszugeben.

Ergebnis       getch liefert bei fehlerfreier AusfÅhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurÅck, wobei keine Vorzeichen-
               erweiterung stattfindet.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getc\#    \#getche\#   \#fgetc\#   \#ungetc\#   \#ferror\#
               \#fopen\#   \#fread\#   \#fseek\#    \#gets\#     \#putc\#
               \#read\#    \#scanf\#
\end

screen( capsensitive("getchar") )
Name           Øget characterÆ - liest ein Zeichen von stdin.

Definition     int  getchar( void );

Prototyp in    stdio.h

Beschreibung   getchar ist ein Makro, das schlicht als getc(stdin)
               definiert ist. getchar liest das jeweils nÑchste
               Zeichen aus stdin.

Ergebnis       getchar liefert bei fehlerfreier AusfÅhrung das
               gelesene Zeichen als \link("%%GLOBAL%%")int\# zurÅck, wobei keine
               Vorzeichenerweiterung stattfindet.
               Bei öberschreitung des Dateiendes (beim Lesen der
               Tastatur: der Eingabe von control-z) wird der Wert
               EOF zurÅckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#getc\#    \#fgetc\#   \#getch\#   \#getche\#   \#ungetc\#
               \#ferror\#  \#fopen\#   \#fread\#   \#fseek\#    \#gets\#
               \#putc\#    \#read\#    \#scanf\#
\end

screen( capsensitive("getche") )
Name           Øget characterÆ - liest ein Zeichen von der Tastatur
               und gibt es auf dem Bildschirm aus.

Definition     int  getche( void );

Prototyp in    ext.h

Beschreibung   getche liest ein Zeichen von der Tastatur und gibt es
               auf dem Bildschirm aus.

Ergebnis       getch liefert bei fehlerfreier AusfÅhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurÅck, wobei keine Vorzeichen-
               erweiterung stattfindet.
               Bei öberschreitung des Dateiendes (beim Lesen der
               Tastatur: der Eingabe  von control-z) wird der Wert
               EOF zurÅckgeliefert.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getc\#    \#getch\#    \#fgetc\#   \#ungetc\#   \#ferror\#
               \#fopen\#   \#fread\#   \#fseek\#    \#gets\#     \#putc\#
               \#read\#    \#scanf\#
\end

screen( capsensitive("getdate") )
Name           Øget dateÆ - ermittelt das aktuelle Tagesdatum.

Definition     void  getdate( struct date *dateRec );

Prototyp in    ext.h

Beschreibung   Die Funktion getdate ermittelt das aktuelle Tagesdatum.
               Das Datum wird in der Struktur \#date\# dateRec Åbergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#   \#ctime\#   \#setdate\#
\end

screen( capsensitive("getenv") )
Name           Øget environmentÆ - liest einen Eintrag aus der
               Tabelle Environment.

Definition     char  *getenv( const char *name );

Prototyp in    stdlib.h

Beschreibung   Die vom Betriebssytem eingerichtete Tabelle Environment
               besteht aus einer (unsortierten) Folge von EintrÑgen
               der Form:

               name=Zeichenfolge

               Der ØbekanntesteÆ Eintrag dÅrfte PATH (Suchwege fÅr
               ausfÅhrbare Programme) sein.
               getenv sucht die Tabelle nach dem Åber name
               angegebenen Eintrag ab und liefert einen Zeiger auf
               Zeichenfolge zurÅck.
               Hinweis: der von getenv zurÅckgelieferte Zeiger
               sollte nicht zur direkten VerÑnderung von Environment-
               EintrÑgen verwendet werden.

Ergebnis       getenv liefert einen Zeiger auf die zu name gehîrende
               Zeichenfolge zurÅck. Falls kein Eintrag des Namens
               name gefunden werden konnte, liefert getenv \link("%%GLOBAL%%")NULL\#.

Gruppe         \#Verschiedene Routinen\#
\end

screen( capsensitive("getftime") )
Name           Øget file timeÆ - liest Datum und Uhrzeit einer
               offenen Datei.

Definition     int  getftime( int handle, struct ftime *ftimep );

Prototyp in    ext.h

Beschreibung   getftime ermittelt Datum und Uhrzeit der durch handle
               bezeichneten (offenen) Datei. Datum und Uhrzeit werden
               durch die Struktur \#ftime\# beschrieben.

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung den
               Wert 0. Wenn der angegebene handle nicht existiert
               (d.h. keine entsprechende Datei offen ist), liefert
               getftime den Wert -1 als Ergebnis, \#errno\# bekommt den
               Wert EBADF oder EINVFNC.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#setftime\#
\end

screen( capsensitive("ftimtotm") )
Name           Øftime format to tm formatÆ - Konvertiert den Inhalt
               einer ftime-Struktur in eine tm-Struktur.

Definition     struct tm  *ftimtotm( struct ftime *f );

Prototyp in    ext.h

Beschreibung   ftimtotm konvertiert den Inhalt der Struktur vom
               Typ \#ftime\#, auf die f zeigt in das Format einer
               Struktur vom Typ \#tm\#.

Ergebnis       Die Funktion liefert einen Zeiger auf eine \#tm\#-Struktur.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getftime\#       \#asctime\#
\end

screen( capsensitive("gets") )
Name           Øget stringÆ - liest einen String.

Definition     char  *gets( char *str );

Prototyp in    stdio.h

Beschreibung   Die Funktion gets liest eine Zeichenfolge von der
               Standard-Datei stdin und speichert ihn in der durch
               str angegebenen Stringvariablen. Die Eingabe wird
               durch einen Zeilenvorschub beendet, der in *str
               als Nullzeichen () gespeichert wird.

Ergebnis       gets liefert bei fehlerfreier AusfÅhrung
               einen Zeiger auf str zurÅck. Wenn beim Lesen das
               Dateiende Åberschritten wird oder ein Fehler auftritt,
               ist das Funktionsergebnis \link("%%GLOBAL%%")NULL\#.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fgets\#   \#ferror\#   \#fopen\#   \#fread\#   \#getc\#
               \#puts\#    \#scanf\#
\end

screen( capsensitive("gettime") )
Name           Øget timeÆ - ermittelt die Uhrzeit des Systems.

Definition     void  gettime( struct time *timeRec );

Prototyp in    ext.h

Beschreibung   Die Funktion gettime ermittelt die aktuelle Uhrzeit.
               Die Uhrzeit wird in der Struktur \#time\# Åbergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#   \#ctime\#   \#settime\#   \#Gettime\#
\end

screen( capsensitive("isatty") )
Name           Øis a teletypeÆ - prÅft, ob ein GerÑt zeichen- oder
               blockorientiert arbeitet.

Definition     int  isatty( int handle );

Prototyp in    ext.h

Ergebnis       Die Funktion liefert ein Ergebnis ungleich 0, wenn
               das Åber handle adressierte GerÑt zeichenorientiert
               arbeitet.

Gruppe         \#Pure-C-Spezialfunktionen\#
\end

screen( capsensitive("gmtime") )
Name           ØGreenwich Mean TimeÆ - rechnet Datum und Uhrzeit
               in die internationale Standardzeit um.

Definition     struct tm  *gmtime( time_t *clock );

Prototyp in    time.h

Beschreibung   gmtime konvertiert direkt in die international
               gÅltige Greenwich Mean Time (ØGMTÆ).
               Die globale long-Variable timezone enthÑlt den
               Unterschied zwischen der lokalen Zeit und der GMT in
               Sekunden. Die globale Variable daylight darf nur dann
               auf einen Wert ungleich Null gesetzt werden, wenn die
               Standardwerte der USA fÅr Sommer- und Winterzeit
               angewendet werden kînnen. Die Funktion arbeitet mit
               einer Tabelle, die die Zeitkorrekturen der Jahre 1974
               und 1975 enthÑlt - falls nîtig, kann diese Tabelle
               entsprechend vergrîûert werden. Der Strukturtyp \#tm\#
               ist in time.h definiert.

Ergebnis       gmtime liefert einen Zeiger auf eine  statische
               Struktur, die durch jeden Aufruf dieser Funktion
               erneut gesetzt wird.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#localtime\#   \#getdate\#   \#time\#   \#time_t\#
\end

screen( capsensitive("isalpha") )
Name           ØisalphaÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isalpha( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein Buchstabe ( a..z, A..Z ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isalnum") )
Name           ØisalnumÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isalnum( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein Buchstabe oder eine Ziffer ( a..z, A..Z, 0..9 )
               ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isascii") )
Name           ØisasciiÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isascii( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein ASCII-Zeichen ( 0x00..0x7F ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("iscntrl") )
Name           ØiscntrlÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  iscntrl( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein Control-Zeichen ( 0x00..0x1F, 0x7F ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isdigit") )
Name           ØisdigitÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isdigit( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               eine Ziffer ( 0..9 ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isgraph") )
Name           ØisgraphÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isgraph( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein druckbares Zeichen ( 0x21..0x7E ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("islower") )
Name           ØislowerÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  islower( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein kleingeschriebener Buchstabe ( a..z ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isodigit") )
Name           ØisodigitÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isodigit( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               eine Oktalziffer ( 0..7 ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.
Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isprint") )
Name           ØisprintÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isprint( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein druckbares Zeichen ( 0x20..0x7E ) ist. isprint
               verhÑlt sich also quasi wie isgraph, mit der Aus-
               nahme, daû hier das Leerzeichen ebenfalls als
               druckbar anerkannt wird.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("ispunct") )
Name           ØispunctÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  ispunct( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein Punktierungszeichen ist. Dies ist der Fall, wenn
               entweder iscntrl oder isspace wahr ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isspace") )
Name           ØisspaceÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isspace( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein Leerzeichen, Tabulator, Zeilen- oder Seitenvor-
               schub ( 0x09..0x0D, 0x20 ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isupper") )
Name           ØisupperÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isupper( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               ein Groûbuchstabe ( A..Z ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isxdigit") )
Name           ØisxdigitÆ - Funktion zur Klassifizierung von Zeichen.

Definition     int  isxdigit( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prÅft, ob das Åbergebene Zeichen c
               eine Hexadezimalziffer ( 0..9, A..F, a..f ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurÅckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("itoa") )
Name           Øinteger to asciiÆ konvertiert einen Integer in einen
               String.

Definition     char  *itoa( int value, char *string, int radix );

Prototyp in    stdlib.h

Beschreibung   itoa konvertiert den Integer value in einen
               nullterminierten String und speichert das Ergebnis
               in der durch String bezeichneten Variablen.
               Der Parameter radix legt die Basis fest auf der die
               konvertierung stattfinden soll - mîgliche Werte
               liegen im Bereich von 2 bis 36.
               itoa erzeugt maximal 16 Zeichen.

Ergebnis       itoa liefert einen Zeiger auf den gesetzten string
               zurÅck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#ltoa\#   \#ultoa\#
\end

screen( capsensitive("kbhit") )
Name           Økeyboard hitÆ - prÅft, ob eine Taste gedrÅckt wurde.

Definition     int  kbhit( void );

Prototyp in    ext.h

Beschreibung   kbhit prÅft, ob ein Zeichen Åber die Tastatur
               eingegeben wurde.

Ergebnis       Wenn eine noch nicht gelesene Eingabe vorliegt,
               liefert kbhit einen Wert ungleich Null, das Zeichen
               kann via \#getch\# gelesen werden. Liegt kein Zeichen
               an, dann liefert kbhit den Wert 0.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getc\#
\end

screen( capsensitive("labs") )
Name           Ølong absoluteÆ - liefert den absoluten Wert eines
               long.

Definition     long  labs( long n );

Prototyp in    stdlib.h

Beschreibung   labs liefert den absoluten Wert des \link("%%GLOBAL%%")long\#-Arguments
               n zurÅck.
               Es handelt es sich um einen ØechtenÆ Funktionsaufruf.

Ergebnis       labs liefert den Absolutwert des long-Arguments n.
               Fehlerbedingungen sind nicht definiert.

Gruppe         \#Mathematische Routinen\#

Querverweis:   \#abs\#   \#fabs\#
\end

screen( capsensitive("ldexp") )
Name           Ølog double expÆ - berechnet value * 2exp.

Definition     double  ldexp( double value, int exp );

Prototyp in    math.h

Beschreibung   ldexp liefert das Ergebnis der Berechnung value = 2 ^
               exponent zurÅck, ist  also das GegenstÅck zu \#frexp\#.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#exp\#
\end

screen( capsensitive("ldiv") )
Name           Ølong divisionÆ - berechnet den Rest und den Quotient
               von zwei long-Zahlen.

Definition     \#ldiv_t\#  ldiv( long n, long d );

Prototyp in    stdlib.h

Beschreibung   Die Funktion ldiv berechnet gleichzeitig Quotienten und
               Rest einer Division von zwei long-Zahlen.

Ergebnis       Das Ergebnis wird in der Struktur \#ldiv_t\# abgelegt.

Gruppe         \#Mathematische Routinen\#
\end

screen( capsensitive("localtime") )
Name           Ølocal timeÆ - konvertiert Datum/Uhrzeit in eine
                Struktur des Typs \#tm\#.

Definition     struct tm  *localtime( time_t *clock );

Prototyp in    time.h

Beschreibung   localtime konvertiert direkt in die international
               gÅltige Greenwich Mean Time (ØGMTÆ), und
               berÅcksichtigt Zeitzonen und die Sommerzeit.
               Die globale long-Variable timezone enthÑlt den
               Unterschied zwischen der lokalen Zeit und der GMT in
               Sekunden. Die globale Variable daylight darf nur dann
               auf einen Wert ungleich Null gesetzt werden, wenn die
               Standardwerte der USA fÅr Sommer- und Winterzeit
               angewendet werden kînnen. Die Funktion arbeitet mit
               einer Tabelle, die die Zeitkorrekturen der Jahre 1974
               und 1975 enthÑlt - falls nîtig, kann diese Tabelle
               entsprechend vergrîûert werden. Der Strukturtyp \#tm\#
               ist in time.h definiert.

Ergebnis       localtime liefert einen Zeiger auf eine statische
               Struktur, die durch jeden Aufruf dieser Funktion
               erneut gesetzt wird.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#getdate\#   \#time\#   \#time_t\#   \#gmtime\#
\end

screen( capsensitive("log") )
Name           ØlogarithmÆ - berechnet den natÅrlichen Logarithmus des
               Arguments.

Definition     double  log( double x );

Prototyp in    math.h

Beschreibung   log liefert den natÅrlichen Logarithmis n des
               Argumentes x zurÅck, erfÅllt also die Gleichung
               x = e ^ n und ist die Umkehrfunktion von \#exp\#.

Ergebnis       Bei einem öberlauf liefert log HUGE_VAL und setzt
               \#errno\# auf den Wert ERANGE. Wenn x kleiner Null
               ist wird errno auf EDOM gesetzt. FÅr x gleich Null
               erhÑlt man als Resultat minus HUGEVAL und errno
               wird ERANGE zugewiesen.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#log10\#
\end

screen( capsensitive("log10") )
Name           Ølogarithm 10Æ - berechnet den Logarithmus des
               Arguments zur Basis 10.

Definition     double  log10( double x );

Prototyp in    math.h

Beschreibung   log10 berechnet den Logarithmus n des Argumentes x
               zur Basis 10, erfÅllt also die Gleichung x = 10 ^ n.

Ergebnis       Bei einem öberlauf liefert log HUGE_VAL und setzt
               \#errno\# auf den Wert ERANGE. Wenn x kleiner Null
               ist wird errno auf EDOM gesetzt. FÅr x gleich Null
               erhÑlt man als Resultat minus HUGEVAL und errno
               wird ERANGE zugewiesen.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#log\#   \#exp\#
\end

screen( capsensitive("longjmp") )
Name           Ølong jumpÆ - fÅhrt ein Ønicht-lokalesÆ goto aus.

Definition     void  longjmp( jmp_buf env, int value );

Prototyp in    setjmp.h

Beschreibung   Ein Aufruf von longjmp stellt den Zustand wieder her,
               der durch \#setjmp\# gespeichert wurde.
               - der Prozessor setzt die Arbeit an der Stelle fort,
               an der sich der Aufruf von \#setjmp\# befindet.
               Um mit longjmp zu einem Punkt x zu springen, mÅssen
               die folgenden Schritte ausgefÅhrt werden:

               ˘ Deklaration einer globalen Variablen vom Typ jmp_buf,
                 die durch setjmp mit den entsprechenden Register-
                 Inhalten geladen wird.
               ˘ AusfÅhrung von setjmp am Punkt x - also an dem Punkt,
                 zu dem hinterher gesprungen werden soll.

Ergebnis       Der ØAufrufÆ von \#setjmp\# via longjmp setzt das
               Funktionsergebnis von setjmp auf den Wert von value -
               wenn fÅr value 0 angegeben ist, dann verwendet Pure C
               automatisch den Wert 1.

Gruppe         \#SprÅnge\#

Querverweis    \#setjmp\#
\end

screen( capsensitive("lseek") )
Name           Ølong seekÆ - setzt die momentane Position innerhalb
               einer Datei.

Definition     size_t  lseek( int handle, size_t offset, int whence );

Prototyp in    stdio.h

Beschreibung   lseek entspricht exakt der Funktion fseek - nur daû
               hier nicht mit einem Stream, sondern mit einem Handle
               gearbeitet wird. Der Parameter offset gibt jeweils
               die zu setzende Entfernung in Bytes an, die Art der
               Positionierung wird Åber drei in stdio.h definierte
               Konstanten fÅr whence festgelegt:
                    SEEK_SET  0    - relativ zum Dateianfang.
                                     Wenn offset den Wert 0 hat,
                                     wird die Position auf das
                                     erste Byte des Dateiinhalts
                                     gesetzt.
                    SEEK_CUR  1    - relativ zur vorherigen Position.
                                     Negative Werte von offset
                                     verschieben in Richtung
                                     Dateianfang.
                    SEEK_END  2    - relativ zum Dateiende. Wenn
                                     offset den Wert 0 hat, wird
                                     die Position auf das Dateiende
                                     gesetzt.
PortabilitÑt   lseek ist auf allen UNIX-Systemen verfÅgbar.

Ergebnis       lseek liefert bei fehlerfreier AusfÅhrung die neue
               Position innerhalb der Datei gemessen in Bytes.
               Bei Anwendung auf GerÑtedateien (wie Terminals,
               Schnittstellen usw.) ist das Funktionsergebnis
               undefiniert. Im Falle eines Fehlers wird der Wert -1
               zurÅckgeliefert, \#errno\# bekommt einen der folgenden
               Werte:
                       EBADF    EINVAL

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#fseek\#   \#getc\#   \#setbuf\#   \#ungetc\#
\end

screen( capsensitive("ltoa") )
Name           Ølong to asciiÆ konvertiert einen long in einen
               String.

Definition     char  *ltoa( long value, char *string, int radix );

Prototyp in    stdlib.h

Beschreibung   ltoa konvertiert den long value in einen
               nullterminierten String und speichert das Ergebnis
               in der durch String bezeichneten Variablen.
               Der Parameter radix legt die Basis fest auf der die
               konvertierung stattfinden soll - mîgliche Werte
               liegen im Bereich von 2 bis 36.
               ltoa erzeugt maximal 32 Zeichen.

Ergebnis       ltoa liefert einen Zeiger auf den gesetzten string
               zurÅck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#itoa\#   \#ultoa\#
\end

screen( capsensitive("malloc") )
Name           Ømemory allocationÆ - Reservierung von Speicherplatz

Definition     void  *malloc( size_t size );

Prototyp in    stdlib.h

Beschreibung   öber diese Funktion wird der Heap verwaltet.
               malloc belegt einen Speicherbereich von size Bytes auf
               dem Heap und liefert einen Zeiger zurÅck, der auf die
               Startadresse des neu belegten Bereichs zeigt. Eine
               Initialisierung der durch malloc belegten Speicher-
               zellen findet nicht statt.

Ergebnis       malloc liefert einen typenlosen Zeiger, der explizit
               auf den verwendeten Zeigertyp konvertiert werden sollte.
               Wenn kein Speicherbereich ausreichender Grîûe zur
               VerfÅgung steht, dann ist das Funktionsergebnis \link("%%GLOBAL%%")NULL\#,
               es findet keine Belegung statt.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#setbuf\#   \#calloc\#   \#realloc\#   \#free\#   \#size_t\#
               \#Malloc\#
\end

screen( capsensitive("setmatherr") )
Name           Øset math errorÆ - setzt eine Routine zur Behandlung
               von Flieûkommafehlern.

Definition     void  setmatherr( int (*errorfunc)(struct exception *e ));

Prototyp in    math.h

Beschreibung   setmatherr setzt eine vom Programmierer frei
               definierbare Routine, die bei Auftreten eines
               Flieûkommafehlers angsprungen werden soll. Diese
               Routine kînnte beispielsweise die exception struktur,
               die bei solch einem Fehler angelegt wird, auswerten.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#exception\#   \#errno\#
\end

screen( capsensitive("offsetof") )
Name           Øoffset ofÆ - ermittelt den Offset eines Strukturele-
               ments.

Definition     size_t  offsetof( type, identifier );

Prototyp in    stddef.h

Beschreibung   offsetof ermittelt den Abstand eines Strukturelements
               vom Strukturanfang.

Ergebnis       Die Funktion liefert den Abstand in Bytes. Falls es
               sich bei identifier um ein Bitfeld handelt, ist das
               Ergebnis undefiniert.

Gruppe         \#Verschiedene Routinen\#
\end

screen( capsensitive("memchr") )
Name           Ømemory characterÆ - Sucht den Speicher nach einem
               Zeichen ab.

Definition     void  *memchr( const void *s, int val, size_t len );

Prototyp in    string.h

Beschreibung   memchr sucht die ersten len Bytes des Arrays s nach dem
               Wert val ab.

Ergebnis       memchr liefert die Adresse der ersten Fundstelle von c
               im Array s zurÅck - oder \link("%%GLOBAL%%")NULL\#, wenn c innerhalb der
               ersten len Bytes von s nicht vorkommt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memcmp") )
Name           Ømemory compareÆ - Speicher vergleichen.

Definition     int  memcmp( const void *s1, const void *s2, size_t len );

Prototyp in    string.h

Beschreibung   memcmp vergleicht die ersten len Bytes der Arrays s1
               und s2 miteinander. memcmp behandelt die Bytes als
               unsigned char (der Wert 0xFF ist also grîûer als
               0x7F).

Ergebnis       memcmp bricht den Vergleich beim ersten nicht
               Åbereinstimmenden Zeichen ab.
               Das Vergleichsergebnis wird als int zurÅckgeliefert:
                <0  wenn s1 kleiner als s2 ist
                0 wenn die ersten n Zeichen von s1 und s2 gleich sind
                >0  wenn s1 grîûer als s2 ist

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memmove") )
Name           Ømemory moveÆ - Speicherbereiche kopieren

Definition     void  *memmove( void *dest, const void *src, size_t len );

Prototyp in    string.h

Beschreibung   memmove kopiert len Bytes von src nach dest und
               berÅcksichtigt mîgliche öberlappungen von Quell-
               und Zielgebiet automatisch.
               memmove ist identisch mit \#memcpy\#.

Ergebnis       memmove liefert den Åbergebenen Parameter dest als
               Ergebnis zurÅck, d.h. einen Zeiger auf das Ziel-Array.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memset") )
Name           Ømemory setÆ - Speicherinhalt setzen

Definition     void  *memset( void *s, int val, size_t len );

Prototyp in    string.h

Beschreibung   memset setzt die ersten len Bytes des Arrays s auf den
               Wert von val.

Ergebnis       memset liefert den Åbergebenen Parameter s als Ergebnis
               zurÅck (d.h. ebenfalls einen Zeiger auf das Ziel-Array).

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memcpy") )
Name           Ømemory copyÆ - kopiert einen Speicherbereich

Definition     void  *memcpy( void *dest, const void *src, size_t len );

Prototyp in    string.h

Beschreibung   memcpy kopiert len Bytes von src nach dest und
               berÅcksichtigt mîgliche öberlappungen von Quell-
               und Zielgebiet automatisch.

Ergebnis       memcpy liefert den Åbergebenen Parameter dest als
               Ergebnis zurÅck, d.h. einen Zeiger auf das Ziel-Array.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("mktime") )
Name           Ømake timeÆ - Datum konvertieren.

Definition     time_t  mktime( struct tm *timeptr );

Prototyp in    time.h

Beschreibung   Die Funktion mktime konvertiert eine Uhrzeit/Datum
               Angabe von der Stuktur \#tm\# in das Format von \#time_t\#.

Ergebnis       Die Funktion liefert Datum/Uhrzeit als Datentyp \#time_t\#.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#
\end

screen( capsensitive("modf") )
Name           Ømodulo floatÆ - teilt eine Flieûkommazahl in Mantisse
               und Exponenten auf.

Definition     double  modf( double value, double *ipart );

Prototyp in    math.h

Beschreibung   Das Funktionsergebnis ist der Dezimalbruchanteil
               von value, der ganzzahlige Anteil wird in ipart
               gespeichert. FÅr einen Wert wie 234.778 wird  also
               0.778 zurÅckgeliefert, *ipart bekommt den Inhalt
               234.0.

Ergebnis       modf liefert den nicht-ganzzahligen Anteil des
               Arguments value als \link("%%GLOBAL%%")double\#.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fmod\#
\end

screen( capsensitive("open") )
Name           ØopenÆ - erîffnet eine Datei fÅr Lese- und
               Schreibaktionen.

Definition     int  open( char *filename, int access, ... );

Prototyp in    stdio.h

Beschreibung   open erîffnet die durch filename angegebene Datei und
               bereitet - je nach den fÅr access angegebenen Werten
               - folgende Lese- und/oder Schreibaktionen vor. FÅr den
               Parameter access sind zwei Arten von Konstanten in
               stdio.h definiert, die Åber eine OR-Operation
               miteinander verbunden werden mÅssen:

               Flags fÅr Lesen und/oder Schreiben:
O_RDONLY       nur Lesen
O_WRONLY       nur Schreiben
O_RDWR         Lesen und Schreiben

               Flags fÅr die Art der Erîffnung
O_APPEND       neu geschriebene Daten werden grundsÑtzlich angehÑngt,
               das öberschreiben bereits existierender DatensÑtze ist
               nicht mîglich
O_CREAT        wenn die Datei noch nicht existiert, wird sie erzeugt.
               Falls die Datei bereits existiert, hat dieses Flag
               keine Wirkung
O_TRUNC        wenn die Datei bereits existiert, wird ihr vorheriger
               Inhalt gelîscht, eventuelle Dateiattribute bleiben
               unverÑndert
O_EXCL         wird ignoriert
Hinweise:      FÅr jeden Aufruf von open muû genau eines der Flags
               O_RDONLY..O_RDWR angegeben sein - die weiteren Flags
               sind nicht obligatorisch und kînnen beliebig
               miteinander kombiniert werden. Die optional mit Ø...Æ
               angegebenen Parameter sind lediglich aus GrÅnden der
               KompatibilitÑt zur IBM-Version von Pure C beibehalten
               worden. Die Parameter werden auf dem Atari ST/TT
               ignoriert.

Ergebnis       Wenn die Datei fehlerfrei erîffnet werden konnte,
               liefert open den Handle dieser Datei zurÅck (einen int
               mit einem Wert grîûer 0, Åber den weitere Operationen
               mit dieser Datei ausgefÅhrt werden). Die momentane
               Position innerhalb der neu erîffneten Datei wird auf
               den Dateianfang gesetzt. Im Falle eines Fehlers liefert
               die Funktion den Wert -1 als Ergebnis und setzt die
               globale Variable \#errno\# auf einen der folgenden Werte:
               ENOENT         EMFILE         EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#close\#   \#creat\#   \#ferror\#   \#fopen\#   \#lseek\#
               \#read\#    \#write\#
\end

screen( capsensitive("perror") )
Name           Øprint errorÆ - gibt eine Systemfehlermeldung via
               stderr aus.

Definition     void  perror( char *s );

Prototyp in    stdio.h

Beschreibung   perror kann nach einem Fehler aufgerufen werden und
               gibt zwei Strings in die Standard-Datei stderr aus
               (der normalerweise der Bildschirm zugeordnet ist):
               ˘ den (vom Programmierer definierten) String s;
               ˘ danach einen Doppelpunkt, ein Leerzeichen und einen
                 String des Arrays sys_errlist;
               ˘ einen Zeilenvorschub.
               Das Array sys_errlist enthÑlt sÑmtliche Fehlermeldungen
               des Systems in der Reihenfolge aufsteigender
               Fehlernummern - perror verwendet den momentanen Wert
               der globalen Variablen \#errno\# zur Adressierung.
               Der Aufruf von perror sollte direkt nach einem Fehler
               geschehen, weil jede weitere Ein-/Ausgabe-Operation
               \#errno\# erneut setzt (bzw. lîscht).
               Normalerweise wird man den Namen des Programms als
               Argument an perror Åbergeben - zwingend ist das
               allerdings genausowenig wie die Verwendung der durch
               sys_errlist vorgegebenen Texte (diesem Zeiger-Array
               lassen sich auch eigene Meldungen zuweisen).
               Weitere Details zu \#errno\#, sys_errlist und sys_nerr
               (der hîchsten Fehlernummer) finden Sie in Kapitel 8.

Ergebnis       perror hat kein direktes Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#feof\#   \#ferror\#
\end

screen( capsensitive("pow") )
Name           ØpowerÆ - berechnet die y. Potenz von x, also x^y.

Definition     double  pow( double x, double y );

Prototyp in    math.h

Beschreibung   pow liefert das Ergebnis der Berechnung x^y.

Ergebnis       Falls sich das Argument x kleiner Null ist und y
               keine ganze Zahl, so wird \#errno\# auf EDOM gesetzt.
               Wenn beide Argumente Null sind, erhÑlt man als
               Resultat 1. Bei einem öberlauf liefert pow HUGE_VAL
               und setzt \#errno\# auf den Wert ERANGE.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#sqrt\#
\end

screen( capsensitive("pow10") )
Name           Øpower 10Æ - berechnet die p. Potenz 10, also 10^y.

Definition     double  pow10( int p );

Prototyp in    math.h

Beschreibung   pow10 liefert das Ergebnis der Berechnung 10^y.

Ergebnis       Bei einem öberlauf oder Unterlauf wird \#errno\# auf
               den Wert ERANGE gesetzt.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#sqrt\#   \#pow\#
\end

screen( capsensitive("printf") )
Name           Øprint formattedÆ - formatierte Ausgaben.

Definition     int  printf( const char *format, ... );

Prototyp in    stdio.h

Beschreibung   Die printf-Funktion gibt formatierte Ausgaben auf
               dem Bildschirm aus. Sie erwartet dazu mindestens
               einen \link("Format-String (printf)")Format-String\# (Parameter format).

Ergebnis       printf liefert die Anzahl der ausgegebenen Zeichen als
               Funktionsergebnis zurÅck. Im Falle eines Fehlers
               ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#      \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#   \#vprintf\#   \#sprintf\#
               \#fprintf\#
\end

screen( "Format-String (printf)" )
Der Format-String ist in jeder Variante von printf obligatorisch
- Åber ihn wird die Art der Konvertierung, die Formatierung und die
Anzahl der Parameter festgelegt. Parameter, die durch den Format-
String nicht erfaût (d.h. ÅberzÑhlig) sind, werden schlicht ignoriert
- wenn printf aufgrund des Format-Strings dagegen mehr Parameter
erwartet als angegeben sind, ergeben sich bestenfalls merkwÅrdige,
meist aber katastrophale Resultate.
Der Format-String ist ein mit  terminierter String, der zwei Arten
von Informationen enthÑlt:
 ˘ Ønormale ZeichenÆ, die schlicht direkt ausgegeben werden;
 ˘ Konvertierungs-Anweisungen, die die Auswertung korrespondierender
   Parameter und ihre Formatierung bestimmen.
Konvertierungs-Anweisungen lassen sich durch das folgende
Syntaxdiagramm darstellen:

% \#[Flags]\# \link("[Breite] (printf)")[Breite]\# \#[.PrÑzision]\# \link("[h|l|L] (printf)")[h|l|L]\# \link("Format")Typ\#

Jede Anweisung beginnt mit einem Prozentzeichen (%).
Querverweis:    \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( "[Flags]" )
[Flags]      eine (optionale) Zeichenfolge, Åber die numerische
             Vorzeichen, Dezimalpunkte, fÅhrende und folgende Nullen,
             oktale und hexadezimale PrÑfixe sowie links- und
             rechtsbÅndige Ausgabe festgelegt werden;

printf erkennt vier verschiedene Zeichen als Flags an: Minus (-), Plus
(+), Doppelkreuz (#) und Leerzeichen( ). Flag-Zeichen kînnen in
beliebiger Folge und Kombination erscheinen und haben die folgenden
Wirkungen:
- linksbÅndige Ausgabe - nîtigenfalls werden nach der Ausgabe
  Leerzeichen angefÅgt. Wenn dieses Flag nicht angegeben ist, arbeitet
  printf rechtsbÅndig, d.h. stellt Leerzeichen voran.
+ numerische Ausgabe mit Vorzeichen - positiven Werten wird ein
  Pluszeichen vorangestellt. Wenn dieses Flag nicht angegeben ist,
  stellt printf nur bei negativen Werten ein Minuszeichen voran, bei
  positiven Werten Åberhaupt nichts.
' ' (Leerzeichen) - positive Werte werden mit einem fÅhrenden
  Leerzeichen ausgegeben. Wenn weder dieses Flag noch ein + angegeben
  ist, dann stellt printf positiven Werten Åberhaupt nichts voran.
# Konvertierung des Arguments in Øalternativer FormÆ (siehe folgende
  Tabelle).

Hinweis: Wenn sowohl ein Leerzeichen als auch ein Pluszeichen
angegeben sind, wird das Leerzeichen von printf ignoriert.

ØAlternative FormenÆ
Die Verwendung des Flags # zusammen mit einer Typ-Angabe hat folgende
Wirkungen:

c,s,d,i,u (keine)
o         solange der korrespondierende Parameter nicht den Wert 0
          hat, wird eine Ø0Æ vorangestellt;
x,X       Voranstellen von Ø0xÆ bzw. Ø0XÆ;
e,E,f     es wird immer ein Dezimalpunkt ausgegeben (normalerweise ist
          das bei diesen Formaten nur dann der Fall, wenn der Wert
          Stellen nach dem Komma enthÑlt);
g,G       wie bei e und E - zusÑtzlich werden folgende Nullen nicht
          unterdrÅckt.


                        \link("Format-String (printf)")Format-String\#
\end

screen( "[Breite] (printf)" )
[Breite]     eine (optionale) Angabe Åber die minimal auszugebende
             Zeichenzahl (printf fÅllt nîtigenfalls mit Leerzeichen
             oder Nullen auf);


Breite
Diese Angabe legt die minimale Zahl auszugebender Zeichen fest und
kann in zwei Formen erfolgen: entweder direkt innerhalb des Format-
Strings oder Åber ein Sternchen (*). Bei der Verwendung von * erwartet
printf einen zusÑtzlichen Parameter, der in der Liste direkt vor dem
auszugebenden Wert stehen und den Typ int haben muû.
Wenn eine Ausgabe weniger Zeichen erzeugt als durch Breite angegeben
ist, dann fÅgt printf (abhÑngig von den Flags) fÅhrende/folgende
Leerzeichen hinzu - erzeugt die Ausgabe dagegen mehr Zeichen als durch
Breite angegeben, dann wird Breite einfach ignoriert. Anders gesagt:
Ausgaben werden durch Breite in keinem Fall begrenzt oder
abgeschnitten.
n   (Dezimalzahl) - printf gibt mindestens n Zeichen aus und stellt
    nîtigenfalls Leerzeichen voran (Standard) bzw. fÅgt folgende
    Leerzeichen an (Flag-);
0n  (Dezimalzahl mit vorangestellter Null) - printf gibt mindestens
    n Zeichen aus und stellt nîtigenfalls eine entsprechende Anzahl
    fÅhrender Nullen voran;
*   (Sternchen) - die Angabe fÅr Breite steht in der Parameterliste
    direkt vor dem auszugebenden Wert.


                        \link("Format-String (printf)")Format-String\#
\end

screen( "[.PrÑzision]" )
[.PrÑzision] eine (optionale) Angabe, wieviele Zeichen maximal
             ausgegeben werden sollen (bei Integern: die Minimalzahl
             von Ziffern);

PrÑzision
Diese Angabe wird immer mit einem Dezimalpunkt (.) eingeleitet und so
von einer eventuell vorangestellten Breite getrennt. Wie bei Breite
kann entweder eine direkte Angabe innerhalb des Format-Strings oder
ein Sternchen (*) verwendet werden. Im letzteren Fall erwartet printf
einen zusÑtzlichen Parameter des Typs int, der direkt vor dem
auszugebenden Wert steht.
Wenn sowohl Breite als auch PrÑzision Åber ein Sternchen angegeben
werden, dann muû die Parameterliste folgendermaûen aussehen:

    ("%<Flags>*.*<Typ>", Breite, PrÑzision, Wert)
                        \link("Format-String (printf)")Format-String\#
\end

screen( "Format",
		"Typ (printf)" )
Typ Parameter Ausgabe

    numerische Werte

d   Integer   signed int (dezimal);
i   Integer   signed int (dezimal);
o   Integer   unsigned int (oktal);
u   Integer   unsigned int (dezimal);
x   Integer   unsigned int (hexadezimal), Buchstaben a..f;
X   Integer   unsigned int (hexadezimal), Buchstaben A..F.
              Die Formate x und X unterscheiden sich nur durch die
              Verwendung von Klein- bzw. Groûbuchstaben.
f  Flieûkomma vorzeichenbehafteter Wert der Form [-]dddd.dddd
              Die Anzahl der Nachkommastellen wird durch PrÑzision
              festgelegt (solange dieser Zusatz angegeben ist).
e  Flieûkomma vorzeichenbehafteter Wert der Form [-]d.dddd e [+|-]ddd
              Hier steht grundsÑtzlich eine Ziffer vor dem
              Dezimalpunkt, die Anzahl der Nachkommastellen wird durch
              PrÑzision festgelegt, der Exponent umfaût immer drei
              Ziffern (notfalls mit fÅhrenden Nullen).
g  Flieûkomma vorzeichenbehafteter Wert im e- oder f-Format (abhÑngig
              vom Wert und der Angabe PrÑzision). Folgende Nullen, ein
              Dezimalpunkt und ein Vorzeichen werden nur ausgegeben,
              wenn es notwendig ist. Das e-Format wird nur dann
              verwendet, wenn das Resultat einer f-Konvertierung mehr
              als PrÑzision Stellen ergibt oder mehr als vier fÅhrende
              Nullen erfordert.
E  Flieûkomma dasselbe Format wie e, aber mit dem Zeichen E vor dem
              Exponenten;
G  Flieûkomma dasselbe Format wie g, aber mit dem Zeichen E vor dem
              Exponenten, wenn dieses Format verwendet wird.

    Zeichen

c  Zeichen    einzelnes Zeichen;
s  String     Ausgabe bis zu einem Nullzeichen oder dem Erreichen der
              durch PrÑzision vorgegebenen Zeichenzahl;
%  (nichts)   Ausgabe des Zeichens %;

    Zeiger

n  *int       speichert in dem korrespondierenden Parameter die Anzahl
              der bis jetzt ausgegebenen Zeichen;
p  Zeiger     gibt den korrespondierenden Parameter als Zeiger in
              hexadezimaler Form aus.

                         \link("Format-String (printf)")Format-String\#
\end

screen( "[h|l|L] (printf)" )
h | l | L - explizite Grîûenangaben
Die Grîûenangaben h und l sind nur auf numerische Argumente anwendbar
fÅr die Formate c, s, p und n haben sie keine Wirkung.

h  das Argument wird als short interpretiert (Formate d, i, o, u, x
   und X);
l  das Argument wird als long (Formate d, i, o, u, x und X) bzw. als
   \link("%%GLOBAL%%")double\# interpretiert (Formate e, E, f, g und G).
L  das Argument wird als long double interpretiert.

Diese Angabe ist nur notwendig wenn die Grîûe der Parameter von der
Standardgrîûe abweicht.

                       \link("Format-String (printf)")Format-String\#
\end

screen( capsensitive("putc") )
Name           Øput characterÆ - Ausgabe eines Zeichens in Datei

Definition     int  putc( int c, FILE *fp );

Prototyp in    stdio.h

Beschreibung   putc ist ein Makro, der das Zeichen c zu dem durch fp
               angegebenen stream ausgibt.

Ergebnis       putc liefert das Åbergebene Zeichen c auch als
               Funktionsergebnis zurÅck. Im Falle eines Fehlers
               liefert putc den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fputc\#   \#putchar\#   \#ferror\#   \#fopen\#    \#fread\#
               \#getc\#    \#printf\#    \#puts\#     \#setbuf\#   \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("putch") )
Name           Øput characterÆ - Ausgabe eines Zeichens auf dem
               Bildschirm

Definition     int  putch( int c );

Prototyp in    ext.h

Beschreibung   putch gibt ein Zeichen auf das GerÑt console
               (d.h. den Bildschirm) aus.

Ergebnis       putch liefert das als c Åbergebene Zeichen zurÅck.
               Im Fehlerfall erhÑlt man EOF.

Gruppe         \#Pure-C-Spezialfunktionen\#

Querverweis    \#ferror\#   \#fopen\#    \#fread\#   \#getc\#    \#printf\#
               \#puts\#     \#setbuf\#   \#putc\#    \#fputc\#   \#putc\#
\end

screen( capsensitive("putchar") )
Name           Øput characterÆ - Ausgabe eines Zeichens auf das
               StandardausgabegerÑt stdout

Definition     int  putchar( int c );

Prototyp in    stdio.h

Beschreibung   putchar ist ein Makro und als \#putc\#(c, stdout)
               definiert, gibt also ein Zeichen via stdout aus.

Ergebnis       putchar liefert das Åbergebene Zeichen c auch als
               Funktionsergebnis zurÅck. Im Falle eines Fehlers
               liefert putchar den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#   \#fopen\#    \#fread\#   \#getc\#  \#printf\#
               \#puts\#     \#setbuf\#   \#putc\#    \#fputc\#
\end

screen( capsensitive("puts") )
Name           Øput stringÆ - Ausgabe einer Zeichenfolge.

Definition     int  puts( const char *s );

Prototyp in    stdio.h

Beschreibung   puts schreibt den nullterminierten String s
               zeichenweise zu stdout und beendet die Ausgabe mit
               einem (automatischen erzeugten) Zeilenvorschub.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert einen nicht-
               negativen Wert. Im Falle eines Fehlers liefert
               puts den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#   \#fopen\#   \#fread\#   \#gets\#   \#open\#
               \#printf\#   \#putc\#    \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("qsort") )
Name           ØquicksortÆ - sortiert die Elemente eines Arrays in
               aufsteigender Reihenfolge.

Definition     void  qsort( void *base, size_t nmemb, size_t size,
                             int (*compar)( ));

Prototyp in    stdlib.h

Beschreibung   qsort ist eine Implementation des ØquicksortÆ-
               Algorithmus zum Sortieren der Elemente eines Arrays.
               Die Elemente kînnen (wie bei bsearch) aus beliebigen
               Datenkonstrukten bestehen, weil die Funktion nur die
               Abfolge der Vergleiche festlegt. qsort erwartet die
               folgenden Parameter:
                 ˘ base   - einen Zeiger auf das Element 0 des zu
                            sortierenden Arrays;
                 ˘ nmemb  - die Anzahl der zu sortierenden Elemente;
                 ˘ size   - die Grîûe eines einzelnen Elements
                            (in Byte);
                 ˘ compar - einen Zeiger auf die Vergleichsfunktion.
               Die Vergleichsfunktion muû vom Programmierer folgender-
               maûen definiert werden:

                  int <Name> (e_typ *elem1, e_typ *elem2);

               Sie bekommt bei jedem Aufruf durch qsort zwei Zeiger
               auf jeweils ein Element des zu sortierenden Arrays
               Åbergeben, muû die entsprechenden Elemente miteinander
               vergleichen und folgende Ergebnisse zurÅckliefern:

                 *elem1 <  *elem2   Wert < 0
                 *elem1 == *elem2   Wert 0
                 *elem1 >  *elem2   Wert > 0

               Theoretisch ist es mîglich, diese Definition
               ØumzudrehenÆ (d.h. fÅr *elem1 < *elem2 einen Wert
               grîûer 0 und fÅr *elem1 > *elem2 einen Wert kleiner
               Null zurÅckzuliefern) - in diesem Fall wÅrde qsort
               die Array-Elemente in absteigender Reihenfolge
               sortieren.

Ergebnis       qsort hat kein direktes Funktionsergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#bsearch\#   \#size_t\#
\end

screen( capsensitive("rand") )
Name           ØrandomÆ - liefert eine ØZufallszahlÆ zurÅck.

Definition     int  rand( void );

Prototyp in    stdlib.h

Beschreibung   rand verwendet ein multiplikatives Kongruenzverfahren
               (Multiplikation mit anschlieûender Modulo-Operation),
               um ØZufallszahlenÆ im Bereich von 0..2^15-1 zu
               erzeugen. Die Periodendauer des Generators betrÑgt
               2^32.
               Der ØZufallszahlen-GeneratorÆ wird beim Start des
               Programms mit dem Wert 1 initialisiert - Åber einen
               Aufruf von \#srand\# kann jederzeit ein neuer (und
               beliebiger) Startwert gesetzt werden. Folgen von
               ØZufallszahlenÆ sind von einem gegebenen Startwert aus
               beliebig oft reproduzierbar.

Ergebnis       rand liefert einen int im Bereich von 0..32767 zurÅck.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#srand\#   \#random\#
\end

screen( capsensitive("read") )
Name           ØreadÆ - liest Daten von einer Datei

Definition     size_t  read( int handle, void *buf, size_t len );

Prototyp in    stdio.h

Beschreibung   Die Funktion read liest len Bytes aus der durch handle
               bezeichneten Datei in den durch buf angegebenen
               Speicherbereich. handle ist eine Referenznummer und
               wird der Datei via creat oder open zugeordnet.
               Bei Diskettendateien beginnt der Lesevorgang ab der
               momentanen Position innerhalb der Datei, die mit \#lseek\#
               gesetzt werden kann und wÑhrend des Lesevorgangs um die
               Anzahl der gelesenen Bytes erhîht wird.
               Bei GerÑtedateien ist eine ØPositionÆ nicht definiert -
               hier liest read direkt vom entsprechenden GerÑt.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert die Funktion die
               Anzahl der gelesenen Bytes als (positiven) Wert vom
               Type size_t zurÅck. Wenn das Dateiende erreicht bzw.
               Åberschritten wurde, liefert die Funktion den Wert 0.
               Im Falle eines Fehlers hat read das Ergebnis -1,
               \#errno\# wird auf einen der folgenden Werte gesetzt:
                               EACCES  EBADF

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#   \#fread\#   \#getc\#   \#open\#   \#write\#
               \#size_t\#
\end

screen( capsensitive("realloc") )
Name           Øre-allocÆ - Ñndert die Grîûe eines dynamisch
               reservierten Speicherplatzes

Definition     void  *realloc( void *block, size_t newsize );

Prototyp in    stdlib.h

Beschreibung   realloc Ñndert die Grîûe eines durch \#malloc\# oder
               \#calloc\# reservierten Speicherbereichs. Der verÑnderte
               Bereich wird nicht neu initialisiert.

Ergebnis       Als Ergebnis erhÑlt man einen typenlosen Zeiger auf
               die Adresse des angepaûten Speicherbereichs, der
               explizit auf den verwendeten Zeigertyp konvertiert
               werden sollte. Wenn kein Speicherbereich ausreichender
               Grîûe zur VerfÅgung steht, dann ist das
               Funktionsergebnis \link("%%GLOBAL%%")NULL\#, es findet keine Belegung statt.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#setbuf\#   \#malloc\#   \#calloc\#   \#size_t\#
\end

screen( capsensitive("remove") )
Name           ØremoveÆ - lîscht eine Datei

Definition     int  remove( const char *filename );

Prototyp in    stdio.h

Beschreibung   remove lîscht die durch filename angegebene Datei,
               wobei filename einen vollstÑndigen Suchweg und/oder
               einen Laufwerksbezeichner enthalten kann - die
               Jokerzeichen * und ? sind dagegen nicht erlaubt.
               SchreibgeschÅtzte Dateien und Directories kînnen mit
               remove nicht gelîscht werden.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert remove den
               Wert 0 zurÅck. Im Falle eines Fehlers ist das
               Funktionsergebnis -1 und \#errno\# bekommt einen der
               folgenden Werte:
                                ENOENT  EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#
\end

screen( capsensitive("rename") )
Name           ØrenameÆ - Ñndert den Namen einer Datei

Definition     int  rename( const char *oldname, const char *newname );

Prototyp in    stdio.h

Beschreibung   rename gibt der durch oldname bezeichneten Datei
               den neuen Namen newname. Beide Namen kînnen
               vollstÑndige Suchwege und/oder Laufwerksbezeichner
               enthalten. Die Angabe von Jokerzeichen (* und ?)
               ist nicht erlaubt - dafÅr ist es mit rename aber
               mîglich, Dateien von einem Directory in ein anderes
               zu bewegen, sofern sich Quelle und Ziel auf demselben
               Laufwerk befinden.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert rename den Wert 0
               zurÅck, ansonsten ist das Funktionsergebnis -1 und
               \#errno\# bekommt einen der folgenden Werte:
                           ENOENT     EACCES     ENOTSAM

Gruppe         \#I/O-Routinen\#
\end

screen( capsensitive("rewind") )
Name           ØrewindÆ - setzt die momentane Position innerhalb einer
               Datei auf den Dateianfang

Definition     void  rewind( FILE *fp );

Prototyp in    stdio.h

Beschreibung   rewind ist Ñquivalent zu \#fseek\# mit SEEK_SET und
               einem offset von 0 - die momentane Position wird
               auf das erste Byte des Dateiinhalts gesetzt. Der
               einzige Unterschied besteht darin, daû rewind nicht
               nur das Dateiende-Flag lîscht, sondern auch eventuell
               gesetzte Fehler-Flags. In Dateien, die fÅr Lese- und
               Schreiboperationen erîffnet worden sind, kann nach
               rewind zwischen ØLesenÆ und ØSchreibenÆ gewechselt
               werden. Mit \#ungetc\# zurÅckgestellte Zeichen sind nach
               rewind nicht mehr erreichbar.

Ergebnis       rewind hat kein direktes Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#getc\#   \#lseek\#   \#setbuf\#   \#ungetc\#
               \#fseek\#
\end

screen( capsensitive("scanf") )
Name           Øscan formattedÆ - formatierte Eingabe

Definition     int  scanf( const char *format, ... );

Prototyp in    stdio.h

Beschreibung   scanf liest Eingaben in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               Åber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       scanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurÅck, wobei mit *
               unterdrÅckte Felder nicht gezÑhlt werden.
               Wenn Åberhaupt keine Zuweisungen erfolgt sind, hat
               das Ergebnis den Wert 0.
               Der Versuch, Åber das Ende einer Datei bzw. Åber das
               Ende eines Strings hinaus zulesen (\#sscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

Querverweis    \#fscanf\#   \#sscanf\#   \#vscanf\#

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#
\end

screen( capsensitive("vscanf") )
Name           Øscan formattedÆ - formatierte Eingabe

Definition     #include <stdarg.h>
               int  vscanf( const char *format, \#va_list\# param );

Prototyp in    stdio.h

Beschreibung   Die v...scanf-Funktionen verhalten sich Ñhnlich wie
               ihre ...scanf-GegenstÅcke, sie akzeptieren jedoch
               einen Pointer auf eine Liste von Argumenten anstelle
               der Liste selber.
               vscanf liest Eingaben in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               Åber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       vscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurÅck, wobei mit *
               unterdrÅckte Felder nicht gezÑhlt werden.
               Wenn Åberhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, Åber das Ende einer Datei bzw. Åber das
               Ende eines Strings hinaus zulesen (\#vsscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

PortabilitÑt   vsscanf ist auf UNIX-Systemen verfÅgbar.

Querverweis    \#fscanf\#   \#sscanf\#   \#scanf\#

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#
\end

screen( "Format-String (scanf)" )
Der Format-String ist ein nullterminierter String, in dem fÅr jede
einzulesende Variable eine Formatierungsanweisung vorhanden sein muû.

Formatierungsanweisungen lassen sich durch das folgende
Syntaxdiagramm darstellen:

 % \#[*]\# \link("[Breite] (printf)")[Breite]\# \link("[h|l|L] (printf)")[h|l|L]\# \link("Format")Typ\#

Jede Anweisung beginnt mit einem Prozentzeichen (%).
\end

screen( "[*]" )
[*]      unterdrÅckt eine Zuweisung Åber den korrespondierenden
         Adress-Parameter;
Wenn der Operator * direkt auf das % einer Format-Anweisung folgt,
dann wertet scanf die restlichen Elemente dieser Anweisung aus und
analysiert die Eingabe, nimmt aber keine Zuweisung Åber den
korrespondierenden Adress-Parameter vor.
(Hier wird zwar dasselbe Zeichen wie fÅr die Indirektion verwendet -
ansonsten haben diese beiden Dinge aber nicht das geringste
miteinander zu tun).
Die UnterdrÅckung von Zuweisungen bei scanf ist mit gewisser Vorsicht
zu genieûen - eine direkte Mîglichkeit zur PrÅfung, ob die ØrichtigenÆ
Teile einer Eingabe dadurch Åbersprungen wurden, gibt es nicht.

                          \link("Format-String (printf)")Format-String\#
\end

screen( "[Breite] (scanf)" )
[Breite] eine (optionale) Angabe Åber die maximal zu lesende
         Zeichenzahl. (Wenn vor Erreichen dieser Zeichenzahl ein
         Øweiûes LeerzeichenÆ oder ein anderes nicht auswertbares
         Zeichen gelesen wird, beendet \#scanf\# die Eingabe dieses
         Wertes von selbst;
         Auswirkungen hat eine derartige Angabe nur dann, wenn das
         entsprechende Feld nicht aufgrund einer anderen Bedingung
         als beendet betrachtet wird (z.B. durch ein Øweiûes
         LeerzeichenÆ oder ein nicht auswertbares Zeichen wie Ø8Æ
         oder Ø9Æ bei der Eingabe einer Oktalzahl).

                            \link("Format-String (scanf)")Format-string\#
\end

screen( "[h|l|L] (scanf)" )
[h|l|L]  eine (optionale) Angabe Åber die Grîûe der Variablen, auf die
         der korrespondierende Adress-Parameter zeigt (h = \link("%%GLOBAL%%")short\# \link("%%GLOBAL%%")int\#,
         l = \link("%%GLOBAL%%")long\# oder \link("%%GLOBAL%%")double\#, L = \link("%%GLOBAL%%")long\# \link("%%GLOBAL%%")double\#);
         Die Grîûenangaben h und l sind nur fÅr Eingaben von Integern
         und Flieûkommawerten anwendbar - auf alle anderen Formate
         haben sie keine Wirkung.
h        fÅr die Formate d, i, o, u, und x: Konvertierung der Eingabe
         in das Format \link("%%GLOBAL%%")short\# \link("%%GLOBAL%%")int\#. FÅr alle anderen Formate ohne Wirkung.
         In Pure C das gleiche wie \link("%%GLOBAL%%")int\#.
l        fÅr die Formate d, i, o, u, und x: Konvertierung der Eingabe
         in das Format \link("%%GLOBAL%%")long\#;
         fÅr die Formate e und f: Konvertierung der Eingabe in das
         Format \link("%%GLOBAL%%")double\#. FÅr alle anderen Formate ohne Wirkung.
L        fÅr die Formate e und f: Konvertierung der Eingabe in das
         Format \link("%%GLOBAL%%")long\# \link("%%GLOBAL%%")double\#. FÅr alle anderen Formate ohne Wirkung.

                           \link("Format-String (printf)")Format-String\#
\end

screen( "Typ (scanf)" )
Die Angabe des Typs ist obligatorisch.

Typ Eingabe       Adress-Parameter

    numerische Werte

d   dez. Integer  Zeiger auf int (int *arg)
o   okt. Integer  Zeiger auf int (int *arg)
i   dez. Integer  Zeiger auf int als Konstante (int *arg)
u   dez. Integer  Zeiger auf unsigned int (unsigned *arg)
x   hex. Integer  Zeiger auf unsigned int (unsigned *arg)
e   Flieûkomma    Zeiger auf float im Exponentialformat (float *arg)
f   Flieûkomma    Zeiger auf float (float *arg)
g   Flieûkomma    Zeiger auf float (float *arg).

   Zeichen

c   Zeichen       Zeiger auf ein einzelnes Zeichen (char *arg).
                  Wenn hier eine Breite angegeben ist (z.B. %5c):
                  Zeiger auf ein char-Array entsprechender Grîûe
                  (char arg[Breite]);
s   String        Zeiger auf einen String (char arg[]);
                  oder %\#[Suchzeichen]\#
%   Zeichen %     keine Konvertierung, sondern Speicherung des
                  Zeichens %;

    Zeiger

n   (nichts)      Zeiger auf int (int *arg) - speichert die Anzahl bis
                  jetzt gelesener Zeichen an der Adresse, auf die der
                  Zeiger zeigt;
p   XXXXXXXX      Zeiger auf ein beliebiges Objekt - die Eingabe wird
                  in hexadezimaler Form interpretiert.

                            \link("Format-String (printf)")Format-String\#
\end

screen( "[Suchzeichen]" )
%[Suchzeichen]

%[abcd]  erlaubt nur Eingaben, die aus den Zeichen a, b, c und d
         bestehen - \#scanf\# betrachtet das Eingabefeld bei jedem
         anderen Zeichen als beendet;
%[^abcd] erlaubt Eingaben, die nicht eines der Zeichen a, b , c
         oder d enthalten. Das Eingabefeld wird durch Øweiûe
         LeerzeichenÆ nicht beendet, sondern nur durch die
         angegebenen Zeichen (oder das Erreichen der mit Breite
         festgelegten Zeichenzahl).

Mehrere Bereiche werden ohne spezielle Trennzeichen direkt
aufeinanderfolgend angegeben. Einige Beispiele dazu:
%[A-Z]              sÑmtliche Groûbuchstaben
%[A-Za-z]           sÑmtliche Groû- und Kleinbuchstaben
%[A-Za-zÑîÅéôöû]    sÑmtliche Buchstaben inklusive der Umlaute
                    und des û
%[-+*/]             die vier arithmetischen Operatoren
%[z-a]              die Zeichen ØzÆ, Ø-Æ und ØaÆ
%[+0-9-A-F]         das Zeichen Ø+Æ, die Ziffern von 0 bis 9, das
                    Zeichen Ø-Æ und die Buchstaben von A bis F
%[+0-9A-F-]         genau dieselben Zeichen wie im vorigen Beispiel
%[^-0-9+A-F]        sÑmtliche Zeichen auûer Ø-Æ, den Ziffern 0 bis 9,
                    dem Zeichen Ø+Æ und den Buchstaben A bis F.

                          \link("Format-String (printf)")Format-String\#
\end

screen( capsensitive("setbuf") )
Name           Øset bufferÆ - Explizite Zuordnung eines Puffers zu
               einem stream.

Definition     void  setbuf( FILE *fp, void *buf );

Prototyp in    stdio.h

Beschreibung   setbuf ordnet der durch fp angegebenen Datei
               den Puffer buf anstelle des automatisch vergebenen
               Puffers zu. Die Minimalgrîûe von buf ist durch die
               (in stdio.h definierte) Konstante BUFSIZ festgelegt.
               Durch die Angabe des Zeigerwertes \link("%%GLOBAL%%")NULL\# anstelle von
               buf arbeiten  folgende Ein-/Ausgaben Åber den stream
               ungepuffert, d.h. Ausgaben geschehen sofort, Eingaben
               lesen direkt vom entsprechenden GerÑt.

               (Die ØPufferungÆ von Ein- und Ausgaben bedeutet:
               Ausgaben werden zeichenweise zwischengespeichert
               und blockweise geschrieben; Eingaben werden blockweise
               von der Datei bzw. dem GerÑt gelesen und danach
               zeichenweise aus dem Puffer geliefert.)

               stdin und stdout arbeiten ungepuffert, solange sie
               nicht umgeleitet sind - Umleitungen bewirken dagegen
               normalerweise eine Pufferung, die via setbuf ver-
               Ñndert werden kann.

               setbuf darf nur direkt nach der Erîffnung (oder
               direkt nach einem fseek) auf einen stream angewendet
               werden - ansonsten sind die Ergebnisse unvorhersag-
               bar. Die Anwendung dieser Funktion auf ungepufferte
               Dateien (bzw. auf Dateien, deren Puffer direkt nach
               der Erîffnung oder einem fseek entfernt wurde) ist
               dagegen problemlos und jederzeit mîglich.

               Hinweis: FÅr buf kann eine lokale Variable verwendet
               werden - allerdings sollte man in diesem Fall streng
               darauf achten, die Datei vor dem Ende der entsprechen-
               den Funktion wieder zu schlieûen.

Ergebnis       setbuf hat kein direktes Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#setvbuf\#   \#fopen\#   \#fclose\#   \#fseek\#   \#malloc\#
               \#open\#
\end

screen( capsensitive("setdate") )
Name           Øset dateÆ - Setzt das aktuelle Tagesdatum.

Definition     void  setdate( struct date *dateRec );

Prototyp in    ext.h

Beschreibung   Die Funktion setdate setzt das aktuelle Tagesdatum. Das
               Datum wird in der Struktur \#date\# Åbergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#, \#ctime\#, \#getdate\#
\end

screen( capsensitive("setdisk") )
Name           Øset diskÆ - Setzt das aktuelle Laufwerk

Definition     int  setdisk( int drive );

Prototyp in    ext.h

Beschreibung   Die Funktion setdisk wechselt das aktuelle Laufwerk.
               FÅr das Laufwerk A: ist eine 0 zu Åbergeben, fÅr B: 
               eine 1 usw.

Ergebnis       setdisk liefert die Anzahl der verfÅgbaren Laufwerke
               zurÅck.

PortabilitÑt   Pure- und Turbo-C-spezifisch.

Querverweis    \#getdisk\#
\end

screen( capsensitive("setftime") )
Name           Øset file timeÆ - Setzt Datum und Uhrzeit einer offenen
               Datei.

Definition     int  setftime( int handle, struct ftime *ftimep );

Prototyp in    ext.h

Beschreibung   Die Funktion setftime setzt Datum und Uhrzeit der durch
               handle bezeichneten Datei. Datum und Uhrzeit werden
               durch die Struktur \#ftime\# beschrieben.

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung den
               Wert 0. Wenn der angegebene handle nicht existiert
               (d.h. keine entsprechende Datei offen ist), liefert
               getftime den Wert -1 als Ergebnis, \#errno\# bekommt den
               Wert EBADF.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getftime\#
\end

screen( capsensitive("setjmp") )
Name           Øset jumpÆ - Vorbereitung eines nicht-lokalen goto.

Definition     int  setjmp( jmp_buf env );

Prototyp in    setjmp.h

Beschreibung   speichert einen ØSchnappschuûÆ des momentanen
               Prozessor-Zustands (und des Stacks) in dem durch
               env angegebenen Puffer.
               Nach einem Aufruf von \#longjmp\# setzt der Prozessor
               die Arbeit an der Stelle fort, an der sich der Aufruf
               von setjmp befindet.

Beispiel:      #include <stdio.h>
               #include <stdlib.h>
               #include <setjmp.h>

               void function(void);

               jmp_buf buffer;   /*  wichtig: muû global sein, wenn
                                  *  aus einer Funktion heraus
                                  *  gesprungen werden soll.
                                  */
               int  main( void )
               {
               int  value;

                   if (( value = setjmp( buffer )) != 0 )
                   {
                       printf( "setjmp returned %d after using"
                               " longjmp\\n", value );
                       exit( 0 );
                   }
                   else
                   {
                       printf( "setjmp returned %d before using"
                               " longjmp\\n", value );
                   }
                   function( );

                   /*  Hierher sollte das Programm gar nicht kommen,
                    *  da function gar nicht zurÅckkehrt!
                    */

                   printf( "function shouldn' t return...\\n" );
               }

               void  function( void )
               {

               /*
                *  ...kehrt zu main zurÅck als wÑre setjmp mit
                *  dem Wert 7 zurÅckgekehrt.
                */

                   longjmp(buffer, 7);
                   printf( "function shouldn' t return...\\n" );
               }

Ergebnis       Der direkte Aufruf von setjmp liefert immer den Wert 0
               zurÅck.

Gruppe         \#SprÅnge\#

Querverweis    \#longjmp\#
\end

screen( capsensitive("settime") )
Name           Øset timeÆ - Setzt die Uhrzeit.

Definition     void  settime( struct time *timeRec );

Prototyp in    ext.h

Beschreibung   Die Funktion settime setzt die aktuelle Uhrzeit. Die
               Uhrzeit wird in der Struktur \#time\# Åbergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#   \#ctime\#   \#gettime\#   \#Settime\#
\end

screen( capsensitive("setvbuf") )
Name           Øset bufferÆ - Explizite Zuordnung eines Puffers zu
               einem stream.

Definition     int  setvbuf( FILE *fp, void *buf, int type,
                              size_t size );

Prototyp in    stdio.h

Beschreibung   setvbuf ordnet der durch fp angegebenen Datei
               den Puffer buf anstelle des automatisch vergebenen
               Puffers zu. Die Minimalgrîûe von buf ist durch die
               (in stdio.h definierte) Konstante BUFSIZ festgelegt.
               Durch die Angabe des Zeigerwertes \link("%%GLOBAL%%")NULL\# anstelle von
               buf wird Åber einen Aufruf von malloc ein Puffer der
               Grîûe size belegt und der Datei zugeordnet. size muû
               einen Wert grîûer Null haben.

               Der Parameter type von setvbuf muû Åber eine der
               drei folgenden Konstanten festgelegt werden, die
               in stdio.h definiert sind:

               _IOFBF  (ØI/O fully bufferedÆ) - Ein-/Ausgaben
               werden vollstÑndig gepuffert. Wenn der Puffer
               ØleergelesenÆ ist, versucht der nÑchste Eingabe-
               befehl, den Puffer wieder komplett mit Daten
               zu fÅllen (liest also BUFSIZ bzw. size Bytes).
               Ausgaben fÅllen den Puffer bis zum letzten Byte,
               erst danach wird der komplette Pufferinhalt
               geschrieben.

               _IOLBF  (ØI/O line bufferedÆ) - Ausgaben werden
               zeilenweise gepuffert: der Pufferinhalt wird nach
               jeder Ausgabe eines Zeilenvorschubs physikalisch
               geschrieben. Eingaben arbeiten dagegen genauso
               wie bei vollstÑndiger Pufferung.

               _IONBF  (ØI/O not bufferedÆ) - Ein-/Ausgaben
               geschehen ohne das dazwischenschalten eines
               Puffers, die Parameter buf und size werden von
               setvbuf ignoriert. Jeder Eingabebefehl liest direkt
               von der Datei, jeder Ausgabebefehl hat eine sofortige
               Schreibaktion zur Folge.

Ergebnis       setvbuf liefert bei fehlerfreier AusfÅhrung den
               Wert 0. UngÅltige Werte fÅr type oder size, fehlender
               Speicherplatz fÅr malloc oder die Anwendung auf eine
               nicht offene Datei erzeugen ein Funktionsergebnis
               ungleich 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#setbuf\#   \#fopen\#, \#fclose\#, \#fseek\#, \#malloc\#,
               \#open\#     \#size_t\#
\end

screen( capsensitive("sin") )
Name           ØsineÆ - Liefert den Sinus des Arguments zurÅck

Definition     double  sin( double x );

Prototyp in    math.h

Beschreibung   sin erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * „, 90 Grad = „/2, 180 Grad = „, 270 Grad = 1.5 * „,
               360 Grad = 2 * „ usw.) als Argument und liefert den
               dazugehîrigen Sinus zurÅck. öbergebene Werte werden
               automatisch auf den Bereich 0..2 * „ reduziert.
               Der Wert von „ (3.1415...) ist in math.h als Konstante
               mit dem Namen M_PI definiert.

Ergebnis       Mîgliche Ergebnisse liegen im Bereich von -1 .. 1.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#asin\#
\end

screen( capsensitive("sincos") )
Name           Øsine, cosineÆ - Berechnet Sinus und Cosinus

Definition     void  sincos( double x, double *sin, double *cos );

Prototyp in    math.h

Beschreibung   sincos erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * „, 90 Grad = „/2, 180 Grad = „, 270 Grad = 1.5 * „,
               360 Grad = 2 * „ usw.) als erstes Argument und berechnet
               sowohl den Sinus als auch den Cosinus des Winkels. Die
               Ergebnisse werden in den zweiten bzw. dritten Parameter
               geschrieben.

Ergebnis       Die Funktion hat kein Ergebnis.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#sin\#  \#cos\#
\end

screen( capsensitive("sinh") )
Name           Øsine hyperbolicÆ - Liefert den Sinus hyperbolicus
               des Arguments zurÅck.

Definition     double  sinh( double x );

Prototyp in    math.h

Beschreibung   sinh berechnet den Sinus hyperbolicus des Arguments,

Ergebnis       Bei fehlerfreier AusfÅhrung liefert die Funktion
               das entsprechende Ergebnis. Bei öberlÑufen wird
               HUGE_VAL (mit korrektem Vorzeichen) zurÅckgeliefert
               und \#errno\# bekommt den Wert ERANGE.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("asinh") )
Name           Øarcus sine hyperbolicÆ - Liefert den hyperbolischen
               Arcussinus des Arguments zurÅck.

Definition     double  asinh( double x );

Prototyp in    math.h

Beschreibung   asinh berechnet den Arcussinus hyperbolicus des
               Arguments.

Ergebnis       asinh liefert immer ein gÅltiges Ergebnis.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#
\end

screen( capsensitive("sprintf") )
Name           Østring print formattedÆ - Formatierte Ausgabe in
               einen String

Definition     int  sprintf( char *buffer, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ØdruckenÆ in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#.
               (Øvariable string printfÆ) - wie \#printf\#, die Ausgabe
               geschieht in den angegebenen (nullterminierten) String,
               der eine entsprechende LÑnge haben muû.

Ergebnis       SÑmtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurÅck,
               wobei das abschlieûende Nullzeichen bei sprintf nicht
               mitgezÑhlt wird. Im Falle eines Fehlers ist das
               Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#      \#scanf\#     \#va_...\#
               \#printf\#   \#vfprintf\#   \#vprintf\#   \#vprintf\#
               \#fprintf\#
\end

screen( capsensitive("sqrt") )
Name           Øsquare rootÆ - Liefert die Quadratwurzel des Arguments

Definition     double  sqrt( double x );

Prototyp in    math.h

Beschreibung   sqrt berechnet die Quadratwurzel des Argumentes x.

Ergebnis       Wenn x negativ ist, wird \#errno\# der Wert EDOM
               zugewiesen. 
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#pow\#
\end

screen( capsensitive("srand") )
Name           Øseed random [generator]Æ - Setzt einen Startwert fÅr
               die Erzeugung von ØZufallszahlenÆ

Definition     void  srand( unsigned seed );

Prototyp in    stdlib.h

Beschreibung   mit srand kann der Startwert fÅr \#rand\# gesetzt werden.
               Der ØZufallszahlen-GeneratorÆ wird beim Start des
               Programms mit dem Wert 1 initialisiert - Åber einen
               Aufruf von srand kann jederzeit ein neuer (und
               beliebiger) Startwert gesetzt werden. Folgen von
               ØZufallszahlenÆ sind von einem gegebenen Startwert aus
               beliebig oft reproduzierbar.

Ergebnis       srand hat kein direktes Funktionsergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#rand\#
\end

screen( capsensitive("sscanf") )
Name           Østring scan formattedÆ - Liest den Inhalt eines
               Strings als formatierte Eingabe

Definition     int  sscanf( char *buffer, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   sscanf liest eine Stringvariable (d.h. den durch
               buffer angegebenen Speicherbereich) in formatierter
               Form und erwartet zumindest einen \link("Format-String (printf)")Format-String\#
               Åber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       sscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurÅck, wobei mit *
               unterdrÅckte Felder nicht gezÑhlt werden.
               Wenn Åberhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, Åber das Ende einer Datei bzw. Åber das
               Ende eines Strings hinaus zulesen, ergibt
               den Wert EOF als Funktionsergebnis.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#fscanf\#  \#vsscanf\#
\end

screen( capsensitive("vsscanf") )
Name           Østring scan formattedÆ - Liest den Inhalt eines
               Strings als formatierte Eingabe

Definition     #include <stdarg.h>
               int  vsscanf( char *string, const char *format,
                             \#va_list\# param );

Prototyp in    stdio.h

Beschreibung   Die v...scanf-Funktionen verhalten sich Ñhnlich wie
               ihre ...scanf-GegenstÅcke, sie akzeptieren jedoch
               einen Pointer auf eine Liste von Argumenten anstelle
               der Liste selber.
               vsscanf liest eine Stringvariable (d.h. den durch
               buffer angegebenen Speicherbereich) in formatierter
               Form und erwartet zumindest einen \link("Format-String (printf)")Format-String\#
               Åber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       vsscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurÅck, wobei mit *
               unterdrÅckte Felder nicht gezÑhlt werden.
               Wenn Åberhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, Åber das Ende einer Datei bzw. Åber das
               Ende eines Strings hinaus zulesen, ergibt
               den Wert EOF als Funktionsergebnis.

PortabilitÑt   vsscanf ist auf UNIX-Systemen verfÅgbar.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#fscanf\#  \#sscanf\#
\end

screen( capsensitive("strerror") )
Name           Østring errorÆ - Liefert Strings mit System-
               fehlermeldungen

Definition     char  *strerror( int errnum );

Prototyp in    string.h

Beschreibung   strerror dient zur Abfrage, welche Fehlermeldung
               ausgegeben wird, wenn \#errno\# den Wert errnum annimmt.

Ergebnis       strerror liefert einen Zeiger auf die mit errnum
               angegebene Fehlermeldung.

Querverweis    \#perror\#

Gruppe         \#I/O-Routinen\#
\end

screen( capsensitive("strcat") )
Name           Østring concatenateÆ - HÑngt einen String an einen
               anderen an

Definition     char  *strcat( char *dest, const char *src );

Prototyp in    string.h

Beschreibung   strcat hÑngt sÑmtliche Zeichen von src an die bereits
               in dest vorhandenen Zeichen an (die LÑnge von dest
               wird also um strlen(src) erhîht).

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf das erste Zeichen
               von dest.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strncat") )
Name           Østring number concatenateÆ - HÑngt eine bestimmte
               Anzahl von Zeichen aus einem String an einen anderen
               an (Verbindung)

Definition     char  *strncat( char *dest, const char *src,
                                size_t maxlen );

Prototyp in    string.h

Beschreibung   strncat hÑngt die ersten maxlen Zeichen von src an die
               bereits in dest vorhandenen Zeichen an. Die Operation
               wird beendet, wenn entweder maxlen Zeichen kopiert
               wurden oder das Ende von src erreicht ist.
               Als letztes schreibt strncat grundsÑtzlich ein
               Nullzeichen in dest.

Ergebnis       Danach wird ein Zeiger auf das erste Zeichen von dest
               zurÅckgeliefert.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("strchr") )
Name           Østring characterÆ - Sucht einen String nach einem
               bestimmten Zeichen ab

Definition     char  *strchr( const char *s, int c );

Prototyp in    string.h

Beschreibung   strchr sucht den Åber s angegebenen String nach dem
               Zeichen c ab, wobei die Suche mit dem ersten Zeichen
               von s beginnt.

Ergebnis       strchr liefert einen Zeiger auf die erste Fundstelle
               des Zeichens c zurÅck bzw. den Wert \link("%%GLOBAL%%")NULL\#, wenn der
               String dieses Zeichen nicht enthÑlt. Das abschlieûende
               Nullzeichen wird zum Stringinhalt gerechnet - ein
               Aufruf wie strchr( stringx, 0 ) liefert also einen
               Zeiger auf das Nullzeichen von stringx.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strrev") )
Name           Østring reverseÆ - Dreht die Reihenfolge der Zeichen
               eines Strings um

Definition     char  *strrev( char *s );

Prototyp in    string.h

Beschreibung   strrev invertiert den Åber s angegebenen String.

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf das erste Zeichen
               von s.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strrchr") )
Name           Østring right characterÆ - Sucht einen String nach dem
               letzten Erscheinen eines bestimmten Zeichens ab
               (Absuche)

Definition     char  *strrchr( const char *s, int c );

Prototyp in    string.h

Beschreibung   strrchr sucht den Åber s angegebenen String nach dem
               Zeichen c ab, wobei die Suche mit dem letzten Zeichen
               von s beginnt.

Ergebnis       strrchr liefert einen Zeiger auf die erste (ØrechtesteÆ)
               Fundstelle des Zeichens c zurÅck bzw. den Wert \link("%%GLOBAL%%")NULL\#,
               wenn der String dieses Zeichen nicht enthÑlt. Das
               abschlieûende Nullzeichen wird zum Stringinhalt
               gerechnet und als erstes verglichen - ein Aufruf wie
               strrchr( stringx,0 ) liefert also einen Zeiger auf das
               Nullzeichen von stringx.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strcmp") )
Name           Østring compareÆ - Vergleicht zwei Strings.

Definition     int  strcmp( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strcmp vergleicht die Inhalte von s1 und s2 miteinander.

Ergebnis       ZurÅckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert grîûer 0, wenn s1
               grîûer als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#  \#stricmp\#
\end

screen( capsensitive("strncmp") )
Name           Østring number compareÆ -  Vergleicht eine bestimmte
               Anzahl von Zeichen miteinander.

Definition     int  strncmp( char *s1, char *s2, size_t maxlen );

Prototyp in    string.h

Beschreibung   strncmp vergleicht maximal die ersten maxlen Zeichen
               von s1 und s2 miteinander.

Ergebnis       ZurÅckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert grîûer 0, wenn s1
               grîûer als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#  \#strnicmp\#
\end

screen( capsensitive("strcmpi"),
		capsensitive("stricmp") )
Name           Østring compare ignore caseÆ - Vergleicht zwei Strings
               ohne Unterscheidung zwischen Groû- und Kleinschreibung.

Definition     int  stricmp( const char *s1, const char *s2 );
               int  strcmpi( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   stricmp und strcmpi sind zwei identische Funktionen.
               Beide vergleichen zwei Strings miteinander, ohne
               zwischen Groû- und Kleinschreibung zu unterscheiden.
               Ansonsten wird der Vergleich wie bei \#strcmp\#
               durchgefÅhrt.
               Achtung: Deutsche Umlaute werden dennoch nach groû/
                        klein unterschieden (s. ATARI-Zeichensatz).

Ergebnis       ZurÅckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert grîûer 0, wenn s1
               grîûer als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#   \#strcmp\#   \#stricmp\#   \#strcmpi\#
               \#strncmp\#   \#strnicmp\#   \#strncmpi\#
\end

screen( capsensitive("strnicmp"),
		capsensitive("strncmpi") )
Name           Østring number compare ignore caseÆ - Vergleicht eine
               bestimmte Anzahl von Zeichen miteinander ohne
               Unterscheidung zwischen Groû- und Kleinschreibung.

Definition     int  strnicmp( const char *s1, const char *s2,
                               size_t n );
               int  strncmpi( const char *s1, const char *s2,
                               size_t n );

Prototyp in    string.h

Beschreibung   strnicmp und strncmpi sind zwei identische Funktionen.
               Beide vergleichen die n ersten Zeichen zweier Strings
               miteinander, ohne zwischen Groû- und Kleinschreibung zu
               unterscheiden. Ansonsten wird der Vergleich wie bei
               \#strncmp\# durchgefÅhrt.
               Achtung: Deutsche Umlaute werden dennoch nach groû/
                        klein unterschieden (s. ATARI-Zeichensatz).

Ergebnis       ZurÅckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert grîûer 0, wenn s1
               grîûer als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#   \#strncmp\#
\end

screen( capsensitive("strcpy") )
Name           Østring copyÆ - Kopiert einen String in einen
               anderen

Definition     char  *strcpy( char *dest, const char *src );

Prototyp in    string.h

Beschreibung   strcpy kopiert den Inhalt des Åber src angegebenen
               Strings in den durch dest angegebenen Speicherbereich.
               Das abschlieûende Nullzeichen von src wird als letztes
               Byte kopiert.

Ergebnis       die Startadresse von dest wird als Funktionsergebnis
               zurÅckgeliefert.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strncpy") )
Name           Østring number copyÆ - Kopiert eine bestimmte Anzahl
               von Zeichen

Definition     char  *strncpy( char *dest, const char *src,
                                size_t maxlen );

Prototyp in    string.h

Beschreibung   strncpy kopiert maxlen Zeichen des Åber src angegebenen
               Strings in den durch dest angegebenen Speicherbereich.
               strncpy kopiert immer genau maxlen Zeichen - wenn src
               weniger als maxlen Zeichen enthÑlt, wird eine
               entsprechende Anzahl von Nullzeichen in dest angehÑngt
               wenn src mehr als maxlen Zeichen umfaût, bleibt der
               nach dest kopierte String ohne ein abschlieûendes
               Nullzeichen.

Ergebnis       strncpy liefert in allen FÑllen einen Zeiger auf das
               erste Byte von dest zurÅck.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
Querverweis    \#size_t\#
\end

screen( capsensitive("strlen") )
Name           Østring lengthÆ - Sucht nach dem Ende eines Strings
               und liefert seine LÑnge zurÅck

Definition     \#size_t\#  strlen( const char *s );

Prototyp in    string.h

Beschreibung   Der angegebene String wird nicht verÑndert.

Ergebnis       strlen liefert die LÑnge des angegebenen Strings
               als unsigned long. Die Null wird nicht mitgezÑhlt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strstr") )
Name           Østring stringÆ - Sucht einen String nach dem Vorkommen
               eines anderen Strings ab

Definition     char  *strstr( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strstr sucht den Åber s1 angegebenen String nach
               dem ersten Vorkommen von s2 ab (im Gegensatz zu
               strspn und strcspn findet hier ein direkter Vergleich
               statt - die Reihenfolge der Zeichen in s1 und s2
               spielt also eine Rolle).

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf den Beginn von s2
               in s1 bzw. der Zeigerwert \link("%%GLOBAL%%")NULL\#, wenn s2 in s1 Åberhaupt
               nicht vorkommt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strcspn\#
\end

screen( capsensitive("strlwr") )
Name           Østring lowercaseÆ - éndert alle Groûbuchstaben in
               Kleinbuchstaben

Definition     char  *strlwr( char *s );

Prototyp in    string.h

Beschreibung   strlwr verÑndert sÑmtliche Groûbuchstaben des via s
               Åbergebenen Strings in Kleinbuchstaben (die deutschen
               Umlaute werden nicht berÅcksichtigt).
Ergebnis       strlwr liefert einen Zeiger auf das erste Zeichen
               dieses Strings zurÅck.
Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strupr") )
Name           Østring uppercaseÆ - Verwandelt alle Kleinbuchstaben
               in Groûbuchstaben

Definition     char  *strupr( char *s );

Prototyp in    string.h

Beschreibung   strupr verÑndert sÑmtliche Kleinbuchstaben des via s
               Åbergebenen Strings in Groûbuchstaben (die deutschen
               Umlaute werden nicht berÅcksichtigt).

Ergebnis       strupr liefert einen Zeiger auf das erste Zeichen
               dieses Strings zurÅck.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strcspn") )
Name           Østring counter set positionÆ - Liefert die LÑnge
               des Teilstrings von s1 zurÅck, der keines der Zeichen
               von s2 enthÑlt

Definition     size_t  strcspn(const char *s1, const char *s2);

Prototyp in    string.h

Beschreibung   strcspn vergleicht s1 ab dem ersten Zeichen mit
               dem in s2 enthaltenen Zeichensatz. Wenn das
               Zeichen nicht in s2 enthalten ist, geht der
               Vergleich mit dem nÑchsten Zeichen von s1
               weiter - solange, bis entweder das letzte Zeichen
               von s1 verglichen wurde (Funktionsergebnis: LÑnge
               von s1) oder sich eine öbereinstimmung ergibt
               (Funktionsergebnis: Position des ersten gefundenen
               Zeichens - also die LÑnge des Teilstrings von s1,
               der keines der Zeichen von s2 enthÑlt. Die Reihen-
               folge der Zeichen in s2 spielt keine Rolle.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strdup") )
Name           Østring duplicateÆ - Dupliziert einen String

Definition     char  *strdup( const char *s );

Prototyp in    string.h

Beschreibung   strdup dupliziert einen String an eine andere Adresse.
               Der Speicher wird per malloc dynamisch angelegt.

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf das erste Zeichen
               des duplizierten Strings.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strset") )
Name           Østring setÆ - FÅllt einen String mit einem
               Zeichen

Definition     char  *strset( char *s, int c );

Prototyp in    string.h

Beschreibung   strset Åberschreibt alle Zeichen des via s
               Åbergebenen Strings mit dem Zeichen c.

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf das erste
               Zeichen von s.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strnset\#
\end

screen( capsensitive("strnset") )
Name           Østring number setÆ - FÅllt einen Stringteil mit einem
               Zeichen

Definition     char  *strnset( char *s, int c, size_t n );

Prototyp in    string.h

Beschreibung   strnset Åberschreibt die ersten n Zeichen des via
               s Åbergebenen Strings mit dem Zeichen c. n wird
               automatisch begrenzt, d.h. strnset schreibt nicht
               Åber das Stringende ('') hinaus.

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf das erste
               Zeichen von s.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strset\#
\end

screen( capsensitive("strpbrk") )
Name           Østring pointer breakÆ - Sucht einen String nach dem
               ersten Auftreten bestimmter Zeichen ab

Definition     char  *strpbrk( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strpbrk sucht den Åber s1 angegebenen String nach
               dem ersten Vorkommen eines der in s2 enthaltenen
               Zeichen ab.

Ergebnis       ZurÅckgeliefert wird ein Zeiger auf die erste
               Fundstelle bzw. der Wert \link("%%GLOBAL%%")NULL\#, wenn keines der
               durch s2 festgelegten Zeichen in s1 enthalten ist.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strspn") )
Name           Østring set positionÆ - Berechnet die LÑnge des
               Teilstrings, der ausschlieûlich aus Zeichen eines
               zweiten Strings besteht.

Definition     size_t  strspn( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strspn ist das GegenstÅck zu \#strcspn\#:
               Beginnend mit dem ersten Zeichen wird der Inhalt
               von s1 mit dem Åber s2 angegebenen Zeichensatz
               verglichen. Wenn das Zeichen in s2 enthalten ist,
               geht es mit dem nÑchsten Zeichen von s1 weiter,
               solange, bis entweder das Ende von s1 erreicht ist
               (Funktionsergebnis: LÑnge von s1) oder der Vergleich
               fehlschlÑgt (Funktionsergebnis: Position des ersten
               nicht Åbereinstimmenden Zeichens - also die LÑnge
               des Teilstrings von s1, der ausschlieûlich aus
               Zeichen besteht, die in s2 enthalten sind).
               Die Reihenfolge der Zeichen in s2 spielt keine Rolle.
               Wenn bereits das erste Zeichen von s1 nicht in s2
               enthalten ist, dann liefert strspn das Ergebnis 0.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strtok") )
Name           Østring tokenÆ - Sucht einen String nach der ersten
               von mehreren Zeichenfolgen ab

Definition     char  *strtok( char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strtok betrachtet den Åber s1 angegebenen String als
               Folge von ØTokensÆ, die voneinander durch die in s2
               definierten Zeichenfolgen getrennt sind. Wenn s1
               beispielsweise den Inhalt "ein String,mit,,Tokens"
               hat und s2 den Inhalt " , ", dann liefern
               aufeinanderfolgende Aufrufe von strtok die ØTokensÆ
               ein, String, mit und Tokens.

Ergebnis       Der erste Aufruf von strtok liefert einen Zeiger auf
               den Beginn des ersten gefundenen ØTokensÆ in s1 zurÅck
               und setzt ein Nullzeichen unmittelbar hinter das Ende
               (in unserem Beispiel also direkt hinter die
               Zeichenfolge ein.
               Folgende Aufrufe von strtok mit dem Wert \link("%%GLOBAL%%")NULL\#
               anstelle des Arguments s1 liefern Zeiger auf weitere
               Tokens zurÅck, bis der ursprÅngliche String zuende
               gelesen ist. s1 wird wÑhrend der Analyse durch das
               EinfÅgen von Nullzeichen verÑndert, s2 kann bei jedem
               Aufruf von strtok beliebig gewechselt werden.
               Wenn kein (weiteres) ØTokenÆ gefunden wird, liefert
               strtok das Ergebnis \link("%%GLOBAL%%")NULL\#.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strtod") )
Name           (Østring to doubleÆ) - Interpretiert einen String
               als einen \link("%%GLOBAL%%")double\#-Wert

Definition     double  strtod( const char *s, char **endptr );

Prototyp in    stdlib.h

Beschreibung   strtod interpretiert den via s Åbergebenen String
               als \link("%%GLOBAL%%")double\#. Der Stringinhalt muû das folgende Format
               haben (vgl. \#atof\#):

               [wl] [+|-] [ddd] [.ddd] [e|E [+|-] ddd]

               [wl] steht hier fÅr Øweiûe LeerzeichenÆ, [+|-] fÅr ein
               (optionales) Vorzeichen und [ddd] fÅr ein oder mehrere
               Dezimalziffern. Wenn ein Exponent angegeben wird, dann
               kann dieser Exponent ein Vorzeichen enthalten.
               Beispiele fÅr gÅltige Angaben sind:
               +1234.1981e-1, 502.3489576, -.34576e8
               strtod bricht die Analyse beim ersten Zeichen ab, das
               nicht mehr als zu einer Flieûkommazahl gehîrig
               interpretiert werden kann.
               Solange der Parameter endptr nicht als \link("%%GLOBAL%%")NULL\# angegeben
               ist, wird er von strtod auf das Zeichen innerhalb von s
               gesetzt, durch das die Analyse abgebrochen wurde.

Ergebnis       strtod liefert das Ergebnis der Interpretation als
               \link("%%GLOBAL%%")double\# zurÅck - wenn sich die Åbergebene Zeichenkette
               Åberhaupt nicht analysieren lÑût, dann ist das
               Ergebnis HUGE_VAL und \#errno\# wird entsprechend gesetzt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strtol\#   \#strtoul\#
\end

screen( capsensitive("strtol") )
Name           Østring to longÆ - Interpretiert einen String als
               einen long-Wert

Definition     long  strtol( const char *s, char **endptr, int radix );

Prototyp in    string.h

Beschreibung   strtol interpretiert den via s Åbergebenen String als
               long im durch radix angegebenen Zahlensystem.
               (radix = 10: Interpretation als Dezimalzahl;
               radix = 16:  Interpretation als Hexadezimalzahl usw.).
               ZulÑssige Werte fÅr diesen Parameter liegen im Bereich
               von 2..36.
               Die in s enthaltene Zeichenfolge muû das folgende
               Format haben (vgl. \#atol\#):

               [wl] [+|-] [0] [x|X] [ddd]

               [wl] steht hier fÅr Øweiûe LeerzeichenÆ, [+|-] fÅr ein
               optionales Vorzeichen. Eine Ziffernfolge, die mit 0
               (oktal), 0x oder 0X (hexadezimal) beginnt, wird von
               strtol automatisch in diesem Format interpretiert,
               wenn fÅr radix der Wert 0 angegeben ist. (FÅr alle
               anderen Werte von radix wird eine fÅhrende Null
               schlicht ignoriert, ein fÅhrendes 0x oder 0X ist
               ØungÅltigÆ und erzeugt das Funktionsergebnis 0).

               strtol bricht die Analyse beim ersten Zeichen ab, das
               nicht mehr als dem Wert zugehîrig interpretiert werden+
               kann. Wenn fÅr den Parameter endptr die Adresse eines
               Zeigers angegeben wurde (und nicht der Wert \link("%%GLOBAL%%")NULL\#),
               dann wird dieser Zeiger auf die Adresse des nicht
               analysierbaren Zeichens in s gesetzt.
               Als Ønicht zugehîrigÆ gelten alle Zeichen, die bei
               einem durch radix festgelegten Zahlensystem keine
               gÅltigen Ziffern darstellen (im Dezimalsystem: alle
               Zeichen auûer '0'..'9'; im Oktalsystem: nur die
               Ziffern '0'..'7'; bei einem Wert von 5 fÅr radix nur
               die Ziffern '0'..'4' usw.).

Ergebnis       strtol liefert das Ergebnis der Interpretation als long
               zurÅck. Wenn der String Åberhaupt nicht numerisch
               auswertbar ist oder fÅr radix ein Wert auûerhalb der
               Grenzen 2..36 angegeben wurde, dann ist das Ergebnis 0,
               **endptr wird (soweit nicht als \link("%%GLOBAL%%")NULL\# angegeben) auf
               das erste Zeichen von s gesetzt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strtoul") )
Name           Østring to unsigned longÆ - Interpretiert einen String
               als einen unsigned long-Wert

Definition     unsigned long  strtoul( const char *s, char **endptr,
                                        int radix );

Prototyp in    string.h

Beschreibung   strtoul interpretiert den via s Åbergebenen String als
               unsigned long im durch radix angegebenen Zahlensystem.
               (radix = 10: Interpretation als Dezimalzahl;
               radix = 16:  Interpretation als Hexadezimalzahl usw.).
               ZulÑssige Werte fÅr diesen Parameter liegen im Bereich
               von 2..36. Die in s enthaltene Zeichenfolge muû das
               folgende Format haben (vgl. \#atol\#):

               [wl] [+|-] [0] [x|X] [ddd]

               [wl] steht hier fÅr Øweiûe LeerzeichenÆ, [+|-] fÅr ein
               optionales Vorzeichen. Eine Ziffernfolge, die mit 0
               (oktal), 0x oder 0X (hexadezimal) beginnt, wird von
               strtoul automatisch in diesem Format interpretiert,
               wenn fÅr radix der Wert 0 angegeben ist. (FÅr alle
               anderen Werte von radix wird eine fÅhrende Null
               schlicht ignoriert, ein fÅhrendes 0x oder 0X ist
               ØungÅltigÆ und erzeugt das Funktionsergebnis 0).

               strtoul bricht die Analyse beim ersten Zeichen ab, das
               nicht mehr als dem Wert zugehîrig interpretiert werden
               kann. Wenn fÅr den Parameter endptr die Adresse eines
               Zeigers angegeben wurde (und nicht der Wert \link("%%GLOBAL%%")NULL\#), dann
               wird dieser Zeiger auf die Adresse des nicht
               analysierbaren Zeichens in s gesetzt.
               Als Ønicht zugehîrigÆ gelten alle Zeichen, die bei
               einem durch radix festgelegten Zahlensystem keine
               gÅltigen Ziffern darstellen (im Dezimalsystem: alle
               Zeichen auûer '0'..'9'; im Oktalsystem: nur die
               Ziffern '0'..'7'; bei einem Wert von 5 fÅr radix nur
               die Ziffern '0'..'4' usw.).

Ergebnis       strtoul liefert das Ergebnis der Interpretation als
               unsigned long  zurÅck. Wenn der String Åberhaupt nicht
               numerisch auswertbar ist oder fÅr radix ein Wert
               auûerhalb der Grenzen 2..36 angegeben wurde, dann ist
               das Ergebnis 0L, **endptr wird (soweit nicht als \link("%%GLOBAL%%")NULL\#
               angegeben) auf das erste Zeichen von s gesetzt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strftime") )
Name           Østring format timeÆ - Spezielle Formatierung eines
               Strings fÅr die Ausgabe von Uhrzeit und Datum

Definition     size_t  strftime( char *s, size_t max_size,
                                  const char *format,
                                  const struct tm *timeptr );
Prototyp in    time.h

Beschreibung   Die Funktion strftime schreibt hîchstens max_size
               Zeichen in den String s. Der String format dient zur
               Formatierung der Zeitangabe in der Struktur \#tm\#.
               Die Zeichen im String werden wie bei der Funktion
               printf behandelt, wobei jedoch folgende spezielle
               Formatier-Angaben verwendet werden:

                      %a  abgekÅrzter Wochentag
                      %A ausgeschriebener Wochentag
                      %b abgekÅrzter Monatsname
                      %B voller Monatsname
                      %c Datum und Uhrzeit
                      %d Tag im Monat (1-31)
                      %H Stunde (0-23)
                      %I Stunde (0-12)
                      %j Tag im Jahr (1-366)
                      %m Monat (1-12)
                      %M Minute (00-59)
                      %p AM/PM
                      %S Sekunde (00-59)
                      %w Wochentag (0-6)
                      %W Woche im Jahr (0-52)
                      %x lokale Datumsdarstellung
                      %X lokale Zeit-Darstellung
                      %y Jahr ohne Jahrhundert (0-99)
                      %Y Jahr mit Jahrhundertangabe
                      %Z Name der Zeitzone (z.B. MEZ)
                      %% das Ø%Æ-Zeichen

Ergebnis       strftime liefert als Ergebnis die GesamtlÑnge des
               Strings.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#   \#size_t\#   \#localtime\#   \#gmtime\#
\end

screen( capsensitive("system") )
Name           ØsystemÆ - öbergibt einen Befehl an einen Kommando-
               interpreter zur AusfÅhrung

Definition     int  system( const char *command );

Prototyp in    stdlib.h

Beschreibung   Die Kommandozeile command wird an einen Kommando-
               interpreter Åbergeben und in einer impelementations-
               abhÑngigen Art und Weise ausgefÅhrt. Vorausetzung fÅr
               die Benutzung dieser Funktion ist, daû Sie eine Shell
               verwenden, die die Systemvariable _shell_p oder das
               Setzen von Environmentvariablen unterstÅtzt. _shell_p
               enthÑlt die Adresse einer Routine, die eine Shell
               starten kann. Die Environmentvariable "SHELL" spezifi-
               ziert den Pfadnamen einer Shell.

Ergebnis       Falls kein Kommandointerpreter verfÅgbar ist, wird 0
               zurÅckgeliefert.
               Wird fÅr command NULL Åbergeben, erhÑlt man einen Wert
               != 0 zurÅck, wenn ein Kommandointerpreter verfÅgbar
               ist. In allen anderen FÑllen erhÑlt man einen
               implementationsabhÑngigen RÅckgabewert.

Beispiel       #include <stdlib.h>

               int  main( void )
               {
                   if( system( NULL ) != 0 )
                       system("del *.*");

                   return( 0 );
               }

Gruppe         \#Prozess-Routinen\#
\end

screen( capsensitive("tan") )
Name           ØtangentÆ - Liefert den Tangens des Arguments

Definition     double  tan( double x );

Prototyp in    math.h

Beschreibung   tan erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * „, 90 Grad = „/2, 180 Grad = „, 270 Grad = 1.5 * P,
               360 Grad = 2 * „ usw.) als Argument und liefert den
               dazugehîrigen Tangens zurÅck. öbergebene Werte werden
               automatisch auf den Bereich 0..2 * „ reduziert.
               Der Wert von „ (3.1415...) ist in math.h als Konstante
               mit dem Namen M_PI definiert

Ergebnis       tan liefert Werte unbegrenzter Grîûe, solange das
               Argument nicht zu dicht an P/2 oder -P/2 liegt - falls
               das Funktionsergebnis nicht mehr berechnet werden kann,
               wird der Wert 0 zurÅckgeliefert und \#errno\# bekommt den
               folgenden Wert ERANGE.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#   \#atan\#   \#atan2\#
\end

screen( capsensitive("tanh") )
Name           Øtangent hyperbolicÆ - Liefert den Tangens hyperbolicus
               des Arguments

Definition     double  tanh( double x );

Prototyp in    math.h

Beschreibung   tanh berechnet den Tangens hyperbolicus des Arguments,

Ergebnis       Bei fehlerfreier AusfÅhrung liefert die Funktion
               das entsprechende Ergebnis. Bei öberlÑufen wird
               HUGE_VAL (mit korrektem Vorzeichen) zurÅckgeliefert und
               \#errno\# bekommt den Wert ERANGE.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atan\#   \#atan2\#
\end

screen( capsensitive("atanh") )
Name           Øarcus tangent hyperbolicÆ - Liefert den Arcus Tangens
               hyperbolicus des Arguments

Definition     double  atanh( double x );

Prototyp in    math.h

Beschreibung   atanh berechnet den Arcus Tangens hyperbolicus des
               Arguments und erwartet Werte im Bereich von [-1,+1].

Ergebnis       Bei fehlerfreier AusfÅhrung liefert die Funktion
               das entsprechende Ergebnis. Bei ungÅltigen Eingabe-
               werten erhÑlt \#errno\# den Wert EDOM.
               Die Behandlung von Fehlern kann Åber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atan\#   \#tanh\#   \#atan2\#
\end

screen( capsensitive("xdcnv") )
Name           Ødouble extended to 8-Byte-doubleÆ - Konvertiert einen
               double(10 Byte) ins 8-Byte \link("%%GLOBAL%%")Flieûkommaformat\#

Definition     void  xdcnv( double *oldval, void *rep8bytes );

Prototyp in    math.h

Beschreibung   xdcnv konvertiert den Åber val angegebenen double ins
               8-Byte \link("%%GLOBAL%%")Flieûkommaformat\# an die mit rep8bytes angegebene
               Adresse.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#dxcnv\#
\end

screen( capsensitive("dxcnv") )
Name           Ø8-Byte-double to extended doubleÆ - Konvertiert einen
               double im 8-Byte \link("%%GLOBAL%%")Flieûkommaformat\# ins 10 Byte
               \link("%%GLOBAL%%")Flieûkommaformat\#

Definition     void  dxcnv( void *rep8bytes, double *val );

Prototyp in    math.h

Beschreibung   dxcnv konvertiert den Åber die Adresse rep8bytes
               Åbergebenen 8-Byte double ins 10-Byte \link("%%GLOBAL%%")Flieûkommaformat\#

Ergebnis       Die Funktion schreibt den konvertierten double an die
               Adresse val.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#xdcnv\#
\end

screen( capsensitive("fpumode") )
Name           Øfloatingpoint unit modeÆ - Liefert den Status des
               Flieûkomma-Koprozessors

Definition     int  fpumode( int disable );

Prototyp in    math.h

Beschreibung   Wird disable = 1 Åbergeben, so wird der Koprozessor
               von den \#Gleitkomma-Befehle\#n nicht angesprochen.
               Mit disable = 0 kann er wieder angesprochen werden,
               sofern er vorhanden ist.

Ergebnis       Die Funktion liefert den Status des Flieûkomma-
               Koprozessors:
                   1:  MC 68881 vorhanden und aktiv
                   0:  MC 68881 nicht vorhanden oder nicht aktiv

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#xdcnv\#
\end

screen( capsensitive("time") )
Name           ØtimeÆ - Liefert Datum und Uhrzeit des Systems

Definition     time_t  time( time_t *timer );

Prototyp in    time.h

Beschreibung   time setzt die via timer Åbergebene Variable auf die
               Anzahl der Sekunden, die seit dem 1. Januar 1970,
               0 Uhr 00:00 (ØGreenwich Mean TimeÆ) verstrichen sind.
               Die Angabe des Zeigerwertes \link("%%GLOBAL%%")NULL\# fÅr timer ist zulÑssig
               in diesem Fall liefert time das Funktionsergebnis ohne
               Speicherung.

Ergebnis       time liefert die Anzahl der seit dem 1.1.1970
               verstrichenen Sekunden auch als Funktionsergebnis
               zurÅck.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#   \#time_t\#  \link("time, struct time")struct time\#
\end

screen( capsensitive("tmpnam") )
Name           Øtemporary file nameÆ - Liefert einen String, der als
               temporÑrer Dateiname verwendet werden kann

Definition     char  *tmpnam( char *str );

Prototyp in    stdio.h

Beschreibung   Die Funktion tmpnam erzeugt einen String, der als
               Dateiname verwendet werden kann und garantiert nicht
               mit einer bereits existierenden Datei identisch ist.
               Die Funktion kann mehrmals hintereinander aufgerufen
               werden und erzeugt dann immer neue Dateinamen. Wie oft
               diese Funktion aufgerufen werden kann, hÑngt von der
               Konstanten TMP_MAX ab. Wenn tmpnam îfter als in
               TMP_MAX angegeben aufgerufen wird, ist das Ergebnis
               nicht definiert. tmpnam verwendet den unter str
               angelegten Puffer. Wenn als Parameter str der Wert
               \link("%%GLOBAL%%")NULL\# Åbergeben wurde, dann legt tmpnam den Puffer
               fÅr den Dateinamen selbstÑndig an.

Ergebnis       Die Funktion liefert als Ergebnis einen Zeiger auf
               einen temporÑren Dateinamen.

Gruppe         \#I/O-Routinen\#

Querverweis    \#tmpfile\#
\end

screen( capsensitive("tmpfile") )
Name           Øtemporary fileÆ - Erzeugt eine temporÑre Datei

Definition     FILE  *tmpfile( void );

Prototyp in    stdio.h

Beschreibung   Die Funktion tmpfile legt eine temporÑre BinÑrdatei an,
               die mit dem Zugriffsmodus Read/Write erîffnet wird. Die
               Datei wird wieder entfernt, wenn die Datei geschlossen
               wird.

Ergebnis       Die Funktion liefert als Ergebnis den Handle der
               temporÑr angelegten Datei. Wenn die Datei nicht
               angelegt werden konnte, dann erhÑlt man als Ergebnis
               einen \link("%%GLOBAL%%")NULL\#-Zeiger.

Gruppe         \#I/O-Routinen\#

Querverweis    \#tmpnam\#
\end

screen( capsensitive("toascii") )
Name           Øto ASCIIÆ - Konvertierung von Zeichen in das
               ASCII-Format

Definition     int  toascii( int c );

Prototyp in    ctype.h

Beschreibung   toascii begrenzt den Wert c (durch eine AND-Operation
               mit 0x7f) auf den Bereich 0..127.

Ergebnis       toascii liefert das Ergebnis dieser Begrenzung als
               Integer zurÅck.

Querverweis    \#tolower\#   \#toupper\#

Gruppe         \#Umwandlungsroutinen\#
\end

screen( capsensitive("tolower") )
Name           Øto lowercaseÆ - PrÅft auf ØGroûbuchstabeÆ und wandelt
               gegebenenfalls in einen Kleinbuchstaben um

Definition     int  tolower( int c );

Prototyp in    ctype.h

Beschreibung   tolower ist eine Funktion, die das Åbergebene Zeichen c
               in einen Kleinbuchstaben verwandelt. Damit diese
               Funktion korrekt arbeitet, muû c einen Wert im Bereich
               von 0..255 oder den Wert EOF haben.

Ergebnis       Die Funktion liefern das Ergebnis ihrer Konvertierung
               als int zurÅck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#toupper\#
\end

screen( capsensitive("toupper") )
Name           Øto uppercaseÆ - PrÅft auf ØKleinbuchstabeÆ und wandelt
               gegebenenfalls in einen Groûbuchstaben um

Definition     int  toupper( int c );

Prototyp in    ctype.h

Beschreibung   toupper ist eine Funktion, die das Åbergebene Zeichen c
               in einen Groûbuchstaben verwandelt. Damit diese
               Funktion korrekt arbeitet, muû c einen Wert im Bereich
               von 0..255 oder den Wert EOF haben.

Ergebnis       Die Funktion liefert das Ergebnis ihrer Konvertierung
               als int zurÅck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#tolower\#
\end

screen( capsensitive("ungetc") )
Name           Øunget characterÆ - Stellt ein aus einem stream
               gelesenes Zeichen zurÅck

Definition     int  ungetc( int c, FILE *stream );

Prototyp in    stdio.h

Beschreibung   ungetc stellt ein Zeichen fÅr eine erneute
               Leseoperation zurÅck, ist also tatsÑchlich das
               Gegenteil von \#getc\#. Praktisch zu jedem Zeitpunkt
               kann ein Zeichen zurÅckgestellt und spÑter mit
               \#getc\# wieder gelesen werden. Es wird immer nur ein
               Zeichen gespeichert. Die Anwendung von \#fseek\# oder
               \#rewind\# auf eine Datei lîscht deren Puffer und damit
               auch ein eventuell mit ungetc zurÅckgestelltes Zeichen.

Ergebnis       ungetc liefert das zurÅckgestellte Zeichen als
               Funktionsergebnis, wenn die Aktion fehlerfrei
               ausgefÅhrt werden konnte - falls der entsprechende
               Puffer bereits besetzt ist, dann erhÑlt man den
               Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#getch\#   \#fgetc\#   \#getchar\#   \#ferror\#   \#fopen\#
               \#fread\#   \#fseek\#   \#gets\#      \#putc\#     \#read\#
               \#scanf\#
\end

screen( capsensitive("ultoa") )
Name           Øunsigned long to asciiÆ - Konvertiert einen unsigned
               long in einen String.

Definition     char  *ultoa( unsigned long value, char *string,
                              int radix );

Prototyp in    stdlib.h

Beschreibung   ultoa konvertiert den unsigned long value in einen
               nullterminierten String und speichert das Ergebnis
               in der durch String bezeichneten Variablen.
               Der Parameter radix legt die Basis fest auf der die
               konvertierung stattfinden soll - mîgliche Werte
               liegen im Bereich von 2 bis 36.
               ultoa erzeugt maximal 32 Zeichen.

Ergebnis       ultoa liefert einen Zeiger auf den gesetzten string
               zurÅck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#itoa\#   \#ltoa\#
\end

screen( capsensitive("unlink") )
Name           ØunlinkÆ - Lîscht eine Datei.

Definition     int  unlink( const char *filename );

Prototyp in    stdio.h

Beschreibung   unlink lîscht die durch filename angegebene Datei,
               wobei filename einen vollstÑndigen Suchweg und/oder
               einen Laufwerksbezeichner enthalten kann. Die Joker-
               zeichen '*' und '?' sind in filename nicht erlaubt.
               SchreibgeschÅtzte Dateien und Directories kînnen
               mit unlink nicht gelîscht werden. Um eine schreib-
               geschÅtzte Datei zu lîschen, muû zuerst das ent-
               sprechende Attribut entfernt werden.

Ergebnis       Bei fehlerfreier AusfÅhrung liefert unlink den Wert 0
               zurÅck. Im Falle eines Fehlers ist das Funktions-
               ergebnis -1 und \#errno\# bekommt einen der folgenden
               Werte:
                              ENOENT    EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#remove\#
\end

screen( capsensitive("va_list") )
va_list ist ein typloser Zeiger, der in STDARG.H definiert ist:

typedef void    *va_list;
\end

screen( capsensitive("va_...") )
Makros fÅr Funktionen mit variabler Parameterzahl
----------------------------------------------------------------------

Die Makros der Namensfamilie va_... ermîglichen es, Deklarationen
und Aufrufe von Funktionen mit variabler Parameterzahl ( z.B. printf )
in portabler Form zu halten.
Es wird in jedem Fall davon ausgegangen, daû die entsprechende
Funktion eine bestimmte Anzahl obligatorischer Parameter erwartet.
ZusÑtzliche Parameter kînnen schrittweise erfaût werden - auch dann,
wenn die Funktion selbst nicht ØweiûÆ, wieviele weitere Angaben zu
bearbeiten sind.
Um eine variable Anzahl von Parametern innerhalb einer Funktion zu
bearbeiten, sind die folgenden Schritte notwendig:
˘ Deklaration der Funktion mit mindestens einem fixen Parameter.
  Auf den oder die fixen Parameter folgen ein Komma und drei Punkte,
  also
  Ergebnistyp <Name>(parm1, parm2, ...)
  Die fixen Parameter kînnen innerhalb der Funktion wie gewîhnlich
  Åber ihre Namen angesprochen werden.
˘ Deklaration einer Zeigervariablen des (in stdarg.h definierten)
  Typs \#va_list\# innerhalb der Funktion sowie Deklaration lokaler
  Variablen, die in ihrem Typ den erwarteten variablen Parametern
  entsprechen.
˘ Aufruf von \#va_start\# mit zwei Parametern: dem Namen des zuvor
  deklarierten Zeigers (Typ va_list) und dem Namen des letzten fixen
  Parameters - in unserem Beispiel also
  \#va_start\#(argpoint, parm2);
  Dieser Aufruf ermittelt anhand des angegebenen letzten fixen
  Parameters, wo der erste variable Parameter gespeichert ist, und
  setzt argpoint entsprechend.
˘ Aufruf von \#va_arg\# mit zwei Parametern: dem zuvor mit \#va_start\#
  initialisierten Zeiger (argpoint) und dem Typ des ersten erwarteten
  variablen Parameters. Dieser Aufruf liefert den Wert des ersten
  variablen Parameters zurÅck und erhîht argpoint entsprechend:

    onearg = va_arg(argpoint, int);

  Weitere Aufrufe von \#va_arg\# - wieder mit argpoint, der angegebene
  Typ kann theoretisch ein anderer sein - liefern weitere variable
  Parameter zurÅck. Eine spezielle Erkennung fÅr Øletzter ParameterÆ
  gibt es nicht - hier muû irgendein Wert (wie 0, -1, \link("%%GLOBAL%%")NULL\# etc.)
  vereinbart werden.
˘ Nach der Auswertung sÑmtlicher Parameter muû ein Aufruf von \#va_end\#
  mit dem Zeiger (argpoint) als Parameter erfolgen. Dieser Aufruf
  setzt den Zeiger auf \link("%%GLOBAL%%")NULL\# zurÅck - wenn er fehlt, ergibt sich unter
  UmstÑnden ein ausgesprochen merkwÅrdiges Verhalten des Programms.

Querverweis \#printf\#, \#scanf\#
\end

screen( capsensitive("va_arg") )
Name           Øvariable argumentÆ - Liefert einen variablen Parameter
               einer Funktion zurÅck.

Definition     type  va_arg( \#va_list\# param, type );

Prototyp in    stdarg.h

Beschreibung   va_arg erwartet einen (zuvor via va_start
               initialisierten) Zeiger des Typs \#va_list\# (param) sowie
               einen Variablentyp (type), interpretiert den jeweils
               nÑchsten variablen Parameter der Funktion als Wert des
               angegebenen Typs und liefert ihn zurÅck. Danach wird
               der Zeiger um sizeof(type) erhîht.

Ergebnis       va_arg liefert den jeweils nÑchsten variablen
               Parameter der Funktion in dem durch type angegebenen
               Format zurÅck.

Gruppe         \link("Behandlung variabler Argument")Behandlung variabler Argumente\#

Querverweis    \#va_...\#   \#va_start\#   \#va_end\#   \#va_list\#
\end

screen( capsensitive("va_end") )
Name           Øvariable [argument] endÆ - Beendet die Auswertung
               variabler Parameter einer Funktion.

Definition      void  va_end( \#va_list\# param );

Prototyp in    stdarg.h

Beschreibung   va_end setzt den als param angegebenen Zeiger des Typs
               \#va_list\# auf \link("%%GLOBAL%%")NULL\# zurÅck. Danach kînnte der Kreislauf
               wiederholt werden (Aufruf von \#va_start\#, danach
               \#va_arg\# usw).

Ergebnis       va_end hat kein direktes Funktionsergebnis

Gruppe         \link("Behandlung variabler Argument")Behandlung variabler Argumente\#

Querverweis    \#va_...\#   \#va_arg\#   \#va_start\#  \#va_list\#
\end

screen( capsensitive("va_start") )
Name           Øvariable [argument] startÆ - Beginn der Auswertung
               variabler Argumente einer Funktion.

Definition     void  va_start( va_list param, lastfix );

Prototyp in    stdarg.h

Beschreibung   va_start erwartet die Angabe eines Zeigers des Typs
               va_list (param) sowie den Namen des letzten fixen
               Parameters der Funktion (fixend) und setzt param auf
               den Beginn des ersten variablen Parameters der
               Funktion.

Ergebnis       va_start hat kein direktes Funktionsergebnis

Gruppe         \link("Behandlung variabler Argument")Behandlung variabler Argumente\#

Querverweis    \#va_...\#   \#va_arg\#   \#va_end\#
\end

screen( capsensitive("vfprintf") )
Name           Øvariable file print formattedÆ - Formatierte Ausgabe
               zu einer Datei

Definition     #include <stdarg.h>
               int  vfprintf( FILE *fp, const char *format,
                               va_list arglist );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ØdruckenÆ in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (Øvariable file printfÆ) - wie \#fprintf\#, aber mit
               öbergabe der Parameter via va_list.

Ergebnis       SÑmtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurÅck.
               Im Falle eines Fehlers ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#      \#puts\#       \#scanf\#    \#va_...\#
               \#printf\#   \#vprintf\#   \#vsprintf\#   \#sprintf\#,
               \#fprintf\#
\end

screen( capsensitive("vprintf") )
Name           Øvariable print formattedÆ - Formatierte Ausgabe
               zu stdout

Definition     #include <stdarg.h>
               int  vprintf( const char *format, va_list arglist );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ØdruckenÆ in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (Øvariable printfÆ) - wie \#printf\#, aber mit öbergabe der
               Parameter via va_list.

Ergebnis       SÑmtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurÅck.
               Im Falle eines Fehlers ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#       \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#   \#vsprintf\#   \#sprintf\#
               \#fprintf\#
\end

screen( capsensitive("vsprintf") )
Name           Øvariable string print formattedÆ - Formatierte Ausgabe
               in einen String

Definition     #include <stdarg.h>
               int  vsprintf( char *buffer, const char *format,
                               va_list arglist );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ØdruckenÆ in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (Øvariable string printfÆ) - wie \#sprintf\#, aber mit
               öbergabe der Parameter via va_list.

Ergebnis       SÑmtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurÅck,
               wobei das abschlieûende Nullzeichen bei vsprintf nicht
               mitgezÑhlt wird. Im Falle eines Fehlers ist das
               Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#      \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#   \#vprintf\#   \#sprintf\#
               \#fprintf\#
\end

screen( capsensitive("write") )
Name           ØwriteÆ - schreibt Daten in eine Datei

Definition     size_t  write( int handle, void *buf, size_t len );

Prototyp in    stdio.h

Beschreibung   Die Funktion write liest len Bytes ab der durch buf
               angegebenen Adresse aus dem Speicher und schreibt sie
               in die durch handle bezeichnete Datei. handle ist eine
               vom \#Betriebssystem\# vergebene Referenznummer, die durch
               creat oder open erzeugt wird.

               Wenn die Datei im Modus ØAppendÆ (O_APPEND) erîffnet
               wurde, setzt write die momentane Position automatisch
               auf das Dateiende (bereits existierende Daten kînnen
               also nicht Åberschrieben werden). Bei Diskettendateien
               schreibt write ansonsten ab der momentanen Position
               (siehe \#lseek\#), bei GerÑte-Dateien wird direkt zum
               jeweiligen GerÑt geschrieben (bzw. in den dazugehîrigen
               Puffer - siehe setbuf).

Ergebnis       Die Funktion liefert die Anzahl der tatsÑchlich ge-
               schriebenen Bytes zurÅck (wobei write die aus Zeilen-
               vorschÅben erzeugten CR/LF-Kombinationen als ein Byte
               zÑhlt). Ein Funktionsergebnis von weniger als len steht
               normalerweise fÅr ØDiskette vollÆ. Im Falle eines
               Fehlers wird der Wert -1 zurÅckgeliefert und \#errno\#
               bekommt einen der folgenden Werte:
                               EACCES    EBADF

Gruppe         \#I/O-Routinen\#
Querverweis    \#creat\#   \#lseek\#   \#open\#   \#read\#
\end

screen( capsensitive("errno") )
errno ist in ERRNO.H definiert und kann folgende Werte annehmen:

EPERM   1  /* file permission denied     Dateizugriff nicht erlaubt  */
ENOENT  2  /* file not found             Suchweg/Datei nicht gefunden*/
EIO     5  /* general i/o error          Ein-/Ausgabefehler          */
EBADF   9  /* invalid file handle        UngÅltiges Handle           */
EILLSPE 10 /* illegal file specification Unerlaubte Spezifikation    */
EINVMEM 11 /* invalid heap block         UngÅltiger Heapblock        */
ENOMEM  12 /* heap overflow              HeapÅberlauf                */
EACCES  13 /* file access mode error     Zugriff nicht erlaubt       */
EEXIST  17 /* file already exists        Datei existiert schon       */
EPLFMT  18 /* program load format error  Ladefehler wegem falschem   */
           /*                            Programmformat              */
ENODEV  19 /* device error               Devicefehler                */
ENOTDIR 20 /* path not found             Pfad nicht gefunden         */
EINVAL  22 /* invalid parameter          ungÅltiger Parameter        */
ENFILE  23 /* file table overflow        Zuviele Dateien             */
EMFILE  24 /* too many open files        Zuviele offene Dateien      */
ENOSPC  28 /* disk full                  Diskette voll               */
ESPIPE  29 /* seek error                 Seekfehler                  */
EROFS   30 /* read only device           Nur lesen erlaubt           */
EDOM    33 /* domain error               Argumente auûerhalb des     */
           /*                            zulÑssigen Bereichs         */
ERANGE  34 /* range error                Ergebnis auûerhalb des      */
           /*                            Bereichs                    */
ENMFILE 35 /* no more matching file      keine weitere Datei
                                         vorhanden (\#findnext\#)        */
\end

screen( capsensitive("__NFPUIN__") )
Dieses Makro bewirkt, das einige Flieûkommafunktionen nicht in den 
entsprechenden FPU-befehl  Åbersetzt werden, falls der Schalter -8
bei den \link("%%GLOBAL%%")Compileroptionen\# gesetzt ist.
Folgende Flieûkommafunktionen kînnen Åbersetzt werden:

/* Arithmetische Befehle: */
\#fabs\#       \link("%%GLOBAL%%")fgetexp\#    \link("%%GLOBAL%%")fgetman\#    \link("%%GLOBAL%%")fint\#       \link("%%GLOBAL%%")fintrz\#
\#fmod\#       \link("%%GLOBAL%%")frem\#       \#ldexp\#      \link("%%GLOBAL%%")fsgldiv\#    \link("%%GLOBAL%%")fsglmul\#

/* Potenzen und Logarithmen: */
\#exp\#        \link("%%GLOBAL%%")fetoxm1\#    \#log\#        \link("%%GLOBAL%%")flognp1\#    \#log10\#
\#sqrt\#       \#pow10\#      \#pow\#

/* Trigonometrie: */
\#acos\#       \#asin\#       \#atan\#       \#cos\#        \#sin\#
\#tan\#

/* Hyperbelfunktionen: */
\#atanh\#      \#cosh\#       \#sinh\#       \#tanh\#
\end

screen( capsensitive("round") )
Name           ØroundÆ - Runden einer Flieûkommazahl

Definition     double  round( double x );

Prototyp in    math.h

Beschreibung   round rundet eine Flieûkommazahl nach dem Øround to
               nearestÆ-Algorithmus. Das heiût, es wird zur nÑchst
               gelegenen ganzen Zahl auf- bzw. abgerundet. Ist der
               Nachkommaanteil genau 0.5, so wird die gerade Zahl
               gerundet, beispielsweise
                      146.67       ergibt       146.0
                      146.5        ergibt       146.0
                      147.5        ergibt       148.0

Ergebnis       Als Ergebnis erhÑlt man die gerundete Zahl.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#trunc\#
\end

screen( capsensitive("trunc") )
Name           ØtruncateÆ - Ganzzahligen Anteil einer Flieûkommazahl
               ermitteln.

Definition     double  trunc( double x );

Prototyp in    math.h

Beschreibung   trunc ermittelt den ganzzahligen Anteil einer Flieû-
               kommazahl, sprich, es schneidet die Nachkommastellen
               ab. Zum Beispiel:
                      146.67       ergibt       146.0
                      -1.5         ergibt       -1.0

Ergebnis       Als Ergebnis erhÑlt man den ganzahligen Anteil der
               Flieûkommazahl.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#round\#
\end

screen( capsensitive("random") )
Name           ØrandomÆ - Zufallszahl ermitteln.

Definition     int  random( int num );

Prototyp in    stdlib.h

Beschreibung   random ist als Makro definiert und liefert eine
               Zufallszahl aus dem Bereich von Null bis num - 1.

Ergebnis       Als Ergebnis erhÑlt man eine ganzzahlige Zufalls-
               zahl zwischen 0 und num - 1.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#rand\#   \#srand\#
\end

screen( "BIOS" )
BIOS

Die BIOS-Funktionen stellen die unterste Schnittstelle des
\#Betriebssystem\#s zur Hardware des Atari ST dar. Diese Funktionen,
die in Assembler alle Åber den 680X0-Trap #13 angesprochen werden,
erscheinen etwas zusammengewÅrfelt. Nur wenige dieser Funktionen
sollten in Applikationsprogrammen verwendet werden, da wesentlich
leistungsfÑhigere Funktionen auf hîherer Ebene als bessere Alterna-
tive verfÅgbar sind. In der nachfolgenden öbersicht finden Sie alle
BIOS-Funktionen des Atari ST. Die erste Zahl gibt die Funktionsnummer
des Traps an.

0  \#Getmpb\#   Speicherparameterblock ermitteln.
1  \#Bconstat\# Status eines EingabegerÑts ermitteln.
2  \#Bconin\#   Zeichen von EingabegerÑt einlesen.
3  \#Bconout\#  Zeichen auf AusgabegerÑt ausgeben.
4  \#Rwabs\#    Sektoren auf Laufwerken lesen und schreiben.
5  \#Setexc\#   Exceptionvektoren ermitteln und festlegen.
6  \#Tickcal\#  Timer-Konstante ermitteln.
7  \#Getbpb\#   BIOS-Parameterblock eines GerÑts ermitteln.
8  \#Bcostat\#  Status eines AusgabegerÑts ermitteln.
9  \#Mediach\#  Ermitteln, ob die Diskette gewechselt wurde.
10 \#Drvmap\#   Angeschlossene Laufwerke ermitteln.
11 \#Kbshift\#  Tastaturstatus ermitteln.

Querverweis     \#VT-52-Terminal\#
\end

screen( "VT-52-Terminal",
		capsensitive("screen") )
Die Ausgabefunktionen des \link("GEMDOS")Gemdos\# bzw. \link("BIOS")Bios\# kînnen ein
VT-52 Videoterminal emulieren. Dabei stehen folgende Steuercodes 
in der \link("%%GLOBAL%%")#include\#-datei screen.h zur VerfÅgung:

\#Bell\#                    Bell
\#Tab\#                     Tabulator
\#Return\#                  Carriage return
\#Line_feed\#               Line feed
\#Next_line\#               CR/LF

\#Cur_up\#                  Cursor up
\#Scroll_up\#               Cursor up and insert
\#Cur_down\#                Cursor down
\#Cur_right\#               Cursor right
\#Cur_left\#                Cursor left
\#Cur_home\#                Cursor home

\#Clear_home\#              Clear screen
\#Clear_down\#              Clear to end of screen
\#Clear_up\#                Clear to start of screen
\#Clear_line\#              Clear line
\#Clear_eol\#               Clear to end of line
\#Clear_sol\#               Clear to start of line

\#Ins_line\#                Insert line
\#Del_line\#                Delete line

\#Save_pos\#                Save cursor position
\#Load_pos\#                Restore cursor position
\#Goto_pos\#                Set cursor position

\#Ink\#                     Foreground color
\#Paper\#                   Background color
\#Rev_on\#                  Reverse video
\#Rev_off\#                 Normal video

\#Cur_on\#                  Show cursor
\#Cur_off\#                 Hide cursor

\#Wrap_on\#                 Wrap on
\#Wrap_off\#                Wrap off

ZusÑtzlich wurden in SCREEN.H einige nÅtzliche \link("%%GLOBAL%%")Funktionen-Makros\#
mit aufgenommen:
\#Blink_on\#                Blink on
\#Blink_off\#               Blink off
\#Set_blink\#               Set blink rate
\#Get_blink\#               Get Blink rate
\end

screen( capsensitive("bios") )
Name           ØbiosÆ - BIOS-Trap ausfÅhren.

Definition     long bios (void, ...) ;

Prototyp in    tos.h

Beschreibung   Die Routine bios fÅhrt einen TRAP 14 durch. Die
               Åbergebenen Parameter hÑngen von der jeweiligen BIOS-
               Funktion ab.
Ergebnis       Die Funktion liefert als Ergebnis einen Wert vom
               Datentyp long.
Querverweis    Bibliotheksfunktionen: \#gemdos\#   \#xbios\#
               Betriebssystem: \link("BIOS")Bios\#
\end

screen( capsensitive("Bconin") )
Name           ØBIOS console inputÆ - Zeichen einlesen.

Biosnummer     2

Definition     long Bconin (int dev) ;

Prototyp in    tos.h
Beschreibung   Die BIOS-Routine Bconin liest ein Zeichen von einem
               PeripheriegerÑt dev ein. Als dev kînnen am Atari ST
               folgende GerÑte angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)
               Eine falsche Angabe fÅr dev kann zum Absturz des
               Systems fÅhren.
Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen. Beim Lesen von der Tastatur ist der
               entsprechende Scan-Code Von Funktionstasten und Cursor-
               Funktionen zu beachten.
Querverweis    \#Bconout\#   \#Keytbl\#   \#Bconmap\#
\end

screen( capsensitive("Bconout") )
Name           ØBIOS console outputÆ - Zeichen ausgeben.

Biosnummer     3

Definition     void Bconout (int dev, int c) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Bconout schreibt das Zeichen c auf das
               PeripheriegerÑt dev. Als dev kînnen am Atari ST
               folgende GerÑte angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console, \#VT-52-Terminal\#)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)

               Eine falsche Angabe fÅr dev kann zum Absturz des
               Systems fÅhren. SÑmtliche Codes von 0x00 bis 0xFF
               werden beim Zeichen c als druckbare Zeichen
               interpretiert.
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Bconin\#   \#Bconstat\#   \#Bconmap\#
\end

screen( capsensitive("Bconstat") )
Name           ØBios console statusÆ - Eingabestatus eines Peripherie-
               gerÑtes.

Biosnummer     1

Definition     int Bconstat (int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Bconstat ermittelt den Eingabestatus
               eines StandardperipheriegerÑtes dev. Als dev kînnen am
               Atari ST folgende GerÑte angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)
               Eine falsche Angabe fÅr dev kann zum Absturz des
               Systems fÅhren.
Ergebnis       Die Funktion liefert als Ergebnis -1, wenn Zeichen im
               Puffer liegen und 0, wenn dies nicht der Fall ist.
Querverweis    \#Bconin\#   \#Bconout\#   \#Bconmap\#
\end

screen( capsensitive("Bcostat") )
Name           Øbios output statusÆ - Status eines Standardausgabe-
               gerÑtes ermitteln.

Biosnummer     8

Definition     long Bcostat (int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Bcostat ermittelt den Status eines
               StandardausgabegerÑtes dev. Als dev kînnen am Atari ST
               folgende GerÑte angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)
Ergebnis       Die Funktion liefert als Ergebnis den Status des Aus-
               gabegerÑts, nÑmlich -1, wenn Zeichen geschrieben werden
               kînnen, und 0, wenn der Puffer voll ist.
Querverweis    \#Bconout\#   \#Bconmap\#
\end

screen( capsensitive("Drvmap") )
Name           Ødrive mapÆ - ermittelt die angeschlossenen Laufwerke.

Biosnummer     10

Definition     long Drvmap(void) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Drvmap ermittelt die angeschlossenen
               Laufwerke. FÅr jedes angeschlossene Laufwerk wird ein
               Bit gesetzt. Angefangen von Bit 0 (Laufwerk A:) bis hin
               zu Bit 15 (Laufwerk P:) werden alle Laufwerke
               aufgefÅhrt.
Ergebnis       Die Funktion liefert als Ergebnis einen Bitvektor fÅr
               die angeschlossenen Laufwerke.
\end

screen( capsensitive("Getbpb") )
Name           Øget bios parameter blockÆ - BIOS-Parameterblock eines
               GerÑtes ermitteln.

Biosnummer     7

Definition     \#BPB\# *Getbpb( int dev );

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Getbpb ermittelt den BIOS-Parameter-
               block des GerÑts dev. 

Ergebnis       Die Funktion liefert als Ergebnis die Adresse des BIOS-
               Parameterblocks.
\end

screen( capsensitive("Getmpb") )
Name           Øget memory parameter blockÆ - Speicherparameter-
               Block kopieren.

Biosnummer     0

Definition     void Getmpb( MPB *ptr );

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Getmpb kopiert den Speicherparameter-
               block in den Bereich ptr. ptr muû auf einen 12 Byte
               groûen Speicherbereich zeigen:
typedef struct
{
    void     *mfl;      /* Liste des freien Speicher */
    void     *mal;      /* Liste des belegten Speicher */
    void     *rover;    /* verschiebbarer Zeiger */
} MPB;
               Die verketteten Listen sind nur im Supervisor-Modus
               zugÑnglich. Achtung: In bisherigen Versionen des TOS
               arbeitet diese Funktion fehlerhaft.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Kbshift") )
Name           Økeyboard shift statusÆ - ermittelt oder Ñndert den
               Status der Spezial-Tasten.

Biosnummer     11

Definition     long Kbshift(int mode) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Kbshift ermittelt oder Ñndert den
               aktuellen Tastatur-Status. Wenn mode negativ ist, wird
               der Status lediglich ermittelt. Wenn mode 0 oder grîûer
               0 ist, dann wird der entsprechende Status neu gesetzt.
               Die einzelnen Bits sind wie folgt definiert:
Bit            Bedeutung
0              Shift-Taste rechts
1              Shift-Taste links
2              Control-Taste
3              Alternate-Taste
4              Caps Lock
5              Maustaste rechts
6              Maustaste links
7              reserviert (0)
Ergebnis       Die Funktion liefert als Ergebnis den gesetzten
               Tastatur-Status.
\end

screen( capsensitive("Mediach") )
Name           Ømedia changeÆ - stellt fest ob der DatentrÑger
               gewechselt wurde.

Biosnummer     9

Definition     long Mediach (int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Mediach stellt fest, ob der Daten-
               trÑger gewechselt wurde.
Ergebnis       Die Funktion liefert als Ergebnis einen Integer-Wert
               mit folgender Bedeutung:
0              Diskette wurde nicht gewechselt
1              Diskette wurde vieleicht gewechselt
2              Diskette wurde gewechselt.
\end

screen( capsensitive("Rwabs") )
Name           Øread write absoluteÆ - direkter Lese-/Schreibzugriff
               auf ein Laufwerk.

Biosnummer     4

Definition     long Rwabs (int rwflag, void *buff, int cnt, int recnr,
                           int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Rwabs liest oder schreibt Daten direkt
               vom bzw. auf das Laufwerk, das mit dev angegeben wurde.
               Der Parameter rwflag bestimmt, ob gelesen (0) oder
               geschrieben (1) werden soll. DarÅberhinaus gibt es noch
               zwei weitere Werte fÅr diesen Parameter, um einen
               Diskettenwechsel zu ignorieren: Lesen (2) und Schreiben
               (3). Es werden cnt Zeichen vom Puffer buff Åbertragen.
               In recnr wird der Startsektor auf dem Laufwerk
               angegeben.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Zugriff erfolgreich war, ansonsten eine negative Zahl.
\end

screen( capsensitive("Setexc") )
Name           Øset exception vectorÆ - Interrupt-Vektoren setzen.

Biosnummer     5

Definition     void (*Setexc( int number, void (*exchdlr)() )) ();

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Setexc setzt einen neuen Interrupt-
               vektor fÅr den Interrupt mit der Nummer number auf die
               Adresse vektor. Wenn als Vektor-Adresse -1 Åbergeben
               wird, dann wird kein neuer Vektor gesetzt, sondern
               lediglich die alte Vektor-Adresse wird gelesen.
Ergebnis       Die Funktion liefert als Ergebnis die gesetzte Adresse.
\end

screen( capsensitive("Tickcal") )
Name           Øtick calculationÆ - Zeitdifferenz zwischen zwei Timer-
               Aufrufen ermitteln.

Biosnummer     6

Definition     long Tickcal(void);

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Tickcal liefert die Anzahl an Milli-
               sekunden, die zwischen zwei Timerticks verstreichen.
Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der Milli-
               sekunden.
\end

screen( capsensitive("Bell") )
Name           ØBellÆ - Systemglocke.

Definition     #define Bell() Cconout( '\\a' )

Definition in  screen.h

Beschreibung   Bell ist ein  Funktionen-Makro, das die Systemglocke
               ertînen lÑût. Damit kînnen Sie sehr leicht ein akus-
               tisches Signal verwenden.
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Tab") )
Name           ØTabulatorÆ - Cursor zur nÑchsten Tabulatorposition.

Definition     #define Tab() Cconout( '\\t' )

Definition in  screen.h

Beschreibung   Tab ist ein Funktionen-Makro, das den Cursor an die
               nÑchste Tabulatorposition setzt.
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Return") )
Name           ØCarriage ReturnÆ - Cursor zum Anfang der Zeile.

Definition     #define Return() Cconout( '\\r' )

Definition in  screen.h

Beschreibung   Tab ist ein Funktionen-Makro, das den Cursor an den
               Anfang der aktuellen Zeile setzt.
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Line_feed") )
Name           ØLine feedÆ - Zeilenvorschub

Definition     #define Line_feed() Cconout( '\\n' )

Definition in  screen.h

Beschreibung   Line_feed ist ein Funktionen-Makro, das den Cursor in
               die nÑchste Zeile setzt (Zeilenvorschub).
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Next_line"),
		capsensitive("NEXT_LINE") )
Name           ØCR/LFÆ - Cursor in eine neue Zeile.

Definition     #define NEXT_LINE   "\\r\\n"
               #define Next_line() Cconws( NEXT_LINE )

Definition in  screen.h

Beschreibung   Next_line ist ein Funktionen-Makro, mit der der TOS-cursor
               an den Anfang der nÑchsten Zeile positioniert werden kann.  
               NEXT_LINE ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr ØCR/LFÆ definiert.  Damit haben Sie  die
               Mîglichkeit, diese Sequenz in eigenen Stringkonstanten  zu
               verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_up"),
		capsensitive("CUR_UP") )
Name           ØCursor upÆ - Cursor eine Zeile nach oben.

Definition     #define CUR_UP   "\\33A"
               #define Cur_up() Cconws( CUR_UP )

Definition in  screen.h

Beschreibung   Cur_up ist ein  Funktionen-Makro,  mit der der  TOS-cursor  
               um eine Zeile nach oben positioniert werden kann. Befindet
               sich  der  Cursor bereits in der  obersten Zeile, passiert
               nichts.
               CUR_UP   ist   ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr ØCursor upÆ definiert.  Damit haben  Sie 
               die Mîglichkeit, diese Sequenz in eigenen Stringkonstanten
               zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Scroll_up"),
		capsensitive("SCROLL_UP") )
Name           ØCursor up and insertÆ - Cursor eine Zeile nach oben und
               scrollen.

Definition     #define SCROLL_UP   "\\33I"
               #define Scroll_up() Cconws( SCROLL_UP )

Definition in  screen.h

Beschreibung   Scroll_up ist ein Funktionen-Makro, mit der der TOS-cursor
               um eine Zeile nach oben positioniert werden kann. Befindet
               sich  der  Cursor bereits in der  obersten Zeile, wird der
               Bildschirminhalt um  eine Zeile  nach unten gescrollt  und
               eine Leerzeile eingefÅgt.
               SCROLL_UP ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr  ØCursor up and insertÆ definiert. Damit
               haben  Sie  die  Mîglichkeit,  diese  Sequenz  in  eigenen 
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_down"),
		capsensitive("CUR_DOWN") )
Name           ØCursor downÆ - Cursor eine Zeile nach unten.

Definition     #define CUR_DOWN   "\\33B"
               #define Cur_down() Cconws( CUR_DOWN )

Definition in  screen.h

Beschreibung   Cur_down ist ein Funktionen-Makro,  mit der der TOS-cursor  
               um eine Zeile nach unten positioniert werden kann. Befindet
               sich  der  Cursor bereits in der  untersten Zeile, passiert
               nichts.
               CUR_DOWN  ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr ØCursor downÆ definiert. Damit haben Sie 
               die Mîglichkeit, diese Sequenz in eigenen Stringkonstanten
               zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_right"),
		capsensitive("CUR_RIGHT") )
Name           ØCursor rightÆ - Cursor eine Spalte nach rechts.

Definition     #define CUR_RIGHT   "\\33C"
               #define Cur_right() Cconws( CUR_RIGHT )

Definition in  screen.h

Beschreibung   Cur_right ist ein Funktionen-Makro,  mit der der TOS-cursor  
               um  eine Spalte nach rechts  positioniert werden kann.  Be-
               findet sich  der Cursor bereits in der ganz rechten Spalte,
               passiert nichts.
               CUR_RIGHT ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fÅr ØCursor rightÆ  definiert.  Damit haben 
               Sie die Mîglichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_left"),
		capsensitive("CUR_LEFT") )
Name           ØCursor leftÆ - Cursor eine Spalte nach links.

Definition     #define CUR_LEFT   "\\33D"
               #define Cur_left() Cconws( CUR_LEFT )

Definition in  screen.h

Beschreibung   Cur_left  ist ein Funktionen-Makro,  mit der der TOS-cursor  
               um  eine Spalte nach  links  positioniert werden kann.  Be-
               findet sich  der Cursor bereits in der  ganz linken Spalte,
               passiert nichts.
               CUR_LEFT  ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fÅr  ØCursor leftÆ  definiert.  Damit haben 
               Sie die Mîglichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CUR_HOME"),
		capsensitive("Cur_home") )
Name           ØCursor homeÆ - Cursor in die obere linke Ecke.

Definition     #define CUR_HOME   "\\33H"
               #define Cur_home() Cconws( CUR_HOME )

Definition in  screen.h

Beschreibung   Cur_home  ist ein Funktionen-Makro,  mit der der TOS-cursor  
               in die obere linke Ecke des Bildschirms positioniert werden 
               kann.
               CUR_HOME  ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fÅr  ØCursor homeÆ  definiert.  Damit haben 
               Sie die Mîglichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_home"),
		capsensitive("CLEAR_HOME") )
Name           ØClear screenÆ - Bildschirm lîschen.

Definition     #define CLEAR_HOME   "\\33E"
               #define Clear_home() Cconws( CLEAR_HOME )

Definition in  screen.h

Beschreibung   Clear_home ist ein Funktionen-Makro,  mit der der gesamte
               Bildschirm gelîscht und der TOS-Cursor in die obere linke
               Ecke des Bildschirms positioniert werden kann.
               CLEAR_HOME ist ein  Konstanten-Makro,  welches  die VT-52 
               Steuersequenz fÅr ØClear screenÆ  definiert.  Damit haben 
               Sie die Mîglichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_down"),
		capsensitive("CLEAR_DOWN") )
Name           ØClear to end of screenÆ - Bildschirm ab Cursor lîschen.

Definition     #define CLEAR_DOWN   "\\33J"
               #define Clear_down() Cconws( CLEAR_DOWN )

Definition in  screen.h

Beschreibung   Clear_down ist ein Funktionen-Makro, mit der der Bildschirm
               ab der Cursorposition gelîscht werden kann.
               CLEAR_DOWN ist ein   Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr ØClear to end of screenÆ definiert. Damit
               haben Sie die Mîglichkeit, diese Sequenz in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CLEAR_UP"),
		capsensitive("Clear_up") )
Name           ØClear to start of screenÆ - Bildschirm bis Cursor lîschen.

Definition     #define CLEAR_UP   "\\33d"
               #define Clear_up() Cconws( CLEAR_UP )

Definition in  screen.h

Beschreibung   Clear_up ist ein Funktionen-Makro, mit der der Bildschirm
               bis zur Cursorposition gelîscht werden kann.
               CLEAR_UP ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fÅr ØClear to start of screenÆ  definiert.
               Damit haben Sie die Mîglichkeit, diese Sequenz in eigenen 
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_line"),
		capsensitive("CLEAR_LINE") )
Name           ØClear lineÆ - Aktuelle Zeile lîschen.

Definition     #define CLEAR_LINE   "\\33l"
               #define Clear_line() Cconws( CLEAR_LINE )

Definition in  screen.h

Beschreibung   Clear_line ist ein Funktionen-Makro, mit der die aktuelle
               Zeile gelîscht werden kann. Die nachfolgenden Zeilen wer-
               den nicht nachgeschoben.  Der Cursor  wird zum Anfang der
               Zeile gesetzt.
               CLEAR_LINE ist ein Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr ØClear lineÆ definiert. Damit haben Sie
               die Mîglichkeit,  diese Sequenz in eigenen Stringkonstan-
               ten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CLEAR_EOL"),
		capsensitive("Clear_eol") )
Name           ØClear to end of lineÆ - Aktuelle Zeile ab Cursor lîschen.

Definition     #define CLEAR_EOL   "\\33K"
               #define Clear_eol() Cconws( CLEAR_EOL )

Definition in  screen.h

Beschreibung   Clear_eol ist ein Funktionen-Makro, mit der die aktuelle
               Zeile ab der Cursorposition gelîscht werden kann.
               CLEAR_EOL ist ein Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fÅr  ØClear to end of lineÆ definiert. Da-
               mit haben Sie die Mîglichkeit,  diese Sequenz in eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_sol"),
		capsensitive("CLEAR_SOL") )
Name           ØClear to start of lineÆ - Aktuelle Zeile ab Cursor lîschen.

Definition     #define CLEAR_SOL   "\\33o"
               #define Clear_sol() Cconws( CLEAR_SOL )

Definition in  screen.h

Beschreibung   Clear_sol ist ein Funktionen-Makro, mit der die aktuelle
               Zeile bis zur Cursorposition gelîscht werden kann.
               CLEAR_SOL ist ein Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz   fÅr  ØClear to start of lineÆ  definiert. 
               Damit haben Sie die Mîglichkeit, diese Sequenz in eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Ins_line"),
		capsensitive("INS_LINE") )
Name           ØInsert lineÆ - Zeile einfÅgen.

Definition     #define INS_LINE   "\\33k"
               #define Ins_line() Cconws( INS_LINE )

Definition in  screen.h

Beschreibung   Ins_line ist ein Funktionen-Makro,  mit der  eine neue
               Zeile an der Cursorposition eingefÅgt werden kann. Der
               Cursor wird an den Anfang der neuen Zeile gesetzt.
               INS_LINE ist ein Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fÅr ØInsert lineÆ definiert. Damit haben
               Sie die Mîglichkeit,  diese Sequenz in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("DEL_LINE"),
		capsensitive("Del_line") )
Name           ØDelete lineÆ - Zeile entfernen.

Definition     #define DEL_LINE   "\\33M"
               #define Del_line() Cconws( DEL_LINE )

Definition in  screen.h

Beschreibung   Del_line ist ein Funktionen-Makro, mit der die aktuelle
               Zeile  gelîscht  werden kann.  Die nachfolgenen  Zeilen
               werden nachgeschoben, der Cursor wird an den Anfang der
               Zeile gesetzt.
               DEL_LINE ist ein Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fÅr ØDelete lineÆ definiert. Damit haben
               Sie die Mîglichkeit,  diese Sequenz in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("SAVE_POS"),
		capsensitive("Save_pos") )
Name           ØSave cursor positionÆ - Cursor "merken".

Definition     #define SAVE_POS   "\\33j"
               #define Save_pos() Cconws( SAVE_POS )

Definition in  screen.h

Beschreibung   Save_pos ist ein Funktionen-Makro, mit der die aktuelle
               Cursorposition  in einen  internen  Puffer  gespeichert
               wird. Die gespeicherte Cursorposition  kann spÑter  mit
               \#Load_pos\# resaturiert werden.
               SAVE_POS ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz  fÅr  ØSave cursor positionÆ   definiert. 
               Damit haben Sie  die Mîglichkeit,  diese Sequenz in ei-
               genen Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Load_pos"),
		capsensitive("LOAD_POS") )
Name           ØRestore cursor positionÆ - Cursor restaurieren.

Definition     #define LOAD_POS   "\\33k"
               #define Load_pos() Cconws( LOAD_POS )

Definition in  screen.h

Beschreibung   Load_pos ist ein Funktionen-Makro, mit der der Cursor
               wieder an  die Stelle positioniert  werden kann,  die 
               vorher mit \#Save_pos\# "gemerkt" wurde.
               LOAD_POS ist ein Konstanten-Makro,  welches die VT-52 
               Steuersequenz fÅr ØRestore cursor positionÆ definiert. 
               Damit haben Sie die Mîglichkeit, diese Sequenz in ei-
               genen Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Goto_pos"),
		capsensitive("GOTO_POS") )
Name           ØSet cursor positionÆ - Cursor positionieren.

Definition     #define GOTO_POS         "\\33Y"
               #define Goto_pos( x, y ) (Cconws( GOTO_POS ),\\
                                         Cconout( ' ' + x ),\\ 
                                         Cconout( ' ' + y ))

Definition in  screen.h

Beschreibung   Goto_pos ist ein Funktionen-Makro,  mit der der  Cursor
               an x-te Zeile und  y-te Spalte positioniert werden kann.
               Beachten Sie bitte, daû die ZÑhlung bei 0 beginnt.
               GOTO_POS ist ein  Konstanten-Makro,   welches die VT-52 
               Steuersequenz fÅr ØSet cursor positionÆ  definiert. Da-
               mit haben Sie die Mîglichkeit, diese Sequenz in eigenen 
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("INK"),
		capsensitive("Ink") )
Name           ØForeground colorÆ - Textfarbe setzen.

Definition     #define INK      "\\33b"
               #define Ink( c ) (Cconws( INK ), Cconout( c ))

Definition in  screen.h

Beschreibung   Ink ist ein Funktionen-Makro, mit der die  Textfarbe ge-
               setzt werden kann. Die Anzahl der verfÅgbaren Farben ist
               auflîsungsabhÑngig.
               INK  ist ein Konstanten-Makro,  welches die VT-52 Steuer-
               sequenz fÅr ØForeground colorÆ definiert. Damit haben Sie
               die Mîglichkeit,  diese Sequenz in eigenen Stringkonstan-
               ten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("PAPER"),
		capsensitive("Paper") )
Name           ØBackground colorÆ - Hintergrundfarbe setzen.

Definition     #define PAPER      "\\33c"
               #define Paper( c ) (Cconws( PAPER ), Cconout( c ))

Definition in  screen.h

Beschreibung   Paper ist ein Funktionen-Makro, mit der die Hintergrund-
               farbe gesetzt  werden kann.  Die Anzahl der  verfÅgbaren 
               Farben ist auflîsungsabhÑngig.
               PAPER ist ein Konstanten-Makro, welches die VT-52 Steuer-
               sequenz fÅr ØBackground colorÆ definiert. Damit haben Sie
               die Mîglichkeit,  diese Sequenz in eigenen Stringkonstan-
               ten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Rev_on"),
		capsensitive("REV_ON") )
Name           ØReverse videoÆ - Reverse Schrift einschalten.

Definition     #define REV_ON    "\\33p"
               #define Rev_on() Cconws( REV_ON )

Definition in  screen.h

Beschreibung   Rev_on ist ein Funktionen-Makro,  mit der die  reverse 
               Schrift (Hintergrund- und Textfarbe vertauscht) einge-
               schaltet  werden kann.  Dieser Modus kann mit  \#Rev_off\#
               wieder ausgeschaltet weden.
               REV_ON  ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fÅr ØReverse videoÆ definiert. Damit ha-
               ben Sie  die  Mîglichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("REV_OFF"),
		capsensitive("Rev_off") )
Name           ØNormal videoÆ - Reverse Schrift ausschalten.

Definition     #define REV_OFF    "\\33q"
               #define Rev_off()  Cconws( REV_OFF )

Definition in  screen.h

Beschreibung   Rev_off ist ein Funktionen-Makro, mit der die  reverse 
               Schrift (\#Rev_on\#) wieder ausgeschaltet werden kann.
               REV_OFF ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fÅr ØNormal videoÆ definiert.  Damit ha-
               ben Sie  die  Mîglichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CUR_ON"),
		capsensitive("Cur_on") )
Name           ØShow cursorÆ - Cursor einschalten.

Definition     #define CUR_ON    "\\33e"
               #define Cur_on()  Cconws( CUR_ON )

Definition in  screen.h

Beschreibung   Cur_on ist ein Funktionen-Makro, mit der der Cursor
               eingeschaltet werden kann.
               CUR_ON ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fÅr ØShow cursorÆ definiert.  Damit ha-
               ben Sie  die Mîglichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CUR_OFF"),
		capsensitive("Cur_off") )
Name           ØHide cursorÆ - Cursor einschalten.

Definition     #define CUR_OFF    "\\33f"
               #define Cur_off()  Cconws( CUR_OFF )

Definition in  screen.h

Beschreibung   Cur_off ist ein Funktionen-Makro, mit der der Cursor
               ausgeschaltet werden kann.
               CUR_OFF ist ein  Konstanten-Makro, welches die  VT-52 
               Steuersequenz fÅr ØHide cursorÆ definiert.  Damit ha-
               ben Sie  die Mîglichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("WRAP_ON"),
		capsensitive("Wrap_on") )
Name           ØWrap onÆ - Zeilenumbruch einschalten.

Definition     #define WRAP_ON    "\\33v"
               #define Wrap_on()  Cconws( WRAP_ON )

Definition in  screen.h

Beschreibung   Wrap_on  ist ein Funktionen-Makro, mit der der Zeilen-
               umbruch  eingeschaltet werden kann.  Dies bewirkt, daû
               bei  Erreichen des  Endes einer Zeile  automatisch zum
               Anfang der nÑchsten Zeile gesprungen wird. 
               WRAP_ON ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz  fÅr ØWrap onÆ  definiert.  Damit  haben 
               Sie  die Mîglichkeit, diese Sequenz  in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("WRAP_OFF"),
		capsensitive("Wrap_off") )
Name           ØWrap offÆ - Zeilenumbruch ausschalten.

Definition     #define WRAP_OFF    "\\33w"
               #define Wrap_off()  Cconws( WRAP_OFF )

Definition in  screen.h

Beschreibung   Wrap_off ist ein Funktionen-Makro, mit der der Zeilen-
               umbruch (\#Wrap_on\#) ausgeschaltet werden kann.
               WRAP_OFF ist ein  Konstanten-Makro, welches die  VT-52 
               Steuersequenz  fÅr ØWrap offÆ definiert.  Damit  haben 
               Sie  die Mîglichkeit, diese Sequenz  in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Blink_on") )
Name           ØBlink onÆ - Cursorblinken einschalten.

Definition     #define Blink_on()  Cursconf( 2, 0 )

Definition in  screen.h

Beschreibung   Blink_on ist ein Funktionen-Makro, mit der das Blinken
               des Cursors eingeschaltet werden kann. Hierzu wird die
               \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Blink_off") )
Name           ØBlink offÆ - Cursorblinken ausschalten.

Definition     #define Blink_off()  Cursconf( 3, 0 )

Definition in  screen.h

Beschreibung   Blink_off ist ein Funktionen-Makro, mit der das Blinken
               des Cursors eingeschaltet werden kann. Hierzu  wird die
               \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Set_blink") )
Name           ØSet blink rateÆ - Cursorblinkfrequenz einstellen.

Definition     #define Set_blink( rate ) Cursconf( 4, rate )

Definition in  screen.h

Beschreibung   Set_blink ist ein Funktionen-Makro, mit der die Frequenz
               des Cursorblinkens eingestellt werden kann. Hierzu  wird
               die \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Get_blink") )
Name           ØGet blink rateÆ - Cursorblinkfrequenz abfragen.

Definition     #define Set_blink() Cursconf( 5, 0 )

Definition in  screen.h

Beschreibung   Get_blink ist ein Funktionen-Makro, mit der die Frequenz
               des  Cursorblinkens abgefragt  werden kann. Hierzu  wird
               die \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( "XBIOS" )
XBIOS
----------------------------------------------------------------------

Diese Funktionen ermîglichen den geordneten Zugriff auf die verschie-
denen Spezial-Chips im Atari-ST. Sie werden Åber den 680X0-Trap #14
aufgerufen.
Das XBIOS lÑût sich in folgende Funktionsgruppen einteilen:

               \#Tastaturfunktionen\#
               \#Bildschirmfunktionen\#
               \#Druckerfunktionen\#
               \#Laufwerksfunktionen\#
               \#Datum, Uhrzeit und Zeitgeber\#
               \#Interruptfunktionen\#
               \#Schnittstellenprogrammierung\#
               \#Spezialbefehle\#

Ab Falcon 030:

               \#DSP-Programmierung\#
               \#Soundroutinen\#
\end

screen( "Tastaturfunktionen" )
Tastaturfunktionen
----------------------------------------------------------------------

Die folgenden Funktionen regeln die direkte Programmierung der Tasta-
tur. Mit \#Keytbl\# kann man eine eigene Tastaturtabelle installieren.
Die Funktion \#Bioskeys\# dient zur Reinitialisierung der Tastatur:
Die Tastatur wird in den Urzustand versetzt. Mit \#Kbrate\# kann man
das Ansprechverhalten der Tastatur einstellen. Es geht dabei darum,
ab welchem Zeitpunkt in den Auto-Repeat-Modus (automatische Tastatur-
wiederholung) umgeschaltet wird, und wie schnell der Auto-Repeat-Modus
durchgefÅhrt wird.

16 \#Keytbl\#   Neue Tabelle fÅr Tastaturcodes vorgeben
24 \#Bioskeys\# BIOS-Tabelle fÅr Tastaturcodes zurÅcksetzen
35 \#Kbrate\#   Auto-Repeat der Tastatur Ñndern oder ermitteln
\end

screen( "Bildschirmfunktionen" )
Bildschirmfunktionen
----------------------------------------------------------------------

Zur direkten Programmierung des Bildschirms stehen mehrere Funktionen
zur VerfÅgung. Mit \#Initmouse\# und \#Cursconf\# kann man sowohl die Ein-
stellung des Grafik- als auch des Textcursors beeinflussen. FÅr beson-
ders schnelle Animationen erweisen sich die beiden Funktionen \#Logbase\#
und \#Physbase\# als vorteilhaft: Auf dem logischen Bildschirm wird im
Hintergrund gezeichnet, dann schaltet man den physikalischen Bild-
schirm mit \#Setscreen\# um.

0   \#Initmouse\#   Mauszeiger initialisieren.
2   \#Physbase\#    Anfangsadresse des physikalischen Bildschirmspeichers
                ermitteln (der dargestellte Bildschirm).
3   \#Logbase\#     Anfangsadresse des logischen Bildschirmspeichers er-
                mitteln (der Bildschirm, auf dem gezeichnet wird).
4   \#Getrez\#      Auflîsung ermitteln.
5   \#Setscreen\#   Festlegen der Bildschirmauflîsung und der Bildschirm-
                adressen.
6   \#Setpalette\#  Farbpalette auswÑhlen.
7   \#Setcolor\#    Farbe einstellen.
21  \#Cursconf\#    Cursordarstellung Ñndern oder ermitteln.
37  \#Vsync\#       Vertikales Synchronisationssignal abfragen.


Ab TOS030 (Atari TT) verfÅgbar:

80  \#EsetShift\#   Shift Mode Register setzen.
81  \#EgetShift\#   Shift Mode Register lesen.
82  \#EsetBank\#    Farbtabelle setzen.
83  \#EsetColor\#   Farbtabelleneintrag setzen.
84  \#EsetPalette\# Farbtabelle laden.
85  \#EgetPalette\# Farbtabelle lesen.
86  \#EsetGray\#    Farbinterpretation setzen.
87  \#EsetSmear\#   Farbverwischung setzen.


Ab Falcon 030 verfÅgbar:

88  \#Vsetmode\#    Videohardwareregister setzen.
89  \#mon_type\#    Monitortyp ermitteln.
90  \#VsetSync\#    Synchronisationsart setzen.
91  \#VgetSize\#    Grîûe des Bildschirmpuffers ermitteln.
93  \#VsetRGB\#     RGB-Wert einer Farbe setzen.
94  \#VgetRGB\#     RGB-Wert einer Farbe ermitteln.
150 \#VsetMask\#    Transparenz fÅr True-Color setzen.
\end

screen( "Druckerfunktionen" )
Druckerfunktionen
----------------------------------------------------------------------

20 \#Scrdmp\# Bildschirminhalt ausdrucken.
33 \#Setprt\# Druckereinstellung ermitteln oder Ñndern.
36 \#Prtblk\# Hardcopy-Funktion mit Parameterblock.
\end

screen( "Laufwerksfunktionen" )
Laufwerksfunktionen
----------------------------------------------------------------------

8  \#Floprd\#   Einzelne Sektoren lesen.
9  \#Flopwr\#   Einzelne Sektoren schreiben.
10 \#Flopfmt\#  Spur auf einer Diskette formatieren.
18 \#Protobt\#  Bootsektor fÅr Diskette im Speicher generieren.
19 \#Flopver\#  Sektoren mit Speicherinhalt vergleichen.


Ab TOS030 (Atari TT) verfÅgbar:

42 \#DMAread\#  Sektoren von Festplatte lesen.
43 \#DMAwrite\# Sektoren auf Festplate schreiben.
\end

screen( "Datum, Uhrzeit und Zeitgeber" )
Datum, Uhrzeit und Zeitgeber im \#XBIOS\#
----------------------------------------------------------------------

22 \#Settime\# Datum und Uhrzeit einstellen.
23 \#Gettime\# Datum und Uhrzeit ermitteln.
31 \#Xbtimer\# Systemzeitgeber initialisieren.
\end

screen( "Interruptfunktionen" )
Interruptfunktionen
----------------------------------------------------------------------

26 \#Jdisint\#  Interrupts sperren.
27 \#Jenabint\# Interrupts freigeben.
\end

screen( "Schnittstellenprogrammierung" )
Schnittstellen-Programmierung
----------------------------------------------------------------------

14 \#Iorec\#    Interruptpuffer fÅr RS232, Tastatur-Chip und
            MIDI-Schnittstelle abfragen.
15 \#Rsconf\#   Konfiguration der RS232-Schnittstelle.
12 \#Midiws\#   Strings lesen und schreiben auf MIDI-Schnittstelle.
13 \#Mfpint\#   Programmierung des Multifunktionsperipherie-Chips.
25 \#Ikbdws\#   Programmierung des Tastatur-Chips.
28 \#Giaccess\# Register des GI-Soundchips lesen und schreiben.
29 \#Offgibit\# Bit im Port A-Register des GI-Chips lîschen.
30 \#Ongibit\#  Bit im Port A-Register des GI-Chips setzen.
32 \#Dosound\#  Sound-Befehle abschicken.
34 \#Kbdvbase\# Puffer und Interruptvektoren fÅr Maus-, MIDI-
            und Tastaturschnittstelle abfragen.


Ab TOS030 (Atari TT) verfÅgbar:

44 \#Bconmap\#  AuswÑhlen einer seriellen Schnittstelle.
\end

screen( "Spezialbefehle" )
Spezialbefehle
----------------------------------------------------------------------

1  \#Ssbrk\#    Speicherplatz reservieren (nur intern verwendet).
17 \#Random\#   Zufallszahlengenerator.
38 \#Supexec\#  Unterprogramm im Supervisormodus starten.
39 \#Puntaes\#  AES im ROM abschalten.
64 \#Blitmode\# Blitterkonfiguration Ñndern oder ermitteln.
\end

screen( capsensitive("xbios") )
Name           ØxbiosÆ - XBIOS-Trap ausfÅhren.

Definition     long xbios (void, ...) ;

Prototyp in    tos.h

Beschreibung   Die Routine xbios fÅhrt einen TRAP 13 durch. Die
               Åbergebenen Parameter hÑngen von der jeweiligen \#XBIOS\#-
               Funktion ab.

Ergebnis       Die Funktion liefert als Ergebnis einen Wert vom
               Datentyp long.

Querverweis    Bibliotheksfunktionen: \#bios\#   \#gemdos\#
               Betriebssystem: \#XBIOS\#
\end

screen( "Soundroutinen" )
Soundroutinen                                         PCTOSLIB.LIB
------------------------------------------------------------------

Die PCTOSLIB.LIB enthÑlt die folgenden Routinen zur Soundprogram-
mierung. Diese Routinen sind nur auf Computern der Falcon-Serie
verfÅgbar:

     \#buffoper\#       Aufnahme-/Wiedergabemodus setzen
     \#buffptr\#        Aufnahme-/Wiedergabeposition ermitteln
     \#devconnect\#     Audio-Subsystem-Komponenten verbinden
     \#dsptristate\#    Externe DSP-Hardware koordinieren
     \#gpio\#           öber externe DSP-Buchse kommunizieren
     \#locksnd\#        Soundsystem fÅr andere Anwendungen sperren
     \#setbuffer\#      Aufnahme-/Wiedergabepuffer setzen
     \#setinterrupt\#   Interrupt am Ende einer Aufnahme bzw.
                    einer Wiedergabe festlegen
     \#setmontracks\#   Wiedergabespur fÅr internen Lautsprecher
                    festlegen
     \#setmode\#        Aufnahme-/Wiedergabemodus wÑhlen
     \#settracks\#      Spurenanzahl festlegen
     \#sndstatus\#      Status des A/D- und D/A-Wandlers ermitteln
     \#soundcmd\#       Parameter des A/D- und D/A-Wandlers setzen
                    oder ermitteln
     \#unlocksnd\#      Soundsystem fÅr andere Anwendungen freigeben
\end

screen( "DSP-Programmierung" )
DSP-Programmierung                                    PCTOSLIB.LIB
------------------------------------------------------------------

Die PCTOSLIB.LIB enthÑlt die folgenden Routinen zur Programmie-
rung des Signal-Prozessors DSP56001, der in die Falcon-Computer
eingebaut ist:

    \#Dsp_Available\#             Freien Speicher ermitteln
    \#Dsp_BlkBytes\#              Byteweiser Datentransfer
    \#Dsp_BlkHandShake\#          Datentransfer mit Handshake
    \#Dsp_BlkUnpacked\#           Datentransfer von DSP-Worten mit
                              maximal 4 Byte LÑnge
    \#Dsp_BlkWords\#              Wortweiser Datentransfer
    \#Dsp_DoBlock\#               Datentransfer
    \#Dsp_ExecBoot\#              Bootprogramm fÅr DSP laden
    \#Dsp_ExecProg\#              DSP-Programm starten
    \#Dsp_FlushSubroutines\#      Unterprogramme lîschen
    \#Dsp_GetProgAbility\#        Identifikation erfragen
    \#Dsp_GetWordSize\#           LÑnge von DSP-Worten ermitteln
    \#Dsp_Hf0\#                   Bit 3 des HSR setzen bzw. lîschen
    \#Dsp_Hf1\#                   Bit 4 des HSR setzen bzw. lîschen
    \#Dsp_Hf2\#                   Bit 3 des HCR ermitteln
    \#Dsp_Hf3\#                   Bit 4 des HCR ermitteln
    \#Dsp_HStat\#                 Wert des ISR-Registers ermitteln
    \#Dsp_InqSubrAbility\#        Unterprogrammkennung ermitteln
    \#Dsp_InStream\#              Datentransfer zum DSP via Interrupt
    \#Dsp_IOStream\#              Datentransfer vom und zum DSP via
                              Interrupt
    \#Dsp_LoadProg\#              DSP-Programm laden und starten
    \#Dsp_LoadSubroutine\#        Unterprogramm installieren
    \#Dsp_Lock\#                  VerfÅgbarkeit des DSP ermitteln
    \#Dsp_LodToBinary\#           .LOD- in BinÑrformat konvertieren
    \#Dsp_MultBlocks\#            Datentransfer vom und zum DSP
    \#Dsp_OutStream\#             Datentransfer vom DSP via Interrupt
    \#Dsp_RemoveInterrupts\#      öbertragungsroutinen entfernen
    \#Dsp_RequestUniqueAbility\#  Identifikation erteilen
    \#Dsp_Reserve\#               Speicher reservieren
    \#Dsp_RunSubroutine\#         Unterprogramm ausfÅhren
    \#Dsp_SetVectors\#            Eigene öbertragungsroutinen instal-
                              lieren
    \#Dsp_TriggerHC\#             Host Command ausfÅhren
    \#Dsp_Unlock\#                DSP freigeben
\end

screen( capsensitive("Dsp_DoBlock") )
Dsp_DoBlock                                           PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_DoBlock( char *data_in, long size_in,
                                  char *data_out, long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in DSP-Worte aus dem
                  Puffer data_in zum DSP. Nachdem alle Daten
                  Åbertragen wurden, wartet die Funktion bis die
                  Daten verarbeitet wurden. Dann werden size_out
                  DSP-Worte in den Puffer data_out zurÅckkopiert,
                  unabhÑngig davon, wieviel Daten wirklich vor-
                  liegen. Sollen keine Daten gesendet werden, muû
                  man size_in auf Null setzen. Gleiches gilt fÅr
                  das Empfangen, in diesem Fall wird size_out
                  Null zugewiesen. size_in und size_out sind auf
                  64 KByte begrenzt.
                  
Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_BlkHandShake\#   \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkWords\#       \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkHandShake") )
Dsp_BlkHandShake                                      PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkHandShake( char *data_in,
                                           long size_in,
                                           char *data_out,
                                           long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in DSP-Worte aus dem
                  Puffer data_in zum DSP. Nachdem alle Daten
                  Åbertragen wurden, wartet die Funktion bis die
                  Daten verarbeitet wurden. Dann werden size_out
                  DSP-Worte in den Puffer data_out zurÅckkopiert,
                  unabhÑngig davon, wieviel Daten wirklich vor-
                  liegen. Sollen keine Daten gesendet werden, muû
                  man size_in auf Null setzen. Gleiches gilt fÅr
                  das Empfangen, in diesem Fall wird size_out
                  Null zugewiesen. size_in und size_out sind auf
                  64 KByte begrenzt. Daten werden nur ausgetauscht,
                  wenn der DSP-Prozeû dazu bereit ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkWords\#       \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkUnpacked") )
Dsp_BlkUnpacked                                       PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkUnpacked( long *data_in,
                                          long size_in,
                                          long *data_out,
                                          long size_out );

Prototyp in       tos.h

Beschreibung      Diese Funktion arbeitet nur mit DSP-Worten, die
                  hîchstens 4 Byte lang sind. Die LÑnge der DSP-
                  Worte kann mit \#Dsp_GetWordSize\# bestimmt werden.
                  data_in und data_out sind long-Felder. size_in
                  und size_out beziehen sich auf die Grîûe der
                  Felder in Langworten. Je nach DSP-WortlÑnge
                  werden nur die unteren Bytes longs Åbertragen.
                  Die Funktion kopiert size_in DSP-Worte aus dem
                  Puffer data_in zum DSP. Nachdem alle Daten
                  Åbertragen wurden, wartet die Funktion bis die
                  Daten verarbeitet wurden. Dann werden size_out
                  DSP-Worte in den Puffer data_out zurÅckkopiert,
                  unabhÑngig davon, wieviel Daten wirklich vor-
                  liegen. Sollen keine Daten gesendet werden, muû
                  man size_in auf Null setzen. Gleiches gilt fÅr
                  das Empfangen, in diesem Fall wird size_out
                  Null zugewiesen. size_in und size_out sind auf
                  64 KByte begrenzt.
                  Es wird nicht garantiert, daû die hîherwertigen
                  Bytes der empfangenen longs Null sind, wenn
                  die DSP-WortlÑnge kleiner als 4 ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkHandShake\#
                  \#Dsp_BlkWords\#       \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkWords") )
Dsp_BlkWords                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkWords( void *data_in,
                                       long size_in,
                                       void *data_out,
                                       long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in vorzeichenbehaf-
                  tete 16-Bit-Worte aus dem Puffer data_in zum
                  DSP. Die Worte werden vor der öbertragung vor-
                  zeichenrichtig auf DSP-Wortbreite erweitert.
                  Nachdem alle Daten Åbertragen wurden, wartet
                  die Funktion bis die Daten verarbeitet wurden.
                  Dann werden size_out 16-Bit-DSP-Worte in den
                  Puffer data_out zurÅckkopiert, unabhÑngig da-
                  von, wieviel Daten wirklich vorliegen. Sollen
                  keine Daten gesendet werden, muû man size_in
                  auf Null setzen. Gleiches gilt fÅr das Empfan-
                  gen, in diesem Fall wird size_out Null zuge-
                  wiesen. size_in und size_out sind auf 64 KByte
                  begrenzt. Daten werden nur ausgetauscht, wenn
                  der DSP-Prozeû dazu bereit ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkBytes") )
Dsp_BlkBytes                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkBytes( void *data_in,
                                       long size_in,
                                       void *data_out,
                                       long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in vorzeichenlose
                  Bytes aus dem Puffer data_in zum DSP. Nachdem
                  alle Daten Åbertragen wurden, wartet die Pro-
                  zedur bis die Daten verarbeitet wurden. Dann
                  werden size_out 8-Bit-DSP-Worte in den Puffer
                  data_out zurÅckkopiert, unabhÑngig davon, wie-
                  viel Daten wirklich vorliegen. Sollen keine
                  Daten gesendet werden, muû man size_in auf
                  Null setzen. Gleiches gilt fÅr das Empfangen,
                  in diesem Fall wird size_out Null zugewiesen.
                  size_in und size_out sind auf 64 KByte be-
                  grenzt. Daten werden nur ausgetauscht, wenn der
                  DSP-Prozeû dazu bereit ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("DSPBLOCK") )
DSPBLOCK                                              PCTOSLIB.LIB
------------------------------------------------------------------

In der Headerdatei TOS.H ist die folgende Struktur DSPBLOCK zur
ParameterÅbergabe an die Funktion \#Dsp_MultBlocks\# definiert:

     typedef struct
     {
         int     blocktype;   /* Typ der Daten im Puffer: */
                              /*   0 : LongInt            */
                              /*   1 : Integer            */
                              /*   2 : Byte               */
         long    blocksize;   /* Puffergrîûe              */
         void    *blockaddr;  /* Zeiger auf den Puffer    */
     } DSPBLOCK;
\end

screen( capsensitive("Dsp_MultBlocks") )
Dsp_MultBlocks                                        PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_MultBlocks( long numsend,
                                        long numreceive,
                                        \#DSPBLOCK\# *sendblocks,
                                        \#DSPBLOCK\# *receiveblocks );

Beschreibung      Die Funktion Dsp_MultBlocks sendet und empfÑngt
                  Daten vom DSP. numsend ist die Anzahl der zu
                  sendenden und numreceive die Anzahl der zu
                  empfangenden Blîcke. sendblocks und receiveblocks
                  sind Zeiger auf Strukturen, die die Puffer und
                  Blîcke beschreiben.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_BlkBytes\#
\end

screen( capsensitive("Dsp_InStream") )
Dsp_InStream                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_InStream( char *data_in,
                                       long block_size,
                                       long num_blocks,
                                       long *blocks_done );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert mittels DSP-Interrupt-
                  behandlung num_blocks Datenblîcke mit einer
                  Grîûe von block_size DSP-Worten aus dem Puffer
                  data_in zum DSP. Bei jedem Interrupt wird ein
                  Block Åbertragen, unabhÑngig davon, ob der DSP
                  empfangsbereit ist. Gleichzeitig wird der ZÑhler
                  blocks_done, der die Anzahl der Åbertragenen
                  Blîcke wiedergibt, inkrementiert. Da die Daten
                  per Interrupt Åbertragen werden, muû die Proze-
                  dur nicht warten. öber blocks_done kann das Pro-
                  gramm im weiteren Verlauf feststellen, ob die
                  öbertragung beendet ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_SetVectors\#     \#Dsp_RemoveInterrupts\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_OutStream") )
Dsp_OutStream                                         PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_OutStream( char *data_out,
                                        long block_size,
                                        long num_blocks,
                                        long *blocks_done );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert mittels DSP-Interrupt-
                  behandlung num_blocks Datenblîcke mit einer
                  Grîûe von block_size DSP-Worten vom DSP in
                  dem Puffer data_out. Bei jedem Interrupt wird
                  ein Block Åbertragen. Gleichzeitig wird der
                  ZÑhler blocks_done, der die Anzahl der Åber-
                  tragenen Blîcke wiedergibt, inkrementiert.
                  Da die Daten per Interrupt Åbertragen werden,
                  muû die Funktion nicht warten. öber blocks_done
                  kann das Programm im weiteren Verlauf feststel-
                  len, ob die öbertragung beendet ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_InStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_SetVectors\#     \#Dsp_RemoveInterrupts\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_IOStream") )
Dsp_IOStream                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_IOStream( char *data_in,
                                       char *data_out,
                                       long block_insize,
                                       long block_outsize,
                                       long num_blocks,
                                       long *blocks_done );

Prototyp in       tos.h

Beschreibung      Die Funktion sendet und empfÑngt gleichzeitig
                  mittels DSP-Interruptbehandlung num_blocks
                  Datenblîcke mit einer Grîûe von block_insize
                  bzw. block_outsize DSP-Worten vom DSP. Die
                  gesendeten Daten werden dem Puffer data_in
                  entnommen, die empfangenen Daten werden im
                  Puffer data_out abgelegt. Bei jedem Interrupt
                  wird ein Block gesendet und einer empfangen
                  (eine Ausnahme bilden der erste und der letzte
                  Interrupt). Gleichzeitig wird der ZÑhler
                  blocks_done, der die Anzahl der Åbertragenen
                  Blîcke wiedergibt, inkrementiert. Da die Daten
                  per Interrupt Åbertragen werden, muû die Funktion
                  nicht warten. öber blocks_done kann das Programm
                  im weiteren Verlauf feststellen, ob die öbertra-
                  gung beendet ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_InStream\#
                  \#Dsp_OutStream\#      \#Dsp_GetWordSize\#
                  \#Dsp_SetVectors\#     \#Dsp_RemoveInterrupts\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_SetVectors") )
Dsp_SetVectors                                        PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_SetVectors( void (*receiver)( ),
                                         long (*transmitter)( ));

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_SetVectors installiert
                  Routinen, die aufgerufen werden, wenn der
                  DSP Åber einen Interrupt Daten Åbertragen
                  will. receiver ist ein Zeiger auf eine Routine,
                  die aufgerufen wird, nachdem der DSP Daten ver-
                  schickt hat, und transmitter ein Zeiger auf eine
                  Routine, die aufgerufen wird, bevor der DSP
                  Daten empfÑngt. Die Empfangsroutine receiver
                  erhÑlt als Parameter auf dem Stack einen
                  long, der vom DSP gesendet wurde. Die Sende-
                  routine transmitter Åbergibt einen long an
                  den DSP in Register D0. Dieser muû ungleich
                  Null sein, damit er, d.h. dessen niederwertigen
                  drei Bytes an den DSP Åbertragen wird. Beide
                  Routinen werden mit dem Assemblerbefehl RTS
                  abgeschlossen.
                  Wird fÅr receiver oder transmitter 0 Åber-
                  geben, so wird der entsprechende Interrupt ge-
                  sperrt. Um eine Routine wieder zu entfernen, muû
                  man \#Dsp_RemoveInterrupts\# aufrufen.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_RemoveInterrupts\#
\end

screen( capsensitive("Dsp_RemoveInterrupts") )
Dsp_RemoveInterrupts                                  PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_RemoveInterrupts( int mask );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_RemoveInterrupts unterbindet
                  die Generierung von DSP-Interrupts. Der Para-
                  meter mask bestimmt, welche Interrupts betroffen
                  sind:

                  ------------------------------------------------
                  mask  Bedeutung
                  ------------------------------------------------
                  1     Keine Interrupts zum Senden von Daten
                        durch den DSP
                  2     Keine Interrupts zum Empfangen von Daten
                        durch den DSP
                  3     Keine Interrupts zum Senden oder Empfangen
                        von Daten durch den DSP
                  ------------------------------------------------

                  Die Funktion entfernt ebenfalls Routinen, die
                  mit Dsp_SetVectors installiert wurden.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_SetVectors\#
\end

screen( capsensitive("Dsp_GetWordSize") )
Dsp_GetWordSize                                       PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_GetWordSize( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_GetWordSize ermittelt die
                  Grîûe in Byte, die ein DSP-Wort lang ist.
                  Diese Funktion ist notwendig, um die Puffer
                  fÅr die DatenÅbertragung ausreichend zu dim-
                  ensionieren.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_InStream\#
                  \#Dsp_IOStream\#       \#Dsp_OutStream\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_Lock") )
Dsp_Lock                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Lock( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Lock ermittelt, ob der DSP
                  fÅr Anwendungen verfÅgbar ist und nicht durch
                  jemand anders blockiert wird. Wird als Er-
                  gebnis -1 zurÅckgegeben, so wird der DSP
                  bereits durch einen anderen Prozeû benutzt.
                  Null dagegen kennzeichnet die VerfÅgbarkeit
                  des DSPs und blockiert ihn gleichzeitig fÅr
                  andere, bis ein Aufruf von \#Dsp_Unlock\# erfolgt.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Unlock\#         \#Dsp_Available\#
                  \#Dsp_Reserve\#        \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_Unlock") )
Dsp_Unlock                                            PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_Unlock( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Unlock gibt den DSP fÅr andere
                  Prozesse frei.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Available\#
                  \#Dsp_Reserve\#        \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_Available") )
Dsp_Available                                         PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_Available( long *xavailable,
                                        long *yavailable );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Available ermittelt den freien
                  X- und Y-Speicher. Freier Speicher beginnt stets
                  an der physikalischen Adresse 0. Die unteren
                  64 Worte sind fÅr Interrupt-Vektoren reserviert.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Reserve\#        \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_Reserve") )
Dsp_Reserve                                           PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Reserve( long xreserve, long yreserve );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Reserve reserviert xreserve
                  Worte X-Speicher und yreserve Worte Y-Speicher.
                  Die Speicheranforderung darf den verfÅgbaren
                  Speicher auf keinen Fall Åbertreffen. Diese
                  Funktion ist notwendig, damit DSP-Prozesse
                  nicht durch DSP-Unterprogramme Åberschrieben
                  werden. Die Reservierung bleibt bis zum nÑchsten
                  Aufruf von Dsp_Reserve bestehen. Das Funktions-
                  resultat Null zeigt die erfolgreiche Reservie-
                  rung an, -1 steht fÅr einen Fehler.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_LoadProg") )
Dsp_LoadProg                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_LoadProg( char *file, int ability,
                                                  char *buffer );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_LoadProg lÑdt das DSP-Pro-
                  gramm mit dem Namen filename. Das Programm
                  muû im .LOD-Format vorliegen und darf den
                  durch \#Dsp_Reserve\# reservierten Speicher
                  nicht Åberschreiten. Der Parameter ability
                  identifiziert das Programm. buffer zeigt auf
                  einen Speicherbereich, in dem das generierte
                  Programm zwischengespeichert werden kann.
                  Die Grîûe des Speicherbereichs berechnet sich
                  nach der Formel

                       DSP-Wortgrîûe * ( Anzahl der
                         Programm- und Datenworte in der
                         .LOD-Datei + ( DSP-Wortgrîûe *
                           Anzahl der Blîcke in der .LOD-
                           Datei ))

                  Danach wird das Programm ausgefÅhrt.
                  Der RÅckgabewert Null signalisiert den er-
                  folgreichen Programmstart, ansonsten erhÑlt
                  man -1.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
                  \#Dsp_LodToBinary\#
\end

screen( capsensitive("Dsp_ExecProg") )
Dsp_ExecProg                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_ExecProg( char *codeptr,
                                       long codesize,
                                       int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_ExecProg startet das im BinÑr-
                  Format an der Stelle codeptr vorliegende DSP-
                  Programm der LÑnge codesize. Seine Grîûe darf
                  den durch \#Dsp_Reserve\# reservierten Speicher
                  nicht Åberschreiten. Der Parameter ability
                  identifiziert das Programm.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_LoadProg\#       \#Dsp_ExecBoot\#
                  \#Dsp_LodToBinary\#
\end

screen( capsensitive("Dsp_ExecBoot") )
Dsp_ExecBoot                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_ExecBoot( char *codeptr,
                                       long codesize,
                                       int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_ExecBoot lÑdt ein Boot-Programm
                  in die 512 Worte des internen DSP-Speichers. Vor
                  dem Laden wird ein Reset auf dem DSP ausgefÅhrt.
                  Das DSP-Programm muû im BinÑr-Format vorliegen.
                  Der Parameter codeptr zeigt auf den Programm-
                  start. Die LÑnge des Programms wird durch den
                  Parameter codesize bestimmt. ability identifi-
                  ziert das Programm.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_LoadProg\#       \#Dsp_ExecProg\#
                  \#Dsp_LodToBinary\#
\end

screen( capsensitive("Dsp_LodToBinary") )
Dsp_LodToBinary                                       PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  Dsp_LodToBinary( char *file,
                                          char *codeptr );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_LodToBinary konvertiert den
                  Inhalt der .LOD-Datei mit dem Namen filename
                  ins BinÑrformat. Das so erzeugte DSP-Programm
                  wird an der Adresse codeptr abgelegt. Dieser
                  Speicherbereich muû ausreichend groû dimen-
                  sioniert sein. Danach kann das Programm mit
                  \#Dsp_ExecProg\# oder \#Dsp_ExecBoot\# ausgefÅhrt werden.
                  Bei erfolgreicher Konvertierung erhÑlt man
                  als Resultat die LÑnge des Programms in DSP-
                  Worten oder beim Auftreten eines Fehlers einen
                  negative Wert.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_LoadProg\#       \#Dsp_ExecBoot\#
                  \#Dsp_ExecProg\#
\end

screen( capsensitive("Dsp_TriggerHC") )
Dsp_TriggerHC                                         PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_TriggerHC( int vector );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_TriggerHC fÅhrt Vector vector
                  aus. Nur die zwei Vektoren $13 und $14 stehen
                  DSP-Programmen zur freien VerfÅgung.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.
\end

screen( capsensitive("Dsp_RequestUniqueAbility") )
Dsp_RequestUniqueAbility                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_RequestUniqueAbility( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_RequestUniqueAbility erteilt
                  einem DSP-Prozeû eine fÅr die gesammte System-
                  laufzeit eindeutige Identifikation, mittels
                  derer man feststellen kann, ob der zum Prozeû
                  gehîrige Code resident im DSP vorhanden ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_GetProgAbility\#
\end

screen( capsensitive("Dsp_GetProgAbility") )
Dsp_GetProgAbility                                    PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_GetProgAbility( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_GetProgAbility erteilt
                  einem DSP-Prozeû eine Identifikation, mittels
                  derer man feststellen kann, ob der zum Prozeû
                  gehîrige Code bereits im DSP vorhanden ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_RequestUniqueAbility\#
\end

screen( capsensitive("Dsp_FlushSubroutines") )
Dsp_FlushSubroutines                                  PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_FlushSubroutines( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_FlushSubroutines entfernt alle
                  Unterprogramme aus dem DSP-Speicher und erhîht
                  somit den verfÅgbaren freien Speicher.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_LoadSubroutine\# \#Dsp_InqSubrAbility\#
                  \#Dsp_RunSubroutine\#
\end

screen( capsensitive("Dsp_LoadSubroutine") )
Dsp_LoadSubroutine                                    PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_LoadSubroutine( char *codeptr,
                                            long codesize,
                                            int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_LoadSubroutine installiert das
                  DSP-Unterprogramm aus dem Puffer codeptr im
                  DSP-Speicher. Das Unterprogramm ist codesize
                  DSP-Worte lang und hat die Identifikation
                  ability. Als Resultat erhÑlt man eine positive
                  Kennung, mittels derer das Unterprogramm mit
                  der Funktion \#Dsp_RunSubroutine\# aufgerufen werden
                  kann. Null zeigt an, daû das Unterprogramm nicht
                  installiert werden konnte. Das Unterprogramm
                  bleibt solange resident im DSP-Speicher bis
                  kein Platz mehr fÅr neue Unterprogramme ist
                  und es verdrÑngt wird oder die Funktion
                  Dsp_FlushSubroutines aufgerufen wird.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_RunSubroutine\#  \#Dsp_FlushSubroutines\#
                  \#Dsp_InqSubrAbility\#
\end

screen( capsensitive("Dsp_InqSubrAbility") )
Dsp_InqSubrAbility                                    PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_InqSubrAbility( int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_InqSubrAbility bestimmt die
                  Kennung des Unterprogramms mit der Funktio-
                  nalitÑt abilitiy. Als Resultat erhÑlt man die
                  Kennung des Unterprogramms. Ist das entspre-
                  chende Unterprogramm nicht im DSP-Speicher
                  vorhanden, wird Null zurÅckgegeben. In diesem
                  Fall muû das Unterprogramm mit \#Dsp_LoadSubroutine\#
                  installiert werden.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_RunSubroutine\#  \#Dsp_FlushSubroutines\#
                  \#Dsp_LoadSubroutine\#
\end

screen( capsensitive("Dsp_RunSubroutine") )
Dsp_RunSubroutine                                     PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_RunSubroutine( int handle );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_RunSubroutine fÅhrt das Unter-
                  programm mit der Kennung handle aus. Die Ken-
                  nung fÅr ein Unterprogramm findet man mittels
                  Dsp_InqSubrAbility oder Dsp_LoadSubroutine
                  heraus. Wird Null zurÅckgegeben, konnte das
                  Unterprogramm gestartet werden. Andernfalls
                  erhÑlt man ein negatives Resultat.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_InqSubrAbility\# \#Dsp_FlushSubroutines\#
                  \#Dsp_LoadSubroutine\#
\end

screen( capsensitive("Dsp_Hf0") )
Dsp_Hf0                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf0( int flag );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf0 ermittelt bzw. setzt den
                  Wert des Bits 3 des HSR. Der Parameter flag
                  hat die folgende Bedeutung:

                  ------------------------------------------------
                  flag  Bedeutung
                  ------------------------------------------------
                  0     Bit 3 des HSR lîschen
                  1     Bit 3 des HSR setzen
                  -1    Bit 3 des HSR unverÑndert lassen
                  ------------------------------------------------

                  Als Resultat erhÑlt man den Wert des Bit 3 des
                  HSR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Hf1\#            \#Dsp_Hf2\#
                  \#Dsp_Hf3\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_Hf1") )
Dsp_Hf1                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf1( int flag );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf1 ermittelt bzw. setzt den
                  Wert des Bits 4 des HSR. Der Parameter flag
                  hat die folgende Bedeutung:

                  ------------------------------------------------
                  flag  Bedeutung
                  ------------------------------------------------
                  0     Bit 4 des HSR lîschen
                  1     Bit 4 des HSR setzen
                  -1    Bit 4 des HSR unverÑndert lassen
                  ------------------------------------------------

                  Als Resultat erhÑlt man den Wert des Bit 4 des
                  HSR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf2\#
                  \#Dsp_Hf3\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_Hf2") )
Dsp_Hf2                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf2( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf2 ermittelt den Wert des
                  Bits 3 des HCR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf1\#
                  \#Dsp_Hf3\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_Hf3") )
Dsp_Hf3                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf3( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf3 ermittelt den Wert des
                  Bits 4 des HCR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf1\#
                  \#Dsp_Hf2\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_HStat") )
Dsp_HStat                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       char  Dsp_HStat( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_HStat ermittelt den Wert des
                  ISR-Registers. Somit kann man feststellen, ob
                  Daten empfangen oder gesendet werden kînnen.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfÅgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf1\#
                  \#Dsp_Hf2\#            \#Dsp_Hf3\#
\end

screen( capsensitive("VERTFLAG"),
		capsensitive("FALC_VGA"),
		capsensitive("OVERSCAN"),
		capsensitive("TV"),
		capsensitive("BPS16"),
		capsensitive("PAL"),
		capsensitive("COL80"),
		capsensitive("STMODES"),
		capsensitive("BPS8"),
		capsensitive("NUMCOLS"),
		capsensitive("BPS1"),
		capsensitive("BPS2"),
		capsensitive("COL40"),
		capsensitive("BPS4") )
Konstanten zur Videohardware des Falcons              PCTOSLIB.LIB
------------------------------------------------------------------

Zur vereinfachten Programmierung des Videohardwareregisters des
Falcons mittels der Funktion \#Vsetmode\# sind in der Headerdatei
tos.h die folgenden Konstanten definiert, die mit | kombiniert
werden:

    #define VERTFLAG  0x0100  /* Interlace aktivieren          */
    #define STMODES   0x0080  /* ST-kompatible Grafik          */
    #define OVERSCAN  0x0040  /* Overscan aktivieren           */
    #define PAL       0x0020  /* PAL-Modus                     */
    #define FALC_VGA  0x0010  /* VGA-Modus                     */
    #define TV        0x0000  /* TV-Modus                      */

    #define COL80     0x0080  /* Bildbreite mind. 640 Pixel    */
    #define COL40     0x0000  /* Bildbreite 320 Pixel          */

    #define BPS16     4       /* 16 Farbebenen: 65536 Farben   */
    #define BPS8      3       /*  8 Farbebenen:   256 Farben   */
    #define BPS4      2       /*  4 Farbebenen:    16 Farben   */
    #define BPS2      1       /*  2 Farbebenen:     4 Farben   */
    #define BPS1      0       /*  1 Farbebenen:     2 Farben   */

Mit der folgenden Konstante kann die Anzahl der Farbebenen aus-
maskiert werden:

    #defineNUMCOLS    7       /* if (( mode & NUMCOLS ) == 0 ) */
                              /*   puts( "monochrome mode" );  */
\end

screen( capsensitive("Vsetmode") )
Vsetmode                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Vsetmode( int modecode );

Prototyp in       tos.h

Beschreibung      Die Funktion Vsetmode programmiert das Video-
                  hardwareregister der Falcon-Computer. Die Bits
                  des Parameters mode haben folgende Bedeutung:

                  ------------------------------------------------
                  Bits   Bedeutung
                  ------------------------------------------------
                  0-2    Anzahl der Farbebenen:
                           0:    1 Ebene        2 Farben
                           1:    2 Ebenen       4 Farben
                           2:    4 Ebenen      16 Farben
                           3:    8 Ebenen     256 Farben
                           4:   16 Ebenen   65536 Farben

                  3      Gesetzt:  Bildbreite mindestens 640 Pixel
                         Gelîscht: Bildbreite 320 Pixel

                  4      Gesetzt:  VGA-Modus
                         Gelîscht: TV-Modus (auch Atari-SC-Monitore)

                  5      Gesetzt:  PAL-Modus
                         Gelîscht: NTSC-Modus

                  6      Gesetzt: Overscan aktiv

                  7      Gesetzt: ST-kompatible Grafik

                  8      Gesetzt: Interlace-Modus aktiv
                  ------------------------------------------------

                  Zur \link("VERTFLAG")einfacheren Kodierung\# sind vordefinierte
                  Konstanten vorhanden.
                  Als Resultat erhÑlt man den alten Inhalt des
                  Videohardwareregisters.

Hinweis           Es findet keine öberprÅfung auf die Richtigkeit
                  der Kodierung fÅr den angeschlossenen Monitor
                  statt. Also Vorsicht!
                  Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#VsetSync\#           \#mon_type\#
                  \#VgetSize\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("mon_type") )
mon_type                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  mon_type( void );

Prototyp in       tos.h

Beschreibung      Die Funktion mon_type ermittelt den angeschlos-
                  senen Monitortyp. Als Resultat erhÑlt man einen
                  der folgenden Werte:

                  ------------------------------------------------
                  Resultat  Bedeutung
                  ------------------------------------------------
                  0         ST-Monochrommonitor
                  1         ST-Farbmonitor
                  2         VGA-Monitor
                  3         TV-GerÑt
                  ------------------------------------------------

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#VsetSync\#           \#Vsetmode\#
                  \#VgetSize\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VsetSync") )
VsetSync                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VsetSync( int flag );

Prototyp in       tos.h

Beschreibung      Die Funktion VsetSync legt fest, auf welche Art
                  Synchronisation erfolgen soll. Der Parameter
                  flag wird wie folgt kodiert:

                  ------------------------------------------------
                  Bit    Bedeutung fÅr gesetzte Bits
                  ------------------------------------------------
                  0      Externer Takt
                  1      Vertikale Synchronisation
                  2      Horizontale Synchronisation
                  ------------------------------------------------

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VgetSize\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VgetSize") )
VgetSize                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  VgetSize( int mode );

Beschreibung      Die Funktion VgetSize ermittelt die Grîûe des
                  Bildschirmpuffers in Bytes fÅr den Grafikmodus
                  \#mode\#.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VgetRGB") )
VgetRGB                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VgetRGB( int index, int count, long *array );

Beschreibung      Die Funktion VgetRGB ermittelt die RGB-Werte
                  fÅr count Farben ab dem Farbindex index. Die
                  resultierenden Werte werden in array abgelegt.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetSize\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VsetRGB") )
VsetRGB                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VsetRGB( int index, int count, long *array );

Beschreibung      Die Funktion VsetRGB setzt die RGB-Werte
                  fÅr count Farben ab dem Farbindex index. Die
                  Farbwerte sind in array abgelegt.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetSize\#
                  \#VgetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VsetMask") )
VsetMask                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VsetMask( int ormask, int andmask,
                                                 int overlay );

Beschreibung      Die Funktion VsetMask setzt Masken, die benutzt
                  werden, um die durch die VDI-Funktion \#vs_color\#
                  gesetzten Farben zu modifizieren. vs_color er-
                  mittelt zu seinem Parameter einen RGB-Wert.
                  Dieser wird bitweise mit ormask verodert und
                  mit andmask verundet. Somit kînnen Farben im
                  True-Color-Modus transparent erscheinen.
                  Ist overlay ungleich Null, wird in den Overlay-
                  modus geschalten bzw. mit Null zurÅck.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetSize\#
                  \#VgetRGB\#            \#VsetRGB\#
\end

screen( capsensitive("locksnd") )
locksnd                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  locksnd( void );

Prototyp in       tos.h

Beschreibung      Die Funktion locksnd sperrt das Soundsystem fÅr
                  andere Anwendungen.
                  Ist das Soundsystem bereits vergeben, so erhÑlt
                  man als Ergebnis ein negatives Resultat oder
                  im Erfolgsfall den Wert 1.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("unlocksnd") )
unlocksnd                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  unlocksnd( void );

Prototyp in       tos.h

Beschreibung      Die Funktion unlocksnd gibt das Soundsystem fÅr
                  andere Anwendungen frei, nachdem es zuvor ge-
                  sperrt wurde.
                  War das Soundsystem bereits verfÅgbar, so erhÑlt
                  man als Ergebnis ein negatives Resultat oder
                  im Erfolgsfall den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#locksnd\#
\end

screen( capsensitive("soundcmd") )
soundcmd                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  soundcmd( int mode, int data );

Prototyp in       tos.h

Beschreibung      Die Funktion soundcmd setzt bzw. ermittelt die
                  Parameter des A/D- und D/A-Wandlers. Der Para-
                  meter mode bestimmt das Kommando und data die
                  vorzunehmende Einstellung.

                  ------------------------------------------------
                  mode  Bedeutung
                  ------------------------------------------------
                  0     AbschwÑchung des linken Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  1     AbschwÑchung des rechten Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  2     VerstÑrkung des linken Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  3     VerstÑrkung des rechten Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  4     Eingabequellen des 16-Bit-Hardware-
                        addierers. Bit 0 von data reprÑsentiert
                        den A/D-Wandler und Bit 1 den Multiplexer

                  5     Eingabequellen des A/D-Wandlers. Bit 0
                        steht fÅr den rechten und Bit 1 fÅr den
                        linken Kanal. Ist ein Bit gesetzt, wird
                        werden die Daten dem Soundchip entnommen,
                        sonst dem Mikrophon.

                  6     KompatibilitÑt zum STE-Soundsystem. data
                        wird als Vorteiler genommen, falls der
                        mittels \#devconnect\# eingestellte Vorteiler
                        gleich Null ist:
                            0      Vorteiler ist 1280
                            1      Vorteiler ist 640
                            2      Vorteiler ist 320
                            3      Vorteiler ist 160
                  ------------------------------------------------

                  Wird fÅr den Parameter data der Wert -1 Åber-
                  geben, so bleibt die Einstellung unverÑndert.
                  Als Resultat erhÑlt man stets die aktuelle
                  Einstellung.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#unlocksnd\#
                  \#locksnd\#
\end

screen( capsensitive("setbuffer") )
setbuffer                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setbuffer( int reg, void *begaddr,
                                             void *endaddr );

Prototyp in       tos.h

Beschreibung      Die Funktion setbuffer setzt den Puffer fÅr
                  die Wiedergabe- (reg = 0) bzw. Aufnahmedaten
                  (reg = 1). Der Parameter begaddr zeigt auf
                  den Anfang des Puffers und endaddr auf das
                  letzte Byte + 1 des Puffers.
                  Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("setmode") )
setmode                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setmode( int mode );

Prototyp in       tos.h

Beschreibung      Die Funktion setmode gibt die Art des Aufnahme-
                  und Wiedergabemodus an:

                  ------------------------------------------------
                  mode  Bedeutung
                  ------------------------------------------------
                  0      8 Bit Stereo
                  1     16 Bit Stereo
                  2      8 Bit Mono
                  ------------------------------------------------

                  Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmontracks\#       \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("settracks") )
settracks                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  settracks( int playtracks, int rectracks );

Prototyp in       tos.h

Beschreibung      Die Funktion settracks setzt die Anzahl der
                  Aufnahme- (rectracks) und Wiedergabespuren
                  (playtracks). Es stehen maximal je 4 Spuren
                  zur VerfÅgung. Als Argument wird die Anzahl
                  - 1 Åbergeben!
                  Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmontracks\#       \#setmode\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("setmontracks") )
setmontracks                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setmontracks( int montrack );

Prototyp in       tos.h

Beschreibung      Die Funktion setmontracks legt fest, daû die
                  Ausgabe einer bestimmten Spur Åber den in-
                  ternen Lautsprecher erfolgen soll. Dieser
                  kann jeweils nur eine Spur wiedergeben.

Parameter         montrack bestimmt eine der vier mîglichen Spu-
                  ren. Diese sind von 0 bis 3 durchnumeriert.

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("setinterrupt") )
setinterrupt                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setinterrupt( int src_inter, int cause );

Prototyp in       tos.h

Beschreibung      Die Funktion setinterrupt bestimmt, welcher
                  Interrupt nach dem Aufnehmen bzw. Abspielen
                  ausgelîst werden soll.

Parameter         ------------------------------------------------
                  src_inter  Bedeutung
                  ------------------------------------------------
                  0          Timer-A-Interrupt
                  1          MFP-Interrupt 7
                  ------------------------------------------------

                  ------------------------------------------------
                  cause      Bedeutung
                  ------------------------------------------------
                  0          Kein Interrupt
                  1          Interrupt nach dem Abspielen
                  2          Interrupt nach dem Aufnehmen
                  3          Interrupt nach Aufnehmen und Ab-
                             spielen
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("buffoper") )
buffoper                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  buffoper( int mode );

Prototyp in       tos.h

Beschreibung      Die Funktion buffoper legt den Aufnahme- und
                  Wiedergabemodus fest.

Parameter         Wird fÅr mode der Wert -1 Åbergeben, wird die
                  aktuelle Einstellung ermittelt. Sonst wird
                  mode wie folgt kodiert:

                  ------------------------------------------------
                  Bit  Operation
                  ------------------------------------------------
                  0    Wiedergabe
                  1    Wiedergabewiederholung
                  2    Aufnahme
                  1    Aufnahmewiederholung
                  ------------------------------------------------

                  Gesetzte Bits schalten eine Operation ein, ge-
                  lîschte Bits aus.

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.
                  Wurde fÅr mode -1 Åbergeben, erhÑlt man die
                  aktuelle Einstellung, deren Kodierung der des
                  Parameters mode entspricht.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffptr\#            \#devconnect\#
                  \#dsptristate\#        \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("dsptristate") )
dsptristate                                           PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  dsptristate( int dspxmit, int dsprec );

Prototyp in       tos.h

Beschreibung      Die Funktion dsptristate koppelt Leitungen vom
                  Multiplexer ab, wenn externe Hardware am SSI-
                  Port des DSP angeschlossen wird.

Parameter         ------------------------------------------------
                  Parameter  Bedeutung
                  ------------------------------------------------
                  dspxmit    Der Wert 0 koppelt den Multiplexer
                             von der entsprechenden Leitung ab,
                             1 erlaubt die Verbindung

                  dsprec     Der Wert 0 koppelt den Multiplexer
                             von der entsprechenden Leitung ab,
                             1 erlaubt die Verbindung
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("gpio") )
gpio                                                  PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  gpio( int mode, int data );

Prototyp in       tos.h

Beschreibung      Die Funktion gpio dient der Kommunikation Åber
                  die externen DSP-Buchse.

Parameter         ------------------------------------------------
                  mode  Bedeutung
                  ------------------------------------------------
                  0     Setzen der Ein-/Ausgaberichtung
                        Die unteren drei Bits von data reprÑsen-
                        tieren die Mehrzweckleitungen. Ein ge-
                        setztes Bit steht fÅr eine Ausgabe- und
                        ein gelîschtes fÅr eine Eingabeleitung.

                  1     Lesen der Mehrzweckleitungen
                        Den Status der Leitungen erhÑlt man als
                        Funktionsresultat.

                  2     Schreiben auf den Mehrzweckleitungen
                        Der Parameter data enthÑlt den neuen
                        Status der Mehrzweckleitungen.
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.
                  Hatte der Parameter mode den Wert 1, so erhÑlt
                  man den Status der Mehrzweckleitungen.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("devconnect") )
devconnect                                            PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  devconnect( int src, int dst,
                                     int srcclk, int prescale,
                                     int protocol );

Prototyp in       tos.h

Beschreibung      Die Funktion devconnect verbindet Komponenten
                  des Audio-Subsystems.

Parameter         ------------------------------------------------
                  Parameter  Bedeutung
                  ------------------------------------------------
                  src        Quellkomponente:
                               0   DMA-Ausgabe
                               1   DSP-Ausgabe
                               2   Externer Eingabekanal
                               3   A/D-Wandler - Mikrophon

                  dst        Bitvektor der Zielkomponenten:
                               Bit 0   DMA-Eingabe
                               Bit 1   DSP-Eingabe
                               Bit 2   Externer Ausgabekanal
                               Bit 3   D/A-Wandler - Lautsprecher

                  srcclk     Takt fÅr die Quellkomponente:
                               0   Interner 25,175 MHz Takt
                               1   Externer Takt
                               2   Interner 32 MHz Takt

                  prescale   Taktvorteiler. Die Sample-Rate ergibt
                             sich aus dem Takt geteilt durch 256
                             und geteilt durch Vorteiler + 1. Die
                             Werte fÅr den Vorteiler rangieren
                             von 0 bis 11.
                             Wird fÅr den Vorteiler 0 Åbergeben,
                             wird in den \link("soundcmd")STE-KompatibilitÑtsmodus\#
                             geschaltet.

                  protocol   Wird 0 Åbergeben, findet eine öber-
                             tragung mit Handshaking statt, bei
                             1 erfolgt kein Handshaking.
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#dsptristate\#        \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("sndstatus") )
sndstatus                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  sndstatus( int reset );

Prototyp in       tos.h

Beschreibung      Die Funktion sndstatus ermittelt den aktuellen
                  Status des A/D- und D/A-Wandlers. Sie kann
                  diesen ebenfalls neu initialisieren.

Parameter         Hat res den Wert 1 wird der A/D- und D/A-Wand-
                  ler neu initialisiert (unteranderem werden die
                  öberlaufbits gelîscht). Andernfalls wird der
                  aktuelle Status ermittelt

Resultat          Liegt kein Fehler vor erhÑlt man als Ergebnis
                  den Wert Null. Ansonsten stellt das Resultat
                  einen Bitvektor dar, der sich wie folgt ent-
                  schlÅsselt:

                  ------------------------------------------------
                  Bits  Bedeutung
                  ------------------------------------------------
                  0-3   1  UngÅltiges Kontrollfeld
                        2  UngÅltiges Syncformat
                        3  UngÅltiger Takt

                  4     Linker öberlauf

                  5     Rechter öberlauf
                  ------------------------------------------------

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmontracks\#       \#setmode\#
                  \#settracks\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("buffptr") )
buffptr                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  buffptr( long *ptr );

Prototyp in       tos.h

Beschreibung      Die Funktion buffptr ermittelt die aktuelle
                  Wiedergabe- und Aufnahmepositionen in den ent-
                  sprechenden Puffern.

Parameter         bptr zeigt auf einen mindestens 4 Langworte
                  groûen Puffer. In diesen werden die Positions-
                  zeiger angelegt. Der erste long des Puffer
                  enthÑlt einen Zeiger auf die aktuelle Wieder-
                  gabeposition und der zweite long einen
                  Zeiger auf die aktuelle Abspielposition.

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfÅgbar.

Querverweise      \#buffoper\#           \#devconnect\#
                  \#dsptristate\#        \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("Bioskeys") )
Name           ØBIOS standard keysÆ - Tastatur reinitialisieren.

Xbiosnummer    24

Definition     void Bioskeys(void);

Prototyp in    tos.h

Beschreibung   Bioskeys ist eine \#XBIOS\#-Routine zur Re-Initialisierung
               der Tastatur-Codes. Dies ist meist nur dann nîtig, wenn
               die Tastatur mit Hilfe der Funktion Keytbl
               umprogrammiert wurde.
Ergebnis       Die Funktion liefert kein Ergebnis.
Beispiel       Siehe Keytbl
Querverweis    \#Keytbl\#
\end

screen( capsensitive("Blitmode") )
Name           Øblitter modeÆ - Blitter-Chip konfigurieren.

Xbiosnummer    64

Definition     int Blitmode(int mode);

Prototyp in    tos.h

Beschreibung   Blitmode ist eine \#XBIOS\#-Routine um den Blitter einzu-
               schalten oder seine Existenz festzustellen. Wenn im
               Parameter mode der Wert -1 angegeben wird, dann erhÑlt
               man den Status des Blitter-Chips. Bei allen anderen
               Werten wird der Blitter konfiguriert:
               Bit            Beschreibung
               0              Blitter oder Line A umschalten
               1-14           reserviert (immer 0)
               15             immer 0
               Achtung: Diese Funktion gibt es zwar nur im Blitter-TOS.
               Sie liefert aber, wenn man sie nur als Nachfrage-
               Funktion verwendet, auch im alten TOS den korrekten
               Wert. (Bit 1 = 0: Blitter nicht vorhanden).
Ergebnis       Die Funktion liefert als Ergebnis im Bit 0 den Status
               des Blitters
                     0:  Blitter aus
                     1:  Blitter an
               und im Bit 1, ob ein Blitter vorhaden ist:
                     0:  Blitter nicht vorhanden
                     1:  Blitter vorhanden.
\end

screen( capsensitive("Cursconf") )
Name           Øcursor configurationÆ - legt die Arbeitsweise des
               Cursors fest.

Definition     int Cursconf( int func, int rate );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Cursconf verÑndert das Aussehen und
               wahlweise die Blinkgeschwindigkeit des Cursors. Der
               Parameter func kann folgende Werte annehmen:
0              Cursor abschalten
1              Cursor einschalten
2              Cursor blinkt
3              Cursor blinkt nicht
4              Die Blinkgeschwindigkeit des Cursors wird auf rate
               gesetzt.
5              Liefert die aktuelle Blinkfrequenz
               Der Parameter rate soll in Schritten der Wiederholfre-
               quenz des Bildschirms verwendet werden.
Ergebnis       Die Funktion liefert nur dann ein definiertes Ergebnis,
               nÑmlich die Blinkfrequenz, wenn im Parameter func die
               Zahl 5 Åbergeben wurde.
\end

screen( capsensitive("Dosound") )
Name           ØDosoundÆ - programmiert den Sound-Generator.

Xbiosnummer    32

Definition     void *Dosound( void *buf );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Dosound startet einen Prozeû zur
               Steuerung des Soundgenerators. Der Puffer buf enthÑlt
               Befehle fÅr die Programmierung des Sound-Generators.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Flopfmt") )
Name           ØFloppy formatÆ - formatiert einzelne Spuren auf einer
               Diskette.

Xbiosnummer    10

Definition     int Flopfmt( void *buf, long filler, int devno,
                            int spt, int trackno, int sideno,
                            int interlv, long magic, int virgin );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Flopfmt formatiert eine oder mehrere
               Spuren auf einer Diskette. In dem durch buf adres-
               sierten Speicherbereich muû das Abbild von mindestens
               spt Sektoren Platz finden, so daû eine Spur trackno auf
               der Seite sideno direkt formatiert werden kann. Der
               Parameter filler wird auûer bei STs mit Blitter-TOS
               nicht verwendet, wÑhrend interlv den physikalischen
               Abstand von logisch hintereinander geschriebenen Sek-
               toren festlegt. Der Parameter magic muû die Hexadezi-
               malzahl 0x87654321 enthalten. Der Parameter virgin ent-
               hÑlt den Wert, der in neuen Sektoren abgelegt werden
               soll. Dazu wird normalerweise die Konstante 0xE5E5 ver-
               wendet.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#Flopwr\#
\end

screen( capsensitive("DMAread") )
Name           ØDMA readÆ - liest einzelne Sektoren von einer
               DMA-Einheit.

Xbiosnummer    42

Definition     int  DMAread( long sector, int count, 
                              void *buffer, int devno );

Prototyp in    tos.h

Beschreibung   Die \link("XBIOS")XBios\#-Routine DMAread liest einzelne oder mehrere
               Sektoren von der DMA-Einheit devno. sector ist die
               Nummer des ersten Sektors, count die Anzahl der zu
               lesenden Sektoren, buffer ist ein Zeiger auf das
               Standard-RAM des TT, in das die Daten gelesen werden
               soll.
               Folgende Werte sind fÅr denvo erlaubt:
                     0 -  7        ACSI GerÑte
                     8 - 15        SCSI GerÑte
                     Andere        Reserviert
Hinweis        Dise Funktion ist nur im TOS030 des TT vefÅgbar.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAwrite\#, \#Floprd\#, \#Flopwr\#
\end

screen( capsensitive("DMAwrite") )
Name           ØDMA readÆ - schreibt einzelne Sektoren auf eine
               DMA-Einheit.

Xbiosnummer    43

Definition     int  DMAwrite( long sector, int count, 
                              void *buffer, int devno );

Prototyp in    tos.h

Beschreibung   Die \link("XBIOS")XBios\#-Routine DMAwrite schreibt einzelne oder
               mehrere Sektoren auf die DMA-Einheit devno. sector
               ist die Nummer des ersten Sektors, count die Anzahl der
               zu schreibenden Sektoren, buffer ist ein Zeiger auf das
               Standard-RAM des TT, aus dem die Daten geschrieben
               werden soll.
               Folgende Werte sind fÅr denvo erlaubt:
                     0 -  7        ACSI GerÑte
                     8 - 15        SCSI GerÑte
                     Andere        Reserviert
Hinweis        Dise Funktion ist nur im TOS030 des TT vefÅgbar.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAread\#, \#Floprd\#, \#Flopwr\#
\end

screen( capsensitive("Floprd") )
Name           ØFloppy readÆ - liest einzelne Sektoren von einer
               Platteneinheit.

Xbiosnummer    8

Definition     int Floprd(void *buf, long filler, int devno,
                          int sectno, int trackno, int sideno,
                          int count);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Floprd liest einen oder mehrere Sek-
               toren von einer Platteneinheit. Der Inhalt der Sektoren
               wird in den durch buf adressierten Speicherbereich
               geladen. Der Parameter filler findet bei Computern ohne
               Blitter-TOS keinerlei Verwendung. Das jeweilige GerÑt
               wird unter devno angegeben. Mit dem Sektor sectno, der
               Spurnummer trackno, der Seite sideno wird der Start-
               punkt festgelegt, ab dem count Sektoren gelesen werden
               sollen.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAread\#, \#DMAwrite\#, \#Flopwr\#
\end

screen( capsensitive("Floprate") )
Name           ØFloppy rateÆ - liest oder setzt die seek rate eines
               Floppylaufwerks.

Xbiosnummer    41

Definition     int Floprate( int devno, int newrate );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Floprate liefert die augeblickliche
               seek rate, wenn fÅr newrate -1 Åbergeben wird. Sonst
               wird die seek rate auf den Wert in newrate gesetzt.
               GÅltige seek rate Werte sind:
               
               Wert   seek rate
               ----------------
               00      6 ms
               01     12 ms
               02      2 ms
               03      3 ms
               
               Es wird keine BereichsÅberprÅfung fÅr devno und 
               newrate vorgenommen.
Hinweis        Floprate wird erst ab TOS 1.4 unterstÅtzt
Ergebnis       Die Funktion liefert die seek rate als Ergebnis.
Querverweis    \#Flopwr\#, \#Floprd\#, \#Flopver\#, \#Flopfmt\#
\end

screen( capsensitive("Flopver") )
Name           ØFlop verififyÆ - ÅberprÅft Disketten.

Xbiosnummer    19

Definition     int Flopver(void *buf, long filler, int devno, int sect
no, int trackno, int sideno, int count);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Flopver untersucht einzelne Sektoren
               auf Disketten im Hinblick darauf, daû sie einwandfrei
               gelesen werden kînnen. Im Parameter buf wird ein 1024-
               Byte groûer Puffer zur Auflistung eventuell beschÑ-
               digter Sektoren zur VerfÅgung gestellt. Der Eintrag
               filler wird auûer im Blitter-TOS nicht verwendet.
               device enthÑlt die Nummer des entsprechenden Laufwerks.
               sectno, trackno und sideno geben Sektor, Spur und Seite
               an. Die Anzahl der Sektoren wird in count Åbergeben.
Ergebnis       Die Funktion liefert als Ergebnis 0, wenn alle angege-
               benen Sektoren lesbar sind, und einen von 0 verschiede-
               nen Fehlercode, wenn einzelne Sektoren nicht gelesen
               werden konnten.
\end

screen( capsensitive("Flopwr") )
Name           ØFloppy writeÆ - schreibt einzelne Sektoren auf eine
               Platteneinheit.

Xbiosnummer    9

Definition     int Flopwr(void *buf, long filler, int devno,
                          int sectno, int trackno, int sideno,
                          int count);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Flopwr schreibt einen oder mehrere
               Sektoren auf eine Platteneinheit. Der Inhalt der
               Sektoren wird durch den mit buf adressierten Speicher-
               bereich Åberschrieben. Der Parameter filler findet
               keinerlei Verwendung. Das jeweilige GerÑt wird unter
               devno angegeben. Mit dem Sektor sectno, der Spurnummer
               trackno, der Seite sideno wird der Startpunkt fest-
               gelegt, ab dem count Sektoren geschrieben werden sollen.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAread\#, \#DMAwrite\#, \#Floprd\#
\end

screen( capsensitive("Getrez") )
Name           Øget resolutionÆ - ermittelt die Auflîsung des Bild-
               schirms.

Xbiosnummer    4

Definition     int Getrez(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Getrez ermittelt die Auflîsung des
               Bildschirms.
Ergebnis       Die Funktion liefert als Ergebnis folgende Werte:
2              hohe Auflîsung
1              mittlere Auflîsung
0              niedrige Auflîsung
\end

screen( capsensitive("Gettime") )
Name           Øget timeÆ - Zeit ermitteln.

Xbiosnummer    23

Definition     unsigned long Gettime(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Gettime ermittelt Datum und Uhrzeit.
               Das 32-Bit-Ergebnis time wird wie folgt aufgesplittet:
Bit            Beschreibung
0-4            Sekunden in Einheiten von 2 (0-29)
5-10           Minuten (0-59)
11-15          Stunden (0-23)
16-20          Tag im Monat (1-31)
21-24          Monat (1-12)
25-31          Jahr (0-119, 0 steht fÅr 1980)
Ergebnis       Die Funktion liefert Datum und Uhrzeit als Ergebnis.
Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#
Querverweis    \#time\#   \#ctime\#   \#settime\#   \#gettime\#
\end

screen( capsensitive("Giaccess") )
Name           Øaccess GI sound chipÆ - ermîglicht den Zugriff auf die
               Register des GI-Sound-Chips.

Xbiosnummer    28

Definition     char Giaccess(int data, int regno);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Giaccess ermîglicht den Zugriff auf
               die Register des GI-Sound-Chips.
Ergebnis       Die Funktion liefert als Ergebnis den Inhalt des ange-
               gebenen Registers.
\end

screen( capsensitive("Ikbdws") )
Name           Øwrite string to keyboardÆ - programmiert den Tastatur-
               Chip.

Xbiosnummer    25

Definition     void Ikbdws(int count, void *ptr);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Ikbdws Åbergibt einen String, der
               unter ptr abgelegt wurde, an die intelligente Tastatur.
               Die LÑnge des Strings wird in count festgelegt.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Initmouse") )
Name           Øinitialize mouseÆ - initialisiert die Maus.

Xbiosnummer    0

Definition     void Initmouse( int type, \#MOUSE\# *par,
                               void (*mousevec)() );

Prototyp in    tos.h

Beschreibung   Initmouse ist eine \#XBIOS\#-Routine zur Low-Level-
               Initialisierung der Maus. Der Parameter type legt die
               Betriebsart der Maus fest:
0              Maus abschalten
1              Relativ-Modus
2              Absolut-Modus
3              reserviert
4              Tastatursteuerung
               Das Argument par enthÑlt die Adresse eines 14-Byte
               langen Parameter-Blocks. Die Bytes 0 bis 3 werden in
               allen Betriebsarten verwendet. Die Bytes von 4 bis 11
               werden nur dann verwendet, wenn die Maus im Absolut-
               Modus arbeiten soll.
0              Falls 0 Y-Achse oben 0, ansonsten unten 0
1              Parameter fÅr Maustasten festlegen
2              Parameter fÅr X-Achsen-Abgrenzung festlegen
3              Parameter fÅr Y-Achsen-Abgrenzung festlegen
4              Hîherwertiges Byte fÅr die X-Achse
5              Niederwertiges Byte fÅr die X-Achse
6              Hîherwertiges Byte fÅr die Y-Achse
7              Niederwertiges Byte fÅr die Y-Achse
8              Hîherwertiges Byte fÅr die X-Koordinate der
               Anfangsposition
9              Niederwertiges Byte fÅr die X-Koordinate der
               Anfangsposition
A              Hîherwertiges Byte fÅr die Y-Koordinate der
               Anfangsposition
B              Niederwertiges Byte fÅr die Y-Koordinate der
               Anfangsposition
               Unter addr erhÑlt man die Adresse des Interrupt-Vektors
               der Maus.
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#MOUSE\#
\end

screen( capsensitive("Iorec") )
Name           Øinput output recordÆ - Adresse des Ein-/Ausgabepuffers
               ermitteln.

Xbiosnummer    14

Definition     IOREC *Iorec( int dev );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Iorec liefert die Adresse des Ein-/
               Ausgabe-Puffers eines seriellen GerÑtes. Der Parameter
               dev kann folgende Werte annehmen:
0              RS-232
1              Tastatur
2              MIDI-Port
               Der resultierende Pointer zeigt auf folgende Struktur:
Ergebnis       Die Funktion liefert als Ergebnis einen Zeiger auf die
               Struktur \#IOREC\#.
Querverweis    \#IOREC\#   \#Bconmap\#
\end

screen( capsensitive("Jdisint") )
Name           Ødisable interruptÆ - Unterbrechungen des multi-
               funktionalen Peripheriebausteins sperren.

Xbiosnummer    26

Definition     void Jdisint (int number);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Jdisint sperrt eine bestimmte Art von
               Interrupt, die mit number angegeben wird, am Multi-
               funktionsperipheriebaustein. Der Parameter number
               bezieht sich auf folgende Interrupts:
number         Beschreibung
0              I/O-Port Bit 0 Busy par. Schnittstelle
1              RS-232 DCD
2              RS-232 CTS
3              Blitter
4              Timer D, RS232-232 Baud-Generator
5              Timer C, 200-Hz System-Uhr
6              Tastatur und MIDI
7              FDC und DMA
8              Timer B ZeilenrÅcklauf
9              RS-232 Sendefehler
10             RS-232 Sendepuffer leer
11             RS-232 Empfangspuffer voll
12             RS-232 Puffer voll
13             Timer A
14             RS-232 RI
15             Monochrom-Monitor Detect
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Jenabint\#   \#Mfpint\#
\end

screen( capsensitive("Jenabint") )
Name           Øenable interruptÆ - Unterbrechungen des multi-
               funktionalen Peripheriebausteins freigeben.

Xbiosnummer    27

Definition     void Jenabint (int number);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Jenabint gibt eine bestimmte Art von
               Interrupt, die mit number angegeben wird, am Multi-
               funktionsperipheriebaustein wieder frei. Der Parameter
               number bezieht sich auf folgende Interrupts:
number         Beschreibung
0              I/O-Port Bit 0 Busy par. Schnittstelle
1              RS-232 DCD
2              RS-232 CTS
3              Blitter
4              Timer D, RS232-232 Baud-Generator
5              Timer C, 200-Hz System-Uhr
6              Tastatur und MIDI
7              FDC und DMA
8              Timer B ZeilenrÅcklauf
9              RS-232 Sendefehler
10             RS-232 Sendepuffer leer
11             RS-232 Empfangspuffer voll
12             RS-232 Puffer voll
13             Timer A
14             RS-232 RI
15             Monochrom-Monitor Detect
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Jdisint\#   \#Mfpint\#
\end

screen( capsensitive("Kbdvbase") )
Name           Økeyboard vectorsÆ - liefert einen Zeiger auf die
               Tastatur-Interruptvektoren.

Xbiosnummer    34

Definition     \#KBDVBASE\# *Kbdvbase(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Kbdvbase liefert einen Zeiger auf
               eine \#KBDVBASE\# Struktur.
Querverweis    \#KBDVBASE\#
\end

screen( capsensitive("Bconmap") )
Name           ØSelect serial portÆ - wÑhlt eine Default-Schnittstelle 
               aus.

Xbiosnummer    44

Definition     long  Bconmap( int devno );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Bconmap wÑhlt eine der seriellen 
               Schnittstellen fÅr die Biosausgabe aus. devno kann dabei 
               folgende Werte annehmen:
               -1        keine énderung,
                6        ST-kompatibler RS232-Port,
                7        SCC Kanal B,
                8        TTMFP RS232-Port,
                9        SCC Kanal A,
               >10       eigene Treiber.
Hinweis        Diese Funktion ist nur im TOS030 des TT vefÅgbar.
Ergebnis       Bconmap liefert die alte Einstellung. Falls devno gleich
               -2 ist liefert die Funktion einen Zeiger auf \#BCONMAP\#
               zurÅck. Wird die Funktion auf einem ST verwendet, liefert 
               sie die Konstante 44 zurÅck.
Querverweis:   \#BCONMAP\#, \#Bconout\#, \#Bconin\#, \#Bcostat\#, \#Bconstat\#, 
               \#Iorec\#, \#Rsconf\#
\end

screen( capsensitive("Kbrate") )
Name           Økeyboard rateÆ - legt die Autorepeat-Rate der Tastatur
               fest.

Xbiosnummer    35

Definition     int Kbrate (int initial, int repeat);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Kbrate ermittelt oder Ñndert die
               aktuelle Auto-Repeat-Geschwindigkeit der Tastatur.
               Die Geschwindigkeit wird als Vielfaches der System-
               einheit von 20 Millisekunden festgelegt. initial legt
               die Zeitdauer fest, nach der Auto-Repeat-Modus
               einsetzen soll, repeat bestimmt die Pausen zwischen
               einer Wiederholung. Wenn beide Parameter mit -1 Åber-
               geben wurden, dann wird die aktuelle Einstellung
               gelesen.
Ergebnis       Die Funktion liefert als Ergebnis die Einstellung des
               Auto-Repeat-Modus.
\end

screen( capsensitive("Keytbl") )
Name           Økey tableÆ - definiert die Umsetzungstabelle der
               Tastatur von Scan-Codes in Tastatur-Codes.

Xbiosnummer    16

Definition     \#KEYTAB\# *Keytbl( void *unshift, void *shift,
                               void *capslock );

Prototyp in    tos.h

Beschreibung   Keytbl ist eine \#XBIOS\#-Funktion mit deren Hilfe eine
               neue Tastatur-Tabelle fÅr die Umsetzung von Scan-Codes
               in Tastatur-Codes vorgenommen werden kann. Beim
               Atari ST erzeugt jeder Tastendruck einen Scan-Code.
               Dabei kînnen bei jeder Taste drei verschiedene Scan-
               Codes herauskommen, je nachdem, ob die Shift-Taste ge-
               drÅckt ist oder ob die Capslock-Taste eingeschaltet
               ist. Dieser Scan-Code wird anschlieûend mit Hilfe einer
               128 Byte langen Tabelle in einen ASCII-Code umgewandelt.
Ergebnis       Die Funktion liefert als Ergebnis einen Zeiger auf die
               Struktur \#KEYTAB\#.
Querverweis    \#Bioskeys\#
\end

screen( capsensitive("Logbase") )
Name           Ølogical screen RAM baseÆ - ermittelt die logische
               Anfangsadresse des Videospeichers.

Xbiosnummer    3

Definition     void *Logbase(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Logbase ermittelt die logische
               Anfangsadresse des momentan als Videospeicher
               verwendeten RAM-Bereichs.
Ergebnis       Die Funktion liefert als Ergebnis die Anfangsadresse
               des logischen Bildschirmspeichers.
Querverweis    \#Physbase\#   \#Setscreen\#
\end

screen( capsensitive("Mfpint") )
Name           Øinit MFP interruptÆ - Interrupt initialisieren.

Xbiosnummer    13

Definition     void Mfpint( int number, void (*vector)() );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Mfpint initialisiert den Multi-
               funktions-Interrupt fÅr die angeschlossenen Peripherie-
               GerÑte. Damit kînnen Hardware-Interrupts abgefangen
               werden. Das Argument vektor gibt die Interrupt-Service-
               Routine an. Im Parameter interrupt wird die Nummer des
               Interrupt von 0 bis 15 angegeben:
number         Beschreibung
0              I/O-Port Bit 0 Busy par. Schnittstelle
1              RS-232 DCD
2              RS-232 CTS
3              Blitter
4              Timer D, RS232-232 Baud-Generator
5              Timer C, 200-Hz System-Uhr
6              Tastatur und MIDI
7              FDC und DMA
8              Timer B ZeilenrÅcklauf
9              RS-232 Sendefehler
10             RS-232 Sendepuffer leer
11             RS-232 Empfangspuffer voll
12             RS-232 Puffer voll
13             Timer A
14             RS-232 RI
15             Monochrom-Monitor Detect
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Jdisint\#   \#Jenabint\#
\end

screen( capsensitive("Midiws") )
Name           ØMidi write stringÆ - gibt eine Zeichenfolge Åber die
               Midi-Schnittstelle aus.

Xbiosnummer    12

Definition     void Midiws (int cnt, void *ptr) ;

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Midiws gibt einen String Åber die
               Midi-Schnittstelle aus. Der Parameter cnt enthÑlt die
               Anzahl der Zeichen - 1 und ptr enthÑlt die Adresse des
               Strings.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Offgibit") )
Name           ØGI bit offÆ - lîscht ein Bit im Register A des
               Soundchips.

Xbiosnummer    29

Definition     void           Offgibit (int bitno);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Offgibit lîscht ein Bit im Register
               A des Soundchips GI. bitno gibt den Wert an, mit dem das
               Register verUNDet werden soll.
               
               Die Bits in diesem Register haben folgende Bedeutung:
               Bit            Beschreibung
               0              Floppy Sideselect
               1              Drive Select A
               2              Drive Select B
               3              RS-232 RTS
               4              RS-232 DTR
               5              Centronics Strobe
               6              PIN 3 Monitor Buchse
               7              unbenutzt 
                              ab TOS030 des TT jedoch 
                              Modem 4 (1) oder LAN (0).

Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Ongibit\#
\end

screen( capsensitive("Ongibit") )
Name           ØGI bit onÆ - setzt ein Bit im Register A des
               Soundchips.

Xbiosnummer    30

Definition     void Ongibit (int bitno);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Ongibit setzt ein Bit im Register A
               des Soundchips GI. bitno gibt den Wert an, mit dem das
               Register verODERt  werden soll.
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Offgibit\#
\end

screen( capsensitive("Physbase") )
Name           Øphysical screen ram baseÆ - ermittelt die Anfangs-
               adresse des Video-Speichers.

Xbiosnummer    2

Definition     void *Physbase(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Physbase ermittelt die physikalische
               Anfangsadresse des momentan als Videospeicher ver-
               wendeten RAM-Bereichs.
Ergebnis       Die Funktion Physbase liefert als Ergebnis die Adresse
               des physikalischen Bildschirmspeichers.
Querverweis    \#Logbase\#   \#Setscreen\#
\end

screen( capsensitive("Protobt") )
Name           Øprototype boot sectorÆ - Standard-Boot-Sektor.

Xbiosnummer    18

Definition     void Protobt( void *buf, long serialno, int disktype,
                             int execflag );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Protobt legt einen Boot-Sektor auf
               einer Diskette an. Das Argument buf verweist auf einen
               512 Byte groûen Puffer mit dem Inhalt des Boot-Sektors.
               Der Parameter serialno dient dazu, eine Seriennummer im
               Bootsektor abzuspeichern. Wenn die Variable serialno
               grîûer als 0x01000000 ist, dann wird eine Zufallszahl
               abgelegt. Mit disktype wird eine der folgenden
               Diskettenarten ausgewÑhlt:
0              40 Spuren, einseitig
1              40 Spuren, doppelseitig
2              80 Spuren, einseitig
3              80 Spuren, doppelseitig
               Der Parameter execflag legt schlieûlich fest, ob die
               Informationen im Boot-Sektor als Programm ausgefÅhrt
               werden kînnen.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Prtblk") )
Name           Øprint screen dumpÆ - Hardcopy-Ausdruck.

Xbiosnummer    36

Definition     void Prtblk( \#PBDEF\# *par );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Prtblk druckt einen bestimmten
               Bereich im Speicher aus. Der Zeiger par wird die
               Struktur des Bildschirmaufbaus angegeben.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Ausdruck erfolgreich war, ansonsten einen von 0
               verschiedenen Wert.
\end

screen( capsensitive("Puntaes") )
Name           Øpunt AESÆ - AES abschalten.

Xbiosnummer    39

Definition     void Puntaes(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Puntaes schaltet das AES-Betriebs-
               system ab. Diese Funktion darf nicht verwendet werden,
               wenn sich das AES im ROM befindet.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Random") )
Name           Ørandom generatorÆ - Zufallsgenerator.

Xbiosnummer    17

Definition     long Random ( void ) ;

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Random liefert eine 24-Bit-Zufalls-
               zahl. Sie basiert auf einem Zeitgeber im Atari ST. Die
               Funktion liefert nach dem Einschalten immer ver-
               schiedene Werte.
Ergebnis       Die Funktion liefert als Ergebnis eine 24-Bit-Zufalls-
               zahl.
\end

screen( capsensitive("Rsconf") )
Name           ØRS-232 configurationÆ - konfiguriert die RS-232-
               Schnittstelle.

Xbiosnummer    15

Definition     long  Rsconf( int baud, int ctr, int ucr, int rsr,
                               int tsr, int scr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine konfiguriert die serielle Schnitt-
               stelle. Im Normal-Betrieb werden nur die Parameter baud
               und ctr verwendet, wobei die anderen Parameter alle mit
               -1 Åbergeben werden mÅssen. Der Parameter baud kann
               folgende Werte annehmen:
Wert           Baudrate
0              19200
1               9600
2               4800
3               3600
4               2400
5               2000
6               1800
7               1200
8                600
9                300
10               200
11               150
12               134
13               110
14                75
15                50
(ab TOS 1.4: wird fÅr baud -2 angegeben, wird der Rest ignoriert
 und als Ergebnis die letzte mir Rsconf eingestellte Baudrate
 zurÅckgegeben)
               Der Parameter ctr legt den Handshake fest:
Bit            Beschreibung
0              Kein Handshake
1              XON/XOFF
2              RTS/CTS
3              XON/XOFF und RTS/CTS
               Mit ucr wird das USART Steuer-Register belegt:
Bit            Beschreibung
0              unbenutzt
1              0 ungerade, 1 gerade ParitÑt
2              0 keine ParitÑt, 1 mit ParitÑt
3,4            Start-/Stop-Bits, sowie deren Format:
               00             synchron   Start=0, Stop =0
               10             asynchron  Start=1, Stop =1
               01             asynchron  Start=1, Stop =1,5
               11             asynchron  Start=1, Stop =2
5,6            WortlÑnge:
               00             8 Bit
               10             7 Bit
               01             6 Bit
               11             5 Bit
7              Baudrate aus der öbertragungssteuerung
               Im Parameter rsr sind die Status-Bits des Empfangs-
               status-Registers enthalten.:
Bit            Beschreibung
0              Empfang einschalten
1              Vergleich mit Synchron-Register einschalten
2              Im Synchron-Betrieb wird angezeigt, daû das
               empfangene Zeichen identisch mit dem Zeichen
               im Synchron-Register ist. Im asynchronen Modus
               wird der Empfang eines Start-Bits signalisiert.
3              Im Synchron-Betrieb wird angezeigt, daû das
               empfangene Zeichen identisch mit dem Zeichen
               im Synchron-Register ist. Im asynchronen Modus
               wird der Empfang eines BREAK-Zeichens signalisiert.
4              öbertragungsfehler, denn das Stop-Bit ist 0,
               wÑhrend das Zeichen nicht NUL ist.
5              ParitÑtsfehler
6              Puffer-öberlauf
7              Puffer voll
               tsr steuert das Transmitter-Status-Registers. Die
               einzelnen Bits haben folgende Bedeutung:
Bit            Beschreibung
0              Senden einschalten
1,2            Ausgabe-Modus (high oder low)
               00             Hochohmig
               01             High-Pegel
               10             Low-Pegel
               11             Loop-back
3              Im synchronen Betriebsmodus wird das Bit nicht
               verwendet, im asynchronen Betrieb sendet es
               das Signal BREAK.
4              Ende der öbertragung (end of transmission)
               anzeigen
5              Nach der nÑchsten öbertragung sofort auf Empfang
               umschalten
6              Zeichen im öbertragungspuffer versenden, bevor
               das neue Zeichen in den öbertragungspuffer
               geschrieben wird.
7              Puffer leer
               scr initialisiert das synchrone Zeichen-Register.
               Dieser Parameter sollte auf 0 gesetzt werden.

Ergebnis       Es werden die altern Registerwerte von ucr, rsr,
               tsr und scr zurÅckgegeben.

Querverweis    \#Bconmap\#
\end

screen( capsensitive("Scrdmp") )
Name           Øscreen dumpÆ - druckt den Bildschirminhalt aus.

Xbiosnummer    20

Definition     void  Scrdmp( void );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Scrdmp druckt den Inhalt des Bild-
               schirms als Hardcopy aus. Bei der Verwendung dieser
               Funktion muû ein Drucker angeschlossen sein.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Setcolor") )
Name           ØSetcolorÆ - legt eine von 16 Farben fest.

Xbiosnummer    7

Definition     int  Setcolor( int colornum, int color );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setcolor legt die Farbe einer von 16
               Farbauswahlmîglichkeiten fest.

Ergebnis       Die Funktion liefert den bisherigen Wert des Farb-
               registers.

Querverweis    \#Setpalette\#
\end

screen( capsensitive("Setpalette") )
Name           Øset paletteÆ - wÑhlt 16 Farben aus.

Xbiosnummer    6

Definition     void  Setpalette( void *pallptr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setpalette wÑhlt 16 Farben mit Hilfe
               einer Bit-Ebenen-Definition aus. Der Parameter pallptr
               zeigt auf ein Feld mit 16 Integer-Werten, in denen die
               einzelnen Farben definiert werden.

Ergebnis       Die Funktion liefert keinen Wert.
\end

screen( capsensitive("Setprt") )
Name           ØSetprinterÆ - initialisiert den Drucker.

Xbiosnummer    33

Definition     int  Setprt( int config );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setprt initialisiert den Drucker.
               Folgende Bit-Parameter kînnen in config angegeben
               werden:

                    0x01           Typenraddrucker
                    0x02           Monochrom-Drucker
                    0x04           1 Epson-Drucker, 0 Atari-Drucker
                    0x08           1 Schînschrift, 0 Konzept-Schrift
                    0x10           1 serielle Schnittstelle,
                                   0 parallele Schnittstelle
                    0x20           1 Einzelblatt, 0 Endlospapier

               Bei config = -1 wird die aktuelle Konfiguration
               zurÅckgegeben.

Ergebnis       Die Funktion liefert als Ergebnis die alte
               Konfiguration.
\end

screen( capsensitive("Setscreen") )
Name           Øset screenÆ - initialisiert den Bildschirm.

Xbiosnummer    5

Definition     void  Setscreen( void *laddr, void *paddr, int rez );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setscreen initialisiert den Bild-
               schirm. Die Parameter laddr und paddr legen die
               Anfangsadresse des Bildschirmspeichers und rez die
               Auflîsung des Bildschirms fest. rez kann folgende
               Werte erhalten:

                        0              niedrige Auflîsung
                        1              mittlere Auflîsung
                        2              hohe Auflîsung

               Wird fÅr einen der Parameter der Wert -1 Åbergeben,
               so wird der entsprechende aktuelle Einstellung
               beibehalten.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Physbase\#   \#Logbase\#   \#Getrez\#
\end

screen( capsensitive("Settime") )
Name           Øset timeÆ - Zeit einstellen.

Xbiosnummer    22

Definition     void  Settime( unsigned long time );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Settime stellt Datum und Uhrzeit neu
               ein. Der 32-Bit Parameter time wird wie folgt
               aufgesplittet:

                  0-4        Sekunden in Einheiten von 2 (0-29)
                  5-8        Minuten (0-59)
                  9-15       Stunden (0-23)
                  16-20      Tag im Monat (1-31)
                  21-26      Monat (1-12)
                  27-31      Jahr (0-119, 0 steht fÅr 1980)

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Ssbrk") )
Name           Øset memory break pointÆ - Speicherplatz reservieren.

Xbiosnummer    1

Definition     void  *Ssbrk( int count );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Ssbrk reserviert Speicherplatz. Die
               Anzahl der Bytes muû dabei in count Åbergeben werden.
               Diese Funktion muû vor der Initialisierung des
               Betriebssystems aufgerufen werden, und sollte daher in
               Anwenderprogrammen nicht verwendet werden. In allen
               Atari-ROM-Versionen ist diese Funktion lediglich als
               ØDummyÆ-Routine implementiert.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Supexec") )
Name           Øsupervisor executeÆ - fÅhrt Routine im Supervisor-
               Modus aus.

Xbiosnummer    38

Definition     void  Supexec( long (*func)( ));

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Supexec fÅhrt die Routine unter addr
               im Supervisor-Modus aus.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Vsync") )
Name           Øvertical syncÆ - wartet auf das nÑchste vertikale
               Sync-Signal.

Xbiosnummer    37

Definition     void  Vsync( void );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Vsync wartet auf den nÑchsten
               Bildschirm-Refresh, damit lassen sich Bildschirm-
               operationen mit dem Betriebssystem synchronisieren.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("EsetShift") )
Name           ØSet shift mode registerÆ - Setzt das Shift Mode Register.

Xbiosnummer    80

Definition     int  Esetshift( int shftMode );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetShift schreibt in das Shift 
               Mode Register des TT den Wert shftMode. shftMode
               ist ein Bitfeld mit folgender Bedeutung:
               
               |S|00|H|0|MMM|0000|BBBB| 
                |    |    |         |
                |    |    |         +-- Bank                  \#EsetBank\#
                |    |    +------------ Auflîsung             \#Setscreen\#
                |    |                    000  320 * 200 * 4
                |    |                    001  640 * 200 * 2
                |    |                    010  640 * 400 * 1
                |    |                    100  640 * 480 * 4
                |    |                    110 1280 * 960 * 1
                |    |                    111  320 * 480 * 8
                |    +----------------- Hyper Mode            \#EsetGray\#
                +---------------------- Sample & Hold

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert den vorherigen Wert des 
               Registers.

Querverweis    \#EgetShift\#
\end

screen( capsensitive("EgetShift") )
Name           ØGet current shift mode valueÆ - Liest das Shift
               Mode Register.

Xbiosnummer    81

Definition     int  EgetShift( void );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine  EgetShift liest das Shift
               Mode Register aus und liefert den Inhalt des Regis-
               ters als Ergebnis zurÅck.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert den Wert des Registers.

Querverweis    \#EsetShift\#
\end

screen( capsensitive("EsetBank") )
Name           ØSet color look up bankÆ - Setzt Bank fÅr Farbtabelle.

Xbiosnummer    82

Definition     int  EsetBank( int bankNum );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetBank setzt die Banknummer
               fÅr die Farbtabelle des TT auf den Wert bankNum.
               Der erlaubte Wert von bankNum liegt zwischen 0
               und 15. Ist bankNum negativ, wird die aktuelle 
               Einstellung nicht verÑndert.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert die vorherige Einstellung.
\end

screen( capsensitive("EsetColor") )
Name           ØSet color entryÆ - Schreibt einen Eintrag in die
               Farbtabelle.

Xbiosnummer    83

Definition     int  EsetColor( int colorNum, int color );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetColor setzt den Farbeintrag
               colorNum in der Farbtabelle auf den  Wert color.
               Ein negativer Wert verÑndert den Eintag nicht.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert die vorherige Einstellung.

Querverweis    \#Setcolor\#
\end

screen( capsensitive("EsetPalette") )
Name           ØSet palette registersÆ - Setzt mehrere EintrÑge in
               der Farbtabelle.

Xbiosnummer    84

Definition     void  EsetPalette( int colorNum, int count,
                                   int *palettePtr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetPalette setzt count Farbein-
               trÑge ab colorNum in der Farbtabelle auf die Werte
               im Array palettePtr.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion hat kein Ergebnis.

Querverweis    \#EgetPalette\#
\end

screen( capsensitive("EgetPalette") )
Name           ØGet look up table registersÆ - Liest mehrere EintrÑge
               aus der Farbtabelle.

Xbiosnummer    85

Definition     void  EgetPalette( int colorNum, int count,
                                   int *palettePtr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EgetPalette liest count Farbein-
               trÑge ab colorNum aus der Farbtabelle in das Array 
               palettePtr

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion hat kein Ergebnis.

Querverweis    \#EsetPalette\#
\end

screen( capsensitive("EsetGray") )
Name           ØSet/clear gray modeÆ - Schaltet die Farbinterpretation
               ein bzw. aus.

Xbiosnummer    86

Definition     int  EsetGray( int swtch );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetGray schaltet die Farbinter-
               pretation in der Farbtabelle als Graustufe ein (1)
               bzw. aus (0). Ein negativer Wert verÑndert die Ein-
               stellung nicht.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert die bisherige Einstellung.
\end

screen( capsensitive("EsetSmear") )
Name           ØSet/clear video smear modeÆ - Schaltet die Farb-
               verwischung ein bzw. aus.

Xbiosnummer    87

Definition     int  EsetSmear( int swtch );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetSmear schaltet die Farbver-
               wischung ein (1) bzw. aus (0).  Ein negativer Wert
               verÑndert die Einstellung nicht.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert die bisherige Einstellung.
\end

screen( capsensitive("Xbtimer") )
Name           Øtimer initÆ - initialisiert die Zeitgeber im MFP-Chip.

Xbiosnummer    31

Definition     void  Xbtimer( int timer, int control, int data,
                                void (*vector)( ));

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Xbtimer initialisiert einen von vier
               Zeitgebern (A-D) im Multifunktionsperipheriechip 68901.
               Die Zeitgeber, die mit Hilfe des Parameters timer
               ausgewÑhlt werden, haben folgende Aufgaben:

                         A              Applikationen
                         B              Grafik
                         C              Systemzeit
                         D              Baudrate

               Der Parameter data enthÑlt den Wert, der in das Timer-
               Register geladen werden soll. vektor verweist auf den
               neuen Interrupt-Handler. control lÑdt das Steuer-
               Register des Zeitgebers.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( "GEMDOS" )
GEMDOS
----------------------------------------------------------------------

Das GEMDOS ist, abgesehen von den hardware-abhÑngigen \#BIOS\# und \#XBIOS\#,
das eigentliche Betriebssystem des Atari. Seine Funktionen werden Åber
den 680X0-Trap #1 aufgerufen.
Die \#Betriebssystem\#funktionen lassen sich sehr leicht aufgrund des
ersten Buchstabens des Funktionsnamen in die Kategorien

            \#Zeichenweise Ein-/Ausgabe\#  (C...),
            \#ProgrammausfÅhrung\#         (P...),
            \#Dateifunktionen\#            (F...),
            \#Verzeichnisfunktionen\#      (D...),
            \#Speicherbereichsverwaltung\# (M...),
            \#Datum und Uhrzeit\#          (T...),
und         \#Systemfunktionen\#           (S...)

einteilen.
In einem Netzwerk stehen noch zusÑtzliche \#Netzwerkfunktionen\#
zur VerfÅgung.
\end

screen( "Zeichenweise Ein-/Ausgabe" )
Zeichenweise Ein-/Ausgabe
----------------------------------------------------------------------

Zu allen Ein-/Ausgabe-Funktionen auf die StandardgerÑte CON: (Tastatur
und Bildschirm), PRN: (Drucker an der parallelen Schnittstelle)  und
AUX: (GerÑte an der seriellen Schnittstelle) stehen auch die ent-
sprechenden Statusfunktionen zur VerfÅgung.

1  \#Cconin\#  Zeichen von StandardeingabegerÑt einlesen.
2  \#Cconout\# Zeichen auf StandardausgabegerÑt schreiben.
3  \#Cauxin\#  Zeichen von serieller Schnittstelle lesen.
4  \#Cauxout\# Zeichen auf serielle Schnittstelle schreiben.
5  \#Cprnout\# Zeichen auf Drucker ausgeben.
6  \#Crawio\#  Zeichen direkt von Tastatur lesen oder auf Bildschirm
           ausgeben.
7  \#Crawcin\# Zeichen ohne Darstellung am Bildschirm und ohne
           Interpretation von Steuerzeichen einlesen.
8  \#Cnecin\#  Zeichen ohne Darstellung am Bildschirm einlesen.
9  \#Cconws\#  String auf StandardausgabegerÑt ausgeben.
10 \#Cconrs\#  String von StandardeingabegerÑt einlesen.
11 \#Cconis\#  Tastatur-Puffer nach anliegenden Zeichen abfragen.
16 \#Cconos\#  Ausgabe-Status des StandardausgabegerÑts ÅberprÅfen.
17 \#Cprnos\#  Drucker-Status ermitteln.
18 \#Cauxis\#  Eingabe-Status der seriellen Schnittstelle ermitteln.
19 \#Cauxos\#  Ausgabe-Status der seriellen Schnittstelle ermitteln.

Die Ausgaberoutinen des Gemdos emulieren ein \#VT-52-Terminal\#.
\end

screen( "ProgrammausfÅhrung" )
ProgrammausfÅhrung
----------------------------------------------------------------------

Programme laden und ausfÅhren oder beenden.

0  \#Pterm0\#   Programm beenden und 0 an Aufrufer zurÅckgeben.
49 \#Ptermres\# Programm beenden, aber im Speicher behalten.
75 \#Pexec\#    Weiteres Programm laden und ausfÅhren.
76 \#Pterm\#    Programm beenden und frei wÑhlbaren Wert an Aufrufer
            zurÅckgeben.
\end

screen( "Dateifunktionen" )
Ein-/Ausgabefunktionen fÅr Dateien, Zugriff auf Dateien
----------------------------------------------------------------------


26  \#Fsetdta\#   DiskettenÅbertragungsadresse Ñndern.
47  \#Fgetdta\#   DiskettenÅbertragungsadresse ermitteln.
60  \#Fcreate\#   Datei anlegen.
61  \#Fopen\#     Datei îffnen.
62  \#Fclose\#    Datei schlieûen.
63  \#Fread\#     Aus Datei lesen.
64  \#Fwrite\#    In Datei schreiben.
65  \#Fdelete\#   Datei lîschen.
66  \#Fseek\#     Zeiger auf bestimmte Position innerhalb einer Datei setzen.
67  \#Fattrib\#   Dateiattribute Ñndern oder ermitteln.
69  \#Fdup\#      Dateihandle duplizieren.
70  \#Fforce\#    Umlenken von Ein-/Ausgaben von StandardkanÑlen auf belie-
              bige andere.
78  \#Fsfirst\#   Ersten Eintrag in Verzeichnis suchen.
79  \#Fsnext\#    NÑchsten Eintrag in Verzeichnis suchen.
86  \#Frename\#   Datei umbenennen.
87  \#Fdatime\#   énderungsdatum einer Datei ermitteln oder Ñndern.
\end

screen( "Netzwerkfunktionen" )
Netzwerkfunktionen
----------------------------------------------------------------------

Zusatzfunktionen fÅr Netzwerkbetrieb.

92  \#Flock\#     File Record im Netzwerk sperren oder freigeben.
\end

screen( "Verzeichnisfunktionen" )
Verzeichnisfunktionen
----------------------------------------------------------------------

Dateiverzeichnisse und Laufwerke verwalten.

14 \#Dsetdrv\#  Aktuelles Laufwerk Ñndern.
25 \#Dgetdrv\#  Aktuelles Laufwerk ermitteln.
54 \#Dfree\#    Freie und GesamtkapazitÑt eines Laufwerks ermitteln.
57 \#Dcreate\#  Verzeichnis anlegen.
58 \#Ddelete\#  Verzeichnis lîschen.
59 \#Dsetpath\# Aktuelles Verzeichnis Ñndern.
71 \#Dgetpath\# Aktuelles Verzeichnis ermitteln.
\end

screen( "Speicherbereichsverwaltung" )
Speicherbereichsverwaltung
----------------------------------------------------------------------

Speicherbereiche reservieren, anpassen und freigeben.

72 \#Malloc\#  Speicherbereich reservieren bzw. freien Speicherplatz
           erfragen.
73 \#Mfree\#   Speicherbereich freigeben.
74 \#Mshrink\# Reservierten Speicherbereich verkleinern.


Ab TOS030 (Atari TT) verfÅgbar:

20 \#Maddalt\# Alternativen Speicher anmelden.
68 \#Mxalloc\# Speicherbereich reservieren.
\end

screen( "Datum und Uhrzeit (GEMDOS)" )
Datum und Uhrzeit im GEMDOS
----------------------------------------------------------------------

Datum und Uhrzeit einstellen oder ermitteln.

42 \#Tgetdate\# Datum ermitteln
43 \#Tsetdate\# Datum einstellen.
44 \#Tgettime\# Uhrzeit ermitteln.
45 \#Tsettime\# Uhrzeit einstellen.
\end

screen( "Systemfunktionen" )
Systemfunktionen
----------------------------------------------------------------------

Die Supervisor-Funktion ist eine der wichtigsten Funktionen fÅr die
direkte Programmierung der Hardware. Nur mit ihrer Hilfe ist es
mîglich, auf die Systemvariablen zuzugreifen.

32 \#Super\#    Supervisormodus ermitteln oder Ñndern.
48 \#Sversion\# Versionsnummer von GEM ermitteln.
\end

screen( capsensitive("gemdos") )
Name           ØgemdosÆ - GEMDOS-Trap ausfÅhren.

Definition     long  gemdos( void, ... );

Prototyp in    tos.h

Beschreibung   Die Routine gemdos fÅhrt einen TRAP 1 durch. Die
               Åbergebenen Parameter hÑngen von der jeweiligen GEMDOS-
               Funktion ab.

Ergebnis       Die Funktion liefert als Ergebnis einen Wert vom
               Datentyp long.

Querverweis    Bibliotheksfunktionen: \#bios\#   \#xbios\#
               Betriebssystem: \link("GEMDOS")Gemdos\#
\end

screen( capsensitive("Cauxin") )
Name           Øcharacter auxiliary inputÆ - Eingabe Åber serielle
               Schnittstelle.

Gemdosnummer   3

Definition     int  Cauxin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxin liest ein Zeichen von der
               seriellen Schnittstelle aux: ein. Die Funktion wartet
               solange, bis ein Zeichen eingegeben wurde.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cauxout\#
\end

screen( capsensitive("Cauxis") )
Name           Øcharacter auxiliary input statusÆ - ÅberprÅft den Ein-
               gabestatus der seriellen Schnittstelle.

Gemdosnummer   18

Definition     int  Cauxis( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxis ÅberprÅft den Status der
               seriellen Schnittstelle aux: dahingehend, ob Zeichen
               im Eingabepuffer vorliegen.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn Zeichen im
               Puffer stehen, ansonsten ein 0.

Querverweis    \#Cauxos\#
\end

screen( capsensitive("Cauxos") )
Name           Øcharacter auxiliary output statusÆ - ÅberprÅft den
               Ausgabestatus der seriellen Schnittstelle.

Gemdosnummer   19

Definition     int  Cauxos( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxos ÅberprÅft den Status der
               seriellen Schnittstelle aux: dahingehend, ob Zeichen
               Åber die serielle Schnittstelle ausgegeben werden
               kînnen.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn die serielle
               Schnittstelle zum Senden bereit ist, ansonsten ein 0.

Querverweis    \#Cauxis\#
\end

screen( capsensitive("Cauxout") )
Name           Øcharacter auxiliary outputÆ - schreibt ein Zeichen auf
               die serielle Schnittstelle.

Gemdosnummer   4

Definition     void  Cauxout( int c );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxout schreibt ein Zeichen auf die
               serielle Schnittstelle aux.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Cauxin\#
\end

screen( capsensitive("Cconin") )
Name           Øcharacter console inputÆ - liest ein Zeichen vom
               StandardeingabegerÑt.

Gemdosnummer   1

Definition     long  Cconin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconin liest ein Zeichen vom Stand-
               ardeingabegerÑt. Als StandardeingabegerÑt dient in der
               Regel die Tastatur.

Ergebnis       Die Funktion liefert als Ergebnis den ASCII-Code des
               Zeichens im niederwertigen Wort. Wenn das eingelesene
               Zeichen von der Tastatur kommt, beinhalten die unteren
               acht Bits des hîherwertigen Worts den Scancode der
               Tastatur.

Querverweis    \#Cconout\#   \#Cconis\#
\end

screen( capsensitive("Cconis") )
Name           Øcharacter console is waitingÆ - prÅft nach, ob ein
               Zeichen im Standardeingabepuffer vorliegt.

Gemdosnummer   11

Definition     int  Cconis( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconis ÅberprÅft, ob Zeichen im
               Standardeingabe-Puffer vorliegen.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn Zeichen im
               Puffer vorliegen, ansonsten eine 0.

Querverweis    \#Cconin\#
\end

screen( capsensitive("Cconout") )
Name           Øcharacter console outputÆ - schreibt ein Zeichen auf
               das StandardausgabegerÑt.

Gemdosnummer   2

Definition     void  Cconout( int c );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconout schreibt das Zeichen c auf
               das StandardausgabegerÑt. Als StandardausgabegerÑt
               dient in der Regel der Bildschirm.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Cconin\#, \#Cconos\#, \#VT-52-Terminal\#
\end

screen( capsensitive("Cconos") )
Name           Øcharacter console output statusÆ - prÅft den Status
               des StandardausgabegerÑtes.

Gemdosnummer   16

Definition     int  Cconos( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconos ÅberprÅft, ob das Standard-

               ausgabegerÑt bereit ist, Zeichen anzunehmen.
Ergebnis       Die Funktion liefert als Ergebnis den Status des
               StandardausgabegerÑts. Wenn das StandardausgabegerÑt
               bereit ist Zeichen auszugeben, wird -1 zurÅckgegeben,
               ansonsten eine 0.

Querverweis    \#Cconout\#
\end

screen( capsensitive("Cconrs") )
Name           Øcharacter console read stringÆ - liest einen String
               von der Standardeingabe.

Gemdosnummer   10

Definition     void  Cconrs( \#LINE\# *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconrs liest einen String von der
               Standardeingabe. WÑhrend der Eingabe kann der String
               editiert werden. Das erste Zeichen im Puffer buf
               enthÑlt die maximale LÑnge des Strings, die im Puffer
               belegt werden kann, damit die Eingaben aufgenommen
               werden kînnen. Das zweite Zeichen des Puffers enthÑlt
               nach Abschluû der Routine die tatsÑchliche LÑnge der
               Eingabe. Diese Struktur ist als Datentyp \#LINE\# in TOS.H
               deklariert.

Ergebnis       Die Funktion hat kein Ergebnis.

Querverweis    \#Cconws\#   \#LINE\#
\end

screen( capsensitive("Cconws") )
Name           Øcharacter console write stringÆ - schreibt einen
               String auf das StandardausgabegerÑt.

Gemdosnummer   9

Definition     int  Cconws( const char *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconws schreibt einen String auf das
               StandardausgabegerÑt. Der String in buf muû mit dem
               ASCII-Zeichen Null beendet werden.

Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der
               tatsÑchlich ausgegebenen Zeichen.

Querverweis    \#Cconrs\#, \#VT-52-Terminal\#
\end

screen( capsensitive("Cnecin") )
Name           Øcharacter no echo inputÆ - liest ein Zeichen vom
               StandardeingabegerÑt.

Gemdosnummer   8

Definition     long  Cnecin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cnecin liest ein Zeichen direkt von
               der Standardeingabe, ohne daû das Zeichen auf dem
               StandardausgabegerÑt ausgegeben wird.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cconin\#   \#Crawcin\#   \#Crawio\#
\end

screen( capsensitive("Cprnos") )
Name           Øcharacter printer output statusÆ - prÅft den Status
               der Druckerschnittstelle.

Gemdosnummer   17

Definition     int  Cprnos( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cprnos ÅberprÅft, ob die Drucker-
               schnittstelle bereit ist, Zeichen anzunehmen.

Ergebnis       Die Funktion liefert als Ergebnis den Drucker-Status.
               Wenn der Drucker bereit ist, wird ein Wert ungleich 0
               zurÅckgegeben, ansonsten eine 0.

Querverweis    \#Cconos\#
\end

screen( capsensitive("Cprnout") )
Name           Øcharacter printer outputÆ - schreibt ein Zeichen auf
               die Druckerschnittstelle.

Gemdosnummer   5

Definition     int  Cprnout( int c );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cprnout schreibt das Zeichen c auf
               die Druckerschnittstelle prn:.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn das Zeichen
               korrekt ausgedruckt werden konnte. Im Fehlerfall wird 0
               zurÅckgegeben.

Querverweis    \#Cprnos\#
\end

screen( capsensitive("Crawcin") )
Name           Øcharacter raw inputÆ - liest ein Zeichen ungepuffert
               vom StandardeingabegerÑt.

Gemdosnummer   7

Definition     long  Crawcin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Crawcin liest ein Zeichen unge-
               puffert von der Standardeingabe. Die Zeichen werden
               nicht interpretiert. Das heiût, daû <Control-C>,
               <Control-S> und <Control-Q> ignoriert werden.
               Wie bei Cnecin wird das von der Tastatur gelesene
               Zeichen nicht auf dem Bildschirm dargestellt.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cconin\#   \#Cconout\#   \#Crawio\#
\end

screen( capsensitive("Crawio") )
Name           Øcharacter raw input outputÆ - ermîglicht ungepufferte
               Ein-/Ausgaben.

Gemdosnummer   6

Definition     long  Crawio( int w );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Crawio fÅhrt ungepufferte Ein-Ausga-
               ben durch. Wenn als Argument w die Zahl 0xFF Åbergeben
               wurde, dann wird ein Zeichen vom StandardeingabegerÑt
               eingelesen. Wenn w einen anderen Wert hat, wird das
               Zeichen auf das StandardausgabegerÑt geschrieben.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cconin\#   \#Cconout\#   \#VT-52-Terminal\#
\end

screen( capsensitive("Dcreate") )
Name           Øcreate directoryÆ - Verzeichnis anlegen.

Gemdosnummer   57

Definition     int  Dcreate( const char *path );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dcreate legt ein Verzeichnis mit dem
               Pfadnamen path an. Der String path muû mit dem ASCII-
               Zeichen NUL abgeschlossen sein.

Ergebnis       Die Funktion liefert als Ergebnis eine negative Zahl,
               wenn es zu einem Fehler kam.

Querverweis    \#Ddelete\#
\end

screen( capsensitive("Ddelete") )
Name           Ødelete directoryÆ - Verzeichnis lîschen.

Gemdosnummer   58

Definition     int  Ddelete( const char *path );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Ddelete lîscht ein Verzeichnis mit
               dem Pfadnamen path, das keine weiteren Dateien oder
               Unterverzeichnisse enthalten darf. Der String path muû
               mit dem ASCII-Zeichen NUL abgeschlossen sein.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn das Ver-
               zeichnis gelîscht werden konnte, und eine negative
               Zahl, wenn es zu einem Fehler kam.

Querverweis    \#Dcreate\#
\end

screen( capsensitive("Dfree") )
Name           Øfree disk spaceÆ - ermittelt die KapazitÑtsauslastung
               eines Laufwerks.

Gemdosnummer   54

Definition     int  Dfree( \#DISKINFO\# *buf, int driveno );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dfree ermittelt KapazitÑt und Bele-
               gung eines Laufwerks driveno. Um die Informationen
               weiterzureichen, benîtigt man einen 16 Byte groûen
               Puffer, der wie folgt strukturiert ist:
                   Byte           Beschreibung
                   0-3            Anzahl freier Cluster
                   4-7            Gesamtanzahl an Clustern
                   8-11           Grîûe eines Sektors in Bytes
                   12-15          Sektoren pro Cluster
               Diese Struktur ist als Datentyp \#DISKINFO\# in der Dekla-
               rationsdatei tos.h enthalten.

Ergebnis       Die Funktion liefert bei korrekter AusfÅhrung eine 0,
               und eine negative Zahl, wenn es zu einem Fehler kam.
\end

screen( capsensitive("Dgetdrv") )
Name           Ødisk get driveÆ - ermittelt das aktuelle Laufwerk.

Gemdosnummer   25

Definition     int  Dgetdrv( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dgetdrv ermittelt das aktuelle Lauf-
               werk.

Ergebnis       Die Funktion liefert als Ergebnis eine Zahl, die das
               aktuelle Laufwerk bezeichnet:

                                 0      A:
                                 1      B:
                                 2      C:
                                 usw.

Querverweis    \#Dsetdrv\#
\end

screen( capsensitive("Dgetpath") )
Name           Øget pathÆ - aktuelles Verzeichnis ermitteln.

Gemdosnummer   71

Definition     int  Dgetpath( char *path, int driveno );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dgetpath ermittelt das aktuelle Ver-
               zeichnis auf dem Laufwerk driveno. Die Bezeichnungen
               der Laufwerke werden im Parameter driveno wie folgt
               codiert:
                           0      aktuelles Laufwerk
                           1      A:
                           2      B:
                           3      C:
                           usw.

               Der Pfad wird im Puffer path als String abgelegt. Da
               ein Pfad in GEMDOS bis zu 128 Zeichen lang sein kann,
               sollte der Puffer entsprechend viel Platz bieten.

Ergebnis       Die Funktion liefert als Ergebnis 0, wenn kein Fehler
               auftrat ansonsten einen Fehlercode.

Querverweis    \#Dsetpath\#
\end

screen( capsensitive("Dsetdrv") )
Name           Ødisk set driveÆ - legt das aktuelle Laufwerk fest.

Gemdosnummer   14

Definition     long  Dsetdrv( int drv );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dsetdrv macht das Laufwerk drv zum
               aktuellen Laufwerk. drv kann eine Integer-Zahl zwischen
               0 und 15 sein:
                                0      A:
                                1      B:
                                2      C:
                                usw.

Ergebnis       Die Funktion liefert als Ergebnis eine Bit-Tabelle mit
               allen angeschlossenen Laufwerken. Jedes angeschlossene
               Laufwerk wird mit einem gesetzten Bit angezeigt.

Querverweis    \#Dgetdrv\#
\end

screen( capsensitive("Dsetpath") )
Name           Øset pathÆ - legt das aktuelle Verzeichnis fest.

Gemdosnummer   59

Definition     int  Dsetpath( const char *path );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dsetpath setzt das aktuelle Ver-
               zeichnis. Der Pfad path muû ein String sein, der mit
               dem ASCII-Zeichen Null abgeschlossen sein muû.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn das Ver-
               zeichnis existiert, ansonsten eine negative Zahl.

Querverweis    \#Dgetpath\#
\end

screen( capsensitive("Fattrib") )
Name           Øfile attributeÆ - Dateiattribut ermitteln oder setzen.

Gemdosnummer   67

Definition     int  Fattrib( const char *filename,
                                 int wflag, int attrib );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fattrib ermittelt oder setzt die
               Attribute der mit filename bezeichneten Datei. Je nach
               dem, ob der Parameter wflag eine 0 oder 1 enthÑlt, wird
               das Attribut gelesen bzw. neu festgelegt. Das Attribut
               setzt sich aus folgenden Flags zusammen:

                 FA_READONLY     Datei darf nur gelesen werden.
                 FA_HIDDEN       Datei wird beim Auflisten des
                                 Dateiverzeichnisses nicht angezeigt.
                 FA_SYSTEM       Systemdatei.
                 FA_VOLUME       Diskettenname (11 Bytes).
                 FA_SUBDIR       Unterverzeichnis.
                 FA_ARCHIVE      Datei wurde verÑndert.

Ergebnis       Die Funktion liefert als Ergebnis das Attribut, wenn
               das Attribut gelesen werden sollte, ansonsten ist die
               Bedeutung nicht festgelegt.
\end

screen( capsensitive("Fclose") )
Name           Øfile closeÆ - Datei schlieûen.

Gemdosnummer   62

Definition     int  Fclose( int handle );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fclose schlieût eine Datei mit dem
               Dateibezeichner handle. Im Netzwerk wird das aktive
               Locking aufgehoben.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die
               Datei geschlossen werden konnte, ansonsten eine
               negative Zahl.

Querverweis    \#Fopen\#
\end

screen( capsensitive("Fcreate") )
Name           Øfile createÆ - Datei anlegen.

Gemdosnummer   60

Definition     int  Fcreate( const char *fname, int attr );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fcreate legt eine Datei an. Der
               Pfadname der Datei, fname, muû ein mit dem ASCII-
               Zeichen NUL abgeschlossener String sein. Der Parameter
               attr legt das Attribut der Datei fest. attr kann mit
               folgenden Flags ge-odert werden.

                 FA_READONLY     Datei darf nur gelesen werden.
                 FA_HIDDEN       Datei wird beim Auflisten des
                                 Dateiverzeichnisses nicht angezeigt.
                 FA_SYSTEM       Systemdatei.
                 FA_VOLUME       Diskettenname (11 Bytes).

               Im Netzwerk setzt das erzeugen einer Datei die
               ExclusivitÑt.

Ergebnis       Die Funktion liefert als Ergebnis einen long-Wert.
               Ist dieser negativ, so ist ein Fehler aufgetreten.
               Andernfalls enthÑlt das niederwertige Wort, das
               man durch Casten des Funktionsresultats erhÑlt,
               einen Handle, der in den nachfolgenden Schreib-/
               Lese-Operationen verwendet werden kann.

Querverweis    \#Fopen\#
\end

screen( capsensitive("Fdatime") )
Name           Øfile date and timeÆ - Uhrzeit und Datum einer Datei
               ermitteln oder setzen.

Gemdosnummer   87

Definition     int  Fdatime( \#DOSTIME\# *timeptr, int handle, int wflag );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fdatime liest oder setzt Datum und
               Uhrzeit der mit handle bezeichneten Datei. Der
               Parameter wflag bestimmt, ob Datum und Uhrzeit der
               Datei gelesen (0) oder geschrieben (1) werden sollen.
               Der Parameter timeptr zeigt auf die Struktur DOSTIME.

Ergebnis       Die Funktion liefert als Ergebnis Datum und Uhrzeit.
               Wenn Datum und Uhrzeit nicht modifiziert oder ermittelt
               werden konnten, den Wert 0 in time und date.
\end

screen( capsensitive("Fdelete") )
Name           Øfile deleteÆ - Datei lîschen.

Gemdosnummer   65

Definition     int  Fdelete( const char *fname );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fdelete lîscht die mit fname be-
               zeichnete Datei.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die
               Datei gelîscht werden konnte, und ein von 0 ver-
               schiedenes Ergebnis, wenn die Datei nicht gelîscht
               werden konnte.

Querverweis    \#Fcreate\#
\end

screen( capsensitive("Fdup") )
Name           Øfile duplicateÆ - Datei-Handle duplizieren.

Gemdosnummer   69

Definition     long  Fdup( int handle );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fdup erzeugt ein neues Datei-Handle
               fÅr die mit handle bezeichnete Datei.

Ergebnis       Die Funktion liefert als Ergebnis einen long-Wert.
               Ist dieser negativ, so ist ein Fehler aufgetreten.
               Andernfalls enthÑlt das niederwertige Wort, das
               man durch Casten des Funktionsresultats erhÑlt,
               einen Handle, der in den nachfolgenden Schreib-/
               Lese-Operationen verwendet werden kann.

Querverweis    \#Fforce\#
\end

screen( capsensitive("Fforce") )
Name           Øfile forceÆ - Standard-Datei umleiten.

Gemdosnummer   70

Definition     int  Fforce( int stch, int nonstdh );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fforce leitet die Ein- und Ausgaben
               einer Standarddatei stch in die mit nonstdh bezeich-
               nete Datei um.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die Um-
               leitung vorgenommen werden konnte, ansonsten einen
               Fehlercode.

Querverweis    \#Fdup\#
\end

screen( capsensitive("Fgetdta") )
Name           Øget disk transfer addressÆ - ermittelt den öbertra-
               gungsbereich fÅr Diskettenoperationen.

Gemdosnummer   47

Definition     \#DTA\#  *Fgetdta( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fgetdta ermittelt die Adresse eines
               Buffers fÅr \#Fsfirst\# und \#Fsnext\#. Auf die ermittelte
               Struktur kann man mit dem in tos.h deklarierten Daten-
               typ \#DTA\# zugreifen.

Ergebnis       Die Funktion liefert als Ergebnis die Adresse des Dis-
               kettenÅbertragungsbereichs.

Querverweis    \#Fsetdta\#   \#DTA\#   \#Fsfirst\#   \#Fsnext\#
\end

screen( capsensitive("Fopen") )
Name           Øfile openÆ - îffnet eine Datei.

Gemdosnummer   61

Definition     long  Fopen( const char *fname, int mode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fopen îffnet die im String fname an-
               gegebene Datei. Der Parameter mode bestimmt den Zu-
               griffsmodus auf die Datei:
                                FO_READ     Lesen
                                FO_WRITE    Schreiben
                                FO_RW       Lesen und Schreiben
               Im Netzwerk:
                               -1           shared write
                               -2           shared read/write
               sowie MS-DOS Open-Calls.

Ergebnis       Die Funktion liefert als Ergebnis einen long-Wert.
               Ist dieser negativ, so ist ein Fehler aufgetreten.
               Andernfalls enthÑlt das niederwertige Wort, das
               man durch Casten des Funktionsresultats erhÑlt,
               einen Handle, der in den nachfolgenden Schreib-/
               Lese-Operationen verwendet werden kann.

Querverweis    \#Fcreate\#
\end

screen( capsensitive("Fread") )
Name           Øfile readÆ - Datei lesen.

Gemdosnummer   63

Definition     long  Fread( int handle, long count, void *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fread liest count Zeichen von der
               mit handle bezeichneten Datei in den Puffer buf.

Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der
               gelesenen Zeichen, wenn der Leseprozeû erfolgreich
               durchgefÅhrt werden konnte, ansonsten einen Fehlercode
               mit einer negativen Zahl.

Querverweis    \#Fwrite\#
\end

screen( capsensitive("Frename") )
Name           Øfile renameÆ - Datei umbenennen.

Gemdosnummer   86

Definition     int  Frename( int zero, const char *oldname,
                              const char *newname );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Frename dient zum Umbenennen von
               Dateien. Die Datei mit dem Namen oldname wird in den
               neuen Dateinamen newname umbenannt. Es kînnen komplette
               Pfade mit Dateinamen Åbergeben werden.
               So kann man mit Frename ganz einfach eine Datei von
               einem Ordner in einen anderen schieben. Der Parameter
               zero ist fÅr TOS reserviert und muû den Wert 0
               enthalten. Ab TOS 1.4 kînnen auch Ordner umbenannt
               werden.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die
               Datei umbenannt werden konnte, ansonsten einen von 0
               verschiedenen Wert.
\end

screen( capsensitive("Fseek") )
Name           Øfile seekÆ - Dateiposition verschieben.

Gemdosnummer   66

Definition     long  Fseek( long offset, int handle, int seekmode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fseek verschiebt die aktuelle Datei-
               position der Datei handle um offset Bytes. Mit dem
               Parameter seekmode wÑhlt man den Ausgangspunkt:

                            seekmode       Bedeutung
                            0              Dateianfang
                            1              aktuelle Position
                            2              Dateiende

               Von diesem Ausgangspunkt aus verschiebt man den Datei-
               zeiger um den angegebenen offset.

Ergebnis       Die Funktion liefert als Ergebnis die neue Dateiposi-
               tion mit dem Datentyp long.
\end

screen( capsensitive("Fsetdta") )
Name           Øset disk transfer addressÆ - Setzen der Adresse fÅr
               den öbertragungsbereich fÅr Diskettenoperationen.

Gemdosnummer   26

Definition     void  Fsetdta( \#DTA\# *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fsetdta legt die DiskettenÅbertra-
               gungs-Adresse fest. Der Puffer buf muû mindestens 44
               Bytes groû sein, um die Informationen aufnehmen zu
               kînnen, die als Struktur \#DTA\# abgelegt werden.
               Diese Struktur ist in tos.h deklariert.
               Beim Programmstart liegt die DTA in der Kommandozeile
               und sollte vor dem ersten Diskettenzugriff mit Fsetdta
               an eine andere Stelle gelegt werden.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Fgetdta\#   \#Fsfirst\#
\end

screen( capsensitive("Fsfirst") )
Name           Øsearch first fileÆ - ersten Dateieintrag suchen.

Gemdosnummer   78

Definition     int  Fsfirst( const char *filename, int attr );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fsfirst sucht den ersten Dateiein-
               trag mit dem Attribut attr unter dem Pfadnamen file-
               name. Der Pfadname kann auch die Joker '*' und '?'
               enthalten.
               Nach Abschluû der Funktion steht der Verzeichniseintrag
               unter der DiskettenÅbertragungsadresse DTA, die mit
               Fgetdta und Fsetdta ermittelt bzw. festgelegt werden
               kann. Die Informationen kînnen dann der Struktur \#DTA\#
               entnommen werden.
               Der Parameter attr enthÑlt eine Kombination der
               folgenden Attribute.

                 FA_READONLY     Datei darf nur gelesen werden.
                 FA_HIDDEN       Datei wird beim Auflisten des
                                 Dateiverzeichnisses nicht angezeigt.
                 FA_SYSTEM       Systemdatei.
                 FA_VOLUME       Diskettenname (11 Bytes).
                 FA_SUBDIR       Unterverzeichnis.
                 FA_ARCHIVE      Datei wurde verÑndert.

Ergebnis       Die Funktion liefert als Ergebnis 0, wenn eine Datei
               gefunden werden konnte, ansonsten einen Fehlercode.

Querverweis    \#Fgetdta\#   \#Fsetdta\#   \#Fsnext\#
\end

screen( capsensitive("Fsnext") )
Name           Øsearch next fileÆ - nÑchsten Dateieintrag suchen.

Gemdosnummer   79

Definition     int  Fsnext( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fsnext sucht den nÑchsten Dateiein-
               trag der mit Fsfirst mit dem Attribut attr unter dem
               Pfadnamen fspec gesucht wurde.
               Nach Abschluû der Funktion steht der Verzeichniseintrag
               unter der DiskettenÅbertragungsadresse DTA, die mit
               Fgetdta und Fsetdta ermittelt bzw. festgelegt werden
               kann. Die Informationen kînnen dann der Struktur \#DTA\#
               entnommen werden.

Ergebnis       Die Funktion liefert als Ergebnis 0, wenn eine Datei
               gefunden werden konnte, ansonsten einen Fehlercode.

Querverweis    \#Fgetdta\#   \#Fsetdta\#   \#Fsfirst\#
\end

screen( capsensitive("Fwrite") )
Name           Øfile writeÆ - auf Datei schreiben.

Gemdosnummer   64

Definition     long  Fwrite( int handle, long count, void *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fwrite schreibt count Zeichen vom
               Puffer buf in die mit handle bezeichnete Datei.

Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der
               geschriebenen Zeichen, falls der Schreibvorgang
               erfolgreich war, ansonsten ist count vom Ergebnis
               verschieden, bei einer negativen Zahl ist es zu einem
               schweren Fehler gekommen. In der Regel ist die Diskette
               voll oder nicht mehr eingelegt.

Querverweis    \#Fread\#
\end

screen( capsensitive("Malloc") )
Name           Ømemory allocationÆ - Speicherplatz reservieren.

Gemdosnummer   72

Definition     void  *Malloc( long number );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Malloc reserviert einen Speicherbe-
               reich der Grîûe number. Mit dem Wert -1 kann man den
               maximal verfÅgbaren Speicherbereich berechnen.

Ergebnis       Die Funktion liefert als Ergebnis die Anfangsadresse
               des reservierten Bereichs als typenlosen Zeiger.
               Malloc liefert als Ergebnis eine 0, wenn nicht mehr
               genÅgend Speicher vorhanden ist.

Querverweis    \#Mfree\#    \#Mxalloc\#    \#Maddalt\#
\end

screen( capsensitive("Mxalloc") )
Name           ØAllocate memory (with preference)Æ - Speicherplatz
               reservieren.

Gemdosnummer   68

Definition     void  *Mxalloc( long amount, int mode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Mxalloc reserviert einen
               Speicherbereich der Grîûe amount. Der Parameter
               mode gibt an welche Speicherart angefordert
               werden soll:

                        0       ST-RAM
                        1       Alternatives RAM
                        2       egal, ST RAM bevorzugt
                        3       egal, alternatives RAM bevorzugt

               Mit dem Wert -1 fÅr amount kann man die LÑnge des
               grîûten zusammenhÑngend verfÅgbaren Speicherblocks
               erfragen.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Die Funktion liefert als Ergebnis die Anfangsadresse
               des reservierten Bereichs als typenlosen Zeiger.
               Mxalloc liefert als Ergebnis eine 0, wenn nicht mehr
               genÅgend Speicher vorhanden ist.

Querverweis    \#Mfree\#    \#Malloc\#    \#Maddalt\#
\end

screen( capsensitive("Maddalt") )
Name           ØInform GEMDOS of alternative memoryÆ - Alternativen
               Speicher anmelden.

Gemdosnummer   20

Definition     long  Maddalt( void *start, long size );

Prototyp in    tos.h

Beschreibung   Mit Maddalt kann man Speicher beim GEMDOS anmelden,
               der durch das BIOS nicht erkannt wird.
               start beschreibt die Startadresse des Speichers und
               size seine LÑnge. Der Speicher muû aus einem zusammen-
               hÑngenden Block bestehen.
               Wurde Speicher einmal mit Maddalt angemeldet, so
               gehîrt er dem GEMDOS und kann diesem nicht mehr
               weggenommen werden. Reservierungen des Speichers
               sollten ausschlieûlich Åber Malloc bzw. Mxalloc
               oder Pexec geschehen.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfÅgbar.

Ergebnis       Im Erfolgsfall wird Null zurÅckgegeben, ansonsten
               ein Fehlercode.

Querverweis    \#Mfree\#   \#Malloc\#   \#Mxalloc\#
\end

screen( capsensitive("Mfree") )
Name           Ømemory freeÆ - Speicherplatz freigeben.

Gemdosnummer   73

Definition     int  Mfree( void *block );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Mfree gibt einen mit Malloc reser-
               vierten Speicherbereich wieder frei.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Speicherplatz wieder frei gegeben wurde, ansonsten
               einen von 0 verschiedenen Wert.

Querverweis    \#Malloc\#   \#Mxalloc\#    \#Maddalt\#
\end

screen( capsensitive("Mshrink") )
Name           Ømemory shrinkÆ - Speicherbereich verkÅrzen.

Gemdosnummer   74

Definition     int  Mshrink( int zero, void *block, long newsiz );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Mshrink verkÅrzt einen bereits
               reservierten Speicherbereich block auf die neue Grîûe
               newsiz. Der Parameter zero muû immer mit 0 Åbergeben
               werden.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Speicher angepaût werden konnte, ansonsten einen von 0
               verschiedenen Wert.

Querverweis    \#Malloc\#   \#Mfree\#
\end

screen( capsensitive("Flock") )
Name           Øfile record lockingÆ - Record-Locking im Netzwerken.

Gemdosnummer   92

Definition     long Flock( int handle, int mode, long start, long length );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Flock sperrt length Bytes ab
               der Position start in der durch handle angegebenen
               Datei (falls mode == 0), bzw. hebt eine bestehende
               Blockierung auf (mode == 1).

Ergebnis       Die Funktion liefert bei fehlerfreier AusfÅhrung
               den Wert 0.

Querverweis    \#Fcreate\#, \#Fopen\#, \#Fclose\#, \#Fdelete\#, \#Ptermres\#
\end

screen( capsensitive("Pexec") )
Name           Øprogram executionÆ - Programm laden und ausfÅhren.

Gemdosnummer   75

Definition     long  Pexec( int mode, char *ptr1,
                               void *ptr2, void *ptr3 );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Pexec lÑdt und startet das im Pfad
               ptr1 angegebene Programm mit der Kommandozeile ptr2 und
               dem Environment ptr3, wenn der Parameter mode den Wert
               0 enthÑlt. Wenn in mode der Wert 3 steht, wird das
               Programm nur als Overlay geladen. Wenn mode den Wert 4
               enthÑlt, soll ein geladenes Programm gestartet werden;
               Parameter 2 und 4 mÅûen 0 sein . Wenn mode 5 ist, soll
               eine neue Basepage angelegt werden. Ab TOS 1.4 gibt es
               noch mode 6, der mode 4 entspricht, mit der Ausnahme,
               daû die Speicherzuordnung an den Tochterprozess ver-
               erbt wird.

Ergebnis       Die Funktion liefert als Ergebnis den Abschluûcode des
               Child-Prozesses. Wenn ein Overlay geladen wurde,
               enthÑlt das Ergebnis die Basepage des Overlays. Die
               Basepage hat die Struktur \#BASPAG\#.
               Bei einem negativen Resultat ist ein Fehler aufgetreten.
\end

screen( capsensitive("Pterm") )
Name           Øprocess terminationÆ - beendet ein TOS-Programm.

Gemdosnummer   76

Definition     void  Pterm( int retcode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Pterm beendet ein TOS-Programm und
               kehrt nicht wieder zurÅck. Der Abschluûcode retcode
               kann von anderen Programmen weiterverwendet werden.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Pterm0") )
Name           Øprocess terminationÆ - beendet ein TOS-Programm.

Gemdosnummer   0

Definition     void  Pterm0( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Pterm0 beendet ein TOS-Programm und
               kehrt nicht wieder zurÅck. Die Routine liefert den
               Return-Code 0 zurÅck.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Ptermres") )
Name           Øterminate and stay residentÆ - Programm beenden, aber
               im Speicher behalten.

Gemdosnummer   49

Definition     void  Ptermres( long keepcnt, int retcode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Ptermres beendet ein Programm, das
               Programm wird jedoch im Speicher gehalten. Dazu muû man
               unter keepcnt angeben, wieviele Bytes des Programms im
               Speicher gehalten werden sollen.
               Der Abschluûcode retcode kann von nachfolgenden
               Programmen ausgewertet werden. Im Netzwerk werden
               alle Lockings des Prozesses aufgehoben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Pexec\#   \#Pterm\#   \#Pterm0\#  \#_PgmSize\#
\end

screen( capsensitive("Super") )
Name           Øsupervisor Æ - Supervisor-Modus umschalten.

Gemdosnummer   32

Definition     long  Super( void *stack );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Super schaltet zwischen User-
               und Supervisior-Modus um bzw. fragt den aktuellen
               Betriebsmodus ab. Die Adresse des Supervisor-Stacks
               kann beim Umschalten verÑndert werden.
               Åbergibt man fÅr den Parameter stack den Wert 1, so
               wird der aktuelle Betriebsmodus erfragt. Der Wert 0
               schaltet zwischen User und Supervisor-Modus um. Alle
               anderen Werten werden als neue Adresse fÅr den
               Supervisor-Stack betrachtet.
               Im Supervisor-Modus kann auf alle geschÅtzten
               Speicherstellen zugegriffen werden.

Ergebnis       Sollte der Zustand ermittelt werden, erhÑlt man
               als Resultat 0 fÅr den User- und -1 fÅr den Super-
               visor-Modus.
               Ansonsten liefert die Funktion als Ergebnis die
               Adresse des alten Supervisor-Stacks, sofern in den
               Supervisor-Modus umgeschaltet wurde.

Beispiel       #include <tos.h>

               int  main( void )
               {
               long   old_super_stack;

                   old_super_stack = Super( 0L );

                   /* Supervisor-Aktionen ... */

                   Super((void *) old_super_stack );

                   return( 0 );
               }
\end

screen( capsensitive("Sversion") )
Name           Øoperating system versionÆ - ermittelt die Versions-
               nummer des Betriebssystems.

Gemdosnummer   48

Definition     int  Sversion( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Sversion ermittelt die Versionsnum-
               mer des Betriebssystems.

Ergebnis       Die Funktion liefert als Ergebnis die Version des
               Betriebssystems. Die Versionsnummer besteht aus zwei
               Zahlen: Das hîherwertige enthÑlt die Hauptversions-
               nummer, wÑhrend das niederwertige Byte kleinere
               öberarbeitungen kennzeichnet.
\end

screen( capsensitive("Tgetdate") )
Name           Øget dateÆ - Tagesdatum ermitteln.

Gemdosnummer   42

Definition     unsigned int  Tgetdate( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tgetdate ermittelt das aktuelle
               Tagesdatum.

Ergebnis       Die Funktion liefert als Ergebnis eine Integer-Zahl mit
               dem Tagesdatum. Das Datum ist wie folgt codiert:

                         Bits           Bedeutung
                         0-4            Tag (1-31)
                         5-8            Monat (1-12)
                         9-15           Jahr (0-119, 0= 1980)

Querverweis    \#Tsetdate\#
\end

screen( capsensitive("Tsetdate") )
Name           Øset dateÆ - Tagesdatum setzen.

Gemdosnummer   43

Definition     unsiged int  Tsetdate( unsigned int date );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tsetdate setzt das aktuelle Tagesda-
               tum. Der Parameter date ist wie folgt codiert:

                         Bits           Bedeutung
                         0-4            Tag (1-31)
                         5-8            Monat (1-12)
                         9-15           Jahr (0-119, 0= 1980)

Ergebnis       Die Funktion liefert als Ergebnis das tatsÑchlich
               gesetzte Datum.

Querverweis    \#Tgetdate\#
\end

screen( capsensitive("Tgettime") )
Name           Øget timeÆ - ermittelt die Uhrzeit.

Gemdosnummer   44

Definition     unsigned int  Tgettime( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tgettime ermittelt die Uhrzeit.

Ergebnis       Die Funktion liefert als Ergebnis die Uhrzeit. Sie ist
               wie folgt codiert:

                         Bits      Bedeutung
                         0-4       Sekunden im Zweierschritt (0-29)
                         5-10      Minuten (0-59)
                         11-15     Stunden (0-23)

Querverweis    \#Tsettime\#
\end

screen( capsensitive("Tsettime") )
Name           Øset timeÆ - setzt die Uhrzeit.

Gemdosnummer   45

Definition     unsiged int  Tsettime( unsigned int time );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tsettime setzt die Uhrzeit. Der
               Parameter time muû wie folgt codiert werden:

                         Bits      Bedeutung
                         0-4       Sekunden im Zweierschritt (0-29)
                         5-10      Minuten (0-59)
                         11-15     Stunden (0-23)

Ergebnis       Die Funktion liefert als Ergebnis die tatsÑchlich
               gesetzte Uhrzeit.

Querverweis    \#Tgettime\#
\end
