#include "hypdefs.h"
#include "hypdebug.h"

#ifdef __TOS__
#include "diallib.h"
#endif


struct pic_adm
{
	short type;
	unsigned short flags;
	struct {
 		_WORD x_offset;
		_WORD y_offset;
		_WORD width;
		_WORD height;
		_WORD wdwidth;
		gboolean islimage;
 		unsigned char attr;
	} osrc;
	long y_display;
	LOADED_PICTURE *data;
	GRECT trans;
	GRECT orig;
};


struct prepnode
{
	HYP_DOCUMENT *hyp;
	HYP_NODE *node;
	struct pic_adm *pic_adm;
	short pic_count;
	short pic_idx;
	LINEPTR *line_ptr;
	long y, h;
	short line;
	short min_lines;
	short empty;
	short empty_lines;
	short empty_start;
	short limage_add;

	short start_idx;
	short start_y;
	short start_line;

	short between;
	long y_start;

	short last_line;
	short last_width;
	long last_y;

	short width;
};



#ifdef HYP_HAVE_INLINE_ASM_M68K
static void gfx_dither_16_to_2(void *addr, long plane_size, short _16to2)
{
	__asm__ volatile
		("movem.l d0-d7/a0-a4,-(sp)\n\t"
		 "movea.l %0,a0\n\t"
		 "move.l %1,d0\n\t"
		 "move.w %2,d4\n\t"
		 "move.l a0,a1\n\t"
		 "adda.l d0,a1\n\t"
		 "movea.l a1,a4\n\t"
		 "movea.l a1,a2\n\t"
		 "adda.l d0,a2\n\t"
		 "movea.l a2,a3\n\t"
		 "adda.l d0,a3\n\t"
	 "rt4loop:"
		 "move.w (a0),d0\n\t"
		 "move.w (a1)+,d1\n\t"
		 "move.w (a2)+,d2\n\t"
		 "move.w (a3)+,d3\n\t"
		 "moveq.l #15,d6\n\t"
	 "rt4pixloop:"
		 "moveq.l #0,d7\n\t"
		 "add.w d3,d3\n\t"
		 "addx.w d7,d7\n\t"
		 "add.w d2,d2\n\t"
		 "addx.w d7,d7\n\t"
		 "add.w d1,d1\n\t"
		 "addx.w d7,d7\n\t"
		 "add.w d0,d0\n\t"
		 "addx.w d7,d7\n\t"
		 "move.w d4,d5\n\t"
		 "ror.w d7,d5\n\t"
		 "and.w #1,d5\n\t"
		 "add.w d5,d0\n\t"
		 "dbra d6,rt4pixloop\n\t"
		 "move.w d0,(a0)+\n\t"
		 "cmpa.l a0,a4\n\t"
		 "blt rt4loop\n\t"
		 "movem.l (sp)+,d0-d7/a0-a4\n\t"
		 :
		 :"a" (addr), "d"(plane_size), "d"(_16to2)
		 :"d0", "d1", "d2", "a0", "a1", "memory");
}


/*
 ; void mono_bitmap(void *src,void *dst,long planesize,int color);
 ; A0 - A3 Pointer auf 1. bis 4. Plane
 ; A4 - Pointer auf Zielbereich
 ; A5 - Endadresse fuer Plane 1
 ; D0 - D3 entsprechendes Wort aus entsprechender Plane
 ; D4 Pixelcounter
 ; D5 Pixelwert
 ; D6 aktuelle mono bitmap (16 Pixel)
 ; D7 gesuchte Farbe (=Pixelwert)
 */
static void mono_bitmap(void *src, void *dst, long planesize, short color)
{
/* MODULE mono_bitmap */
	__asm__ volatile
		("movem.l a2-a5/d3-d7,-(sp)\n\t"
		 "move.l %0,a0\n\t"
		 "move.l %1,a1\n\t"
		 "move.l %2,d0\n\t"
		 "move.w %3,d1\n\t"
		 "movea.l a1,a4\n\t"
		 "movea.l a0,a1\n\t"
		 "adda.l d0,a1\n\t"
		 "movea.l a1,a5\n\t"
		 "movea.l a1,a2\n\t"
		 "adda.l d0,a2\n\t"
		 "movea.l a2,a3\n\t"
		 "adda.l d0,a3\n\t"
		 "move.w d1,d7\n\t"
	 "1:"
		 "move.w (a0)+,d0\n\t"
		 "move.w (a1)+,d1\n\t"
		 "move.w (a2)+,d2\n\t"
		 "move.w (a3)+,d3\n\t"
		 "moveq.l #0,d6\n\t"
		 "moveq.l #15,d4\n\t"
	 "2:"
		 "moveq.l #0,d5\n\t"
		 "add.w d6,d6\n\t"
		 "add.w d3,d3\n\t"
		 "addx.w d5,d5\n\t"
		 "add.w d2,d2\n\t"
		 "addx.w d5,d5\n\t"
		 "add.w d1,d1\n\t"
		 "addx.w d5,d5\n\t"
		 "add.w d0,d0\n\t"
		 "addx.w d5,d5\n\t"
		 "cmp.w d5,d7\n\t"
		 "bne 3f\n\t"
		 "addq.w #1,d6\n\t"
	 "3:"
		 "dbra d4,2b\n\t"
		 "move.w d6,(a4)+\n\t"
		 "cmpa.l a5,a0\n\t"
		 "blt 1b\n\t"
		 "movem.l (sp)+,a2-a5/d3-d7\n\t"
		 :
		 :"a" (src), "a"(dst), "d"(planesize), "d"(color)
		 :"d0", "d1", "d2", "a0", "a1", "memory");
}

#endif


static void TrueColors(MFDB *src, MFDB *dst, short planes)
{
	_WORD colors[2] = { G_BLACK, G_WHITE };

	colors[0] = G_BLACK;
	if (gl_profile.viewer.transparent_pics)
		colors[1] = gl_profile.viewer.background_color;

	if (planes == 4)
	{
		long plane_size = ((long) dst->fd_wdwidth * dst->fd_h) << 1;
		MFDB mono;
		void *mono_plane;
		_WORD pxy[8], i;
		short hardware2vdi[] = { 0, 2, 3, 6, 4, 7, 5, 8, 9, 10, 11, 14, 12, 15, 13, 1 };
		mono_plane = g_malloc(plane_size);

		if (mono_plane == NULL)
		{
			HYP_DBG(("Not enough memory to adapt picture to true color."));
			HYP_DBG(("Planesize is %ld", (long)plane_size));
			return;
		}

		memset(mono_plane, 0, plane_size);

		mono.fd_addr = mono_plane;
		mono.fd_w = dst->fd_w;
		mono.fd_h = dst->fd_h;
		mono.fd_wdwidth = dst->fd_wdwidth;
		mono.fd_stand = 0;
		mono.fd_nplanes = 1;
		mono.fd_r1 = 0;
		mono.fd_r2 = 0;
		mono.fd_r3 = 0;

		pxy[0] = 0;
		pxy[1] = 0;
		pxy[4] = 0;
		pxy[5] = 0;

		pxy[2] = pxy[6] = dst->fd_w - 1;
		pxy[3] = pxy[7] = dst->fd_h - 1;

		mono_bitmap(src->fd_addr, mono_plane, plane_size, 15);
		vrt_cpyfm(vdi_handle, MD_REPLACE, pxy, &mono, dst, colors);
		(void) &mono; /* FIXME */
		(void) colors;
		
		for (i = 1; i < 15; i++)
		{
			mono_bitmap(src->fd_addr, mono_plane, plane_size, i);
			colors[0] = hardware2vdi[i];
			vrt_cpyfm(vdi_handle, MD_TRANS, pxy, &mono, dst, colors);
		}
		g_free(mono_plane);
	} else if (planes == 1)
	{
		_WORD pxy[8];

		src->fd_nplanes = 1;
		pxy[0] = 0;
		pxy[1] = 0;

		pxy[4] = 0;
		pxy[5] = 0;

		pxy[2] = pxy[6] = dst->fd_w - 1;
		pxy[3] = pxy[7] = dst->fd_h - 1;
		vrt_cpyfm(vdi_handle, MD_REPLACE, pxy, src, dst, colors);
	}
}


void hyp_pic_get_header(HYP_PICTURE *hyp_pic, const unsigned char *hyp_pic_raw)
{
	hyp_pic->width = short_from_chars(hyp_pic_raw);
	hyp_pic->height = short_from_chars(hyp_pic_raw + 2);
	hyp_pic->planes = hyp_pic_raw[4];
	hyp_pic->plane_pic = hyp_pic_raw[5];
	hyp_pic->plane_on_off = hyp_pic_raw[6];
	hyp_pic->filler = hyp_pic_raw[7];
}


static LOADED_PICTURE *LoadPicture(HYP_DOCUMENT *hyp, hyp_nodenr num)
{
	LOADED_PICTURE *pic = NULL;
	HYP_PICTURE hyp_pic;
	long mem_size;
	long plane_size;
	short line_size;
	long size;
	unsigned char *data;
	unsigned char hyp_pic_raw[SIZEOF_HYP_PICTURE];
	_WORD dst_planes;

	data = LoadData(hyp, num);	/*      Lade Eintrag    */

	if (data == NULL)
		return NULL;

	/*      HYP_PICTURE-Header entpacken    */
	if (!GetEntryBytes(hyp, num, data, hyp_pic_raw, SIZEOF_HYP_PICTURE))
	{
		g_free(data);
		return NULL;
	}
	
	hyp_pic_get_header(&hyp_pic, hyp_pic_raw);

	line_size = ((hyp_pic.width + 15) / 16) * 2;
	plane_size = line_size * (long) hyp_pic.height;

	/*      Volle Laenge der Daten ermitteln        */
	size = GetDataSize(hyp, num);
	if (size != plane_size * hyp_pic.planes + SIZEOF_HYP_PICTURE)
	{
		HYP_DBG(("Strange picture format: %ld bytes found, but %ld bytes expected",
			  (long) size, (long)(plane_size * hyp_pic.planes + SIZEOF_HYP_PICTURE)));
		g_free(data);
		return NULL;
	}

	HYP_DBG(("W: %d H: %d Planes: %d pic: %x on: %x",
                        hyp_pic.width,hyp_pic.height,hyp_pic.planes,
                        hyp_pic.plane_pic,hyp_pic.plane_on_off));

	hyp_pic.plane_pic &= ((1 << hyp_pic.planes) - 1);
	hyp_pic.plane_on_off &= ((1 << hyp_pic.planes) - 1);

	if (hyp_pic.plane_on_off)
	{
		HYP_DBG(("Unsupported picture format! The result may look strange."));
	}

#ifdef __TOS__
	dst_planes = ext_workout[4];
#else
	dst_planes = 0;
#endif
	if (dst_planes == 0)
		dst_planes = hyp_pic.planes;
	
	mem_size = sizeof(LOADED_PICTURE) + SIZEOF_HYP_PICTURE;
	if (hyp_pic.planes > 1)
	{
		mem_size += plane_size * max(hyp_pic.planes, dst_planes);
		mem_size += plane_size * dst_planes;
	} else
	{
		mem_size += 2 * plane_size;
	}

	pic = (LOADED_PICTURE *) g_malloc(mem_size);
	if (pic != NULL)
	{
		unsigned char *pic_start = (unsigned char *) pic + sizeof(LOADED_PICTURE);
		unsigned char *src;
		MFDB std_pic;

		memset(pic, 0, sizeof(*pic));

		if (hyp_pic.planes > 1)
			src = pic_start + plane_size * dst_planes;
		else
			src = pic_start + plane_size;

		if (!GetEntryBytes(hyp, num, data, src, size))
		{
			g_free(pic);
			g_free(data);
			return NULL;
		}
		
		src += SIZEOF_HYP_PICTURE;		/*      HYP_PICTURE-Header ueberspringen        */

		pic->number = num;

		pic->mfdb.fd_addr = pic_start;
		pic->mfdb.fd_w = hyp_pic.width;
		pic->mfdb.fd_h = hyp_pic.height;
		pic->mfdb.fd_wdwidth = line_size / 2;

		if (hyp_pic.planes > 1)
		{
			/*      Color image!    */
			pic->mfdb.fd_stand = 0;
			pic->mfdb.fd_nplanes = dst_planes;
			pic->mfdb.fd_r1 = pic->mfdb.fd_r2 = pic->mfdb.fd_r3 = 0;

			std_pic = pic->mfdb;
			std_pic.fd_stand = 1;
			std_pic.fd_addr = src;

			if (dst_planes <= 8)	/*      Kein True-Colour?       */
			{
				if (hyp_pic.planes < dst_planes)	/*      Bild hat weniger Planes?        */
				{
					unsigned char *unused_plane = &src[hyp_pic.planes * plane_size];
					short j;
					long i;

					/*      Schwarze Pixel extrahieren...   */
					for (i = 0; i < plane_size; i++)
					{
						unused_plane[i] = src[i];
						for (j = 1; j < hyp_pic.planes; j++)
							unused_plane[i] &= src[i + j * plane_size];
					}

					/*      ... und in noch leere Planes kopieren   */
					for (j = 1; j < (dst_planes - hyp_pic.planes); j++)
						memcpy(unused_plane + j * plane_size, unused_plane, plane_size);
				} else if (hyp_pic.planes > dst_planes)
				{
					switch (hyp_pic.planes)
					{
					case 4:
						pic->mfdb.fd_nplanes = 1;
						std_pic.fd_nplanes = 1;
						gfx_dither_16_to_2(std_pic.fd_addr, plane_size, 0xFF7EU);
						break;
					case 2:
						/* TODO */
						break;
					case 8:
						/* TODO */
						break;
					}
				}

				vr_trnfm(vdi_handle, &std_pic, &pic->mfdb);

				if (gl_profile.viewer.background_color != G_WHITE && gl_profile.viewer.transparent_pics)
				{
					_WORD pxy[8];
					_WORD colors[2];
					short j;
					long i;

					colors[1] = gl_profile.viewer.background_color;

					pxy[0] = 0;
					pxy[1] = 0;
					pxy[4] = 0;
					pxy[5] = 0;

					pxy[2] = pxy[6] = pic->mfdb.fd_w - 1;
					pxy[3] = pxy[7] = pic->mfdb.fd_h - 1;

					/*      Farbige Pixel extrahieren...    */
					for (i = 0; i < plane_size; i++)
					{
						for (j = 1; j < hyp_pic.planes; j++)
							src[i] |= src[i + j * plane_size];
					}

					std_pic.fd_nplanes = 1;
					vrt_cpyfm(vdi_handle, MD_ERASE, pxy, &std_pic, &pic->mfdb, colors);
					(void) &colors; /* FIXME */
				}
			} else
			{
				TrueColors(&std_pic, &pic->mfdb, hyp_pic.planes);
			}
		} else
		{
			/*      Monochrome image!       */
			pic->mfdb.fd_stand = 0;
			pic->mfdb.fd_nplanes = 1;
			pic->mfdb.fd_r1 = pic->mfdb.fd_r2 = pic->mfdb.fd_r3 = 0;

			std_pic = pic->mfdb;
			std_pic.fd_stand = 1;
			std_pic.fd_addr = src;

			vr_trnfm(vdi_handle, &std_pic, &pic->mfdb);
		}
		pic = (LOADED_PICTURE *)g_realloc(pic, sizeof(LOADED_PICTURE) + plane_size * pic->mfdb.fd_nplanes);
	}
	g_free(data);

	return pic;
}


static void set_start(struct prepnode *p, gboolean empty)
{
	int i;

	if (p->pic_count)
	{
		long limag_yadd = 0;
		short limage_y = -1;
		short align;
		short inside_idx = -1;

		for (i = 0; i < p->pic_count; i++)
		{
			short ly2 = p->pic_adm[i].orig.g_y + p->pic_adm[i].orig.g_h;

			if (p->line >= p->pic_adm[i].orig.g_y && p->line < ly2)
			{
				if (p->pic_adm[i].type != -1 && p->line == p->pic_adm[i].orig.g_y)
				{
					short py2 = 0,
						ny,
						type = p->pic_adm[i].type;
					gboolean islimage;
					LOADED_PICTURE *pic;

					if (type == HYP_ESC_LINE || type == HYP_ESC_BOX || type == HYP_ESC_RBOX)
					{
						p->pic_adm[i].y_display = p->y;
						p->pic_adm[i].trans.g_y = (_WORD) p->y;
						p->pic_adm[i].trans.g_h = (_WORD)(p->pic_adm[i].orig.g_h * p->hyp->line_height);
					} else
					{
						if (i != 0)
						{
							py2 = (p->pic_adm[i - 1].trans.g_y + p->pic_adm[i - 1].trans.g_h);
							align = py2 % p->hyp->line_height;
							if (align)
								py2 += (p->hyp->line_height - align);
						}

						islimage = p->pic_adm[i].osrc.islimage;
						if (islimage || i == 0 || p->y >= py2)
						{
							ny = p->y;
							if (islimage)
							{
								pic = p->pic_adm[i].data;

								if (limage_y == -1)
									limage_y = ny;

								if (limag_yadd < pic->mfdb.fd_h)
								{
									p->line_ptr[p->line].y += pic->mfdb.fd_h - limag_yadd;
									p->y += pic->mfdb.fd_h - limag_yadd;
									align = p->y % p->hyp->line_height;
									if (align)
									{
										align = p->hyp->line_height - align;
										p->line_ptr[p->line].y += align;
										p->y += align;
									}
									limag_yadd = pic->mfdb.fd_h;

									p->last_line = p->line;
									p->last_y = p->y;
									p->last_width = p->width;
								}
								p->pic_adm[i].trans.g_y = ny = limage_y;
								p->pic_adm[i].type = -1;
								empty = TRUE;
							} else
							{
								p->pic_adm[i].trans.g_y = ny;
							}
						} else
						{
							ny = p->y;
							p->pic_adm[i].trans.g_y = ny;
							if (inside_idx == -1 || p->pic_adm[i].trans.g_h > p->pic_adm[inside_idx].trans.g_h)
							{
								if (inside_idx >= 0)
									p->pic_adm[inside_idx].type = -1;
								inside_idx = i;
							} else
								p->pic_adm[i].type = -1;
						}
						p->pic_adm[i].y_display = ny;
						if (!empty)
						{
							p->start_y = p->line;
							p->start_line = -1;
							p->y_start = p->y;
							p->start_idx = i;
							p->between = 1;
							p->last_line = -1;
						}
					}
				}
			}
		}
		if (inside_idx >= 0 && !empty)
		{
			p->start_y = p->line;
			p->start_line = -1;
			p->y_start = p->y;
			p->start_idx = inside_idx;
			p->between = 1;
			p->last_line = -1;
		}
	}
}


static short check_end(struct prepnode *p, short force)
{
	short ret = 0;

	switch (p->between)
	{
	case 1:
		{
			short h1, h2;

			if (force || (p->line >= (p->pic_adm[p->start_idx].orig.g_y + p->pic_adm[p->start_idx].orig.g_h)))
			{
				long py2 = p->pic_adm[p->start_idx].trans.g_y + p->pic_adm[p->start_idx].trans.g_h;

				if (p->pic_adm[p->start_idx].type != -1)
				{
					short start_line = p->start_line;

					if (start_line == -1)
						start_line = p->start_y;

					if (start_line != -1)
					{
						h2 = p->pic_adm[p->start_idx].trans.g_h;
						h1 = p->y - p->y_start;

						if (h2 > h1)
						{
							long diff = ((long) p->pic_adm[p->start_idx].trans.g_y + (h2 - h1)) - p->y_start;

							p->line_ptr[start_line].y += diff;
							p->y += diff;
							diff = (p->y % p->hyp->line_height);
							if (diff)
							{
								diff = p->hyp->line_height - diff;
								p->line_ptr[start_line].y += diff;
								p->y += diff;
							}
						}
						p->pic_adm[p->start_idx].type = -1;
					}
#if 1
					else if (p->y < py2)
					{
						long diff = p->y - py2;

						p->line_ptr[p->line].y += diff;
						p->y += diff;
						diff = (diff % p->hyp->line_height);
						if (diff)
						{
							diff = p->hyp->line_height - diff;
							p->line_ptr[p->line].y += diff;
							p->y += diff;
						}
					}
#endif
					p->last_y = p->y;
					p->last_line = p->line;
					p->last_width = p->width;
				}
				p->start_y = -1;
				ret = 1;
			}
		}
		break;
	}
	return ret;
}


gboolean PrepareNode(HYP_DOCUMENT *hyp, HYP_NODE *node)
{
	const unsigned char *src = node->start;
	const unsigned char *end = node->end;
	const unsigned char *line_start;
	gboolean gfx_bloc = TRUE;
	long real_height = 0;
	struct prepnode p;

	if (hyp->skip_prepare)
		return TRUE;
	
	memset(&p, 0, sizeof(p));
	p.hyp = hyp;
	p.node = node;

	while (src < end && *src == HYP_ESC)
	{
		switch (src[1])
		{
		case HYP_ESC_PIC:
		case HYP_ESC_LINE:
		case HYP_ESC_BOX:
		case HYP_ESC_RBOX:
			p.pic_count++;
			break;
		default:
			break;
		}
		src = skip_esc(src);
	}

	if (p.pic_count != 0)
	{
		p.pic_adm = g_new(struct pic_adm, p.pic_count);
		if (p.pic_adm == NULL)
			goto error;
	}

	/*      Zuerst wird der Grafik-/Info-Block bearbeitet (=alles ESC Daten)        */
	src = node->start;
	while (src < end && gfx_bloc)					/*      ESC ?   */
	{
		if (*src == HYP_ESC)
		{
			src++;
			switch (*src)
			{
			case HYP_ESC_WINDOWTITLE:
				src++;					/*      Nummer ueberspringen    */
				node->window_title = src;	/*      Fenstertitel merken     */
				src += ustrlen(src) + 1;	/*      Daten ueberspringen     */
						/*****  Abfrage ob ungerade Adresse noetig???   ******/
				break;
			
			case HYP_ESC_EXTERNAL_REFS:		/*      bis zu 12 Querverweis-Datenbloecke      */
				src += src[1] - 1;	/*      Daten ueberspringen     */
				break;

			case HYP_ESC_CASE_DATA:				/*      weitere Datenbloecke    */
				src += src[1] - 1;		/*      Daten ueberspringen     */
				break;
			
			case HYP_ESC_OBJTABLE:				/*      Tabelle mit Objekten und Seiten */
				{
#if 0
					short line_nr,
					 tree_nr,
					 obj_nr,
					 index_nr;

					line_nr = DEC_255(&src[1]);	/*      Zeilennummer in der Zielseite   */
					tree_nr = DEC_255(&src[3]);	/*      Nummer des Baumes       */
					obj_nr = DEC_255(&src[5]);	/*      Objekt in diesem Baum   */
					index_nr = DEC_255(&src[7]);	/*      Index der Seite */

					HYP_DBG(("Objtable: Line: %d  Tree: %d  Obj: %d  Index: %d", line_nr, tree_nr, obj_nr, index_nr));

#endif
					src += 9;			/*      Daten berspringen       */
				}
				break;

			case HYP_ESC_PIC:				/*      Bild    */
				{
					hyp_nodenr num;
					long tmp;
					LOADED_PICTURE *pic;

					num = DEC_255(&src[1]);

					pic = (LOADED_PICTURE *) AskCache(hyp, num);

					if (pic == NULL)
					{
						pic = LoadPicture(hyp, num);
						TellCache(hyp, num, (HYP_NODE *)pic);
					}

					if (pic != NULL)
					{
						short val;
						gboolean islimage;
						_WORD y_offset;
						unsigned char y_height;
						
						p.pic_adm[p.pic_idx].type = HYP_ESC_PIC;
						p.pic_adm[p.pic_idx].data = pic;

						p.pic_adm[p.pic_idx].osrc.x_offset = src[3];
						y_offset = DEC_255(&src[4]);
						p.pic_adm[p.pic_idx].osrc.y_offset = y_offset;
						p.pic_adm[p.pic_idx].osrc.width = src[6];
						y_height = src[7];
						p.pic_adm[p.pic_idx].osrc.height = y_height;
						islimage = hyp->comp_vers >= 3 && src[6] == 1;
						p.pic_adm[p.pic_idx].osrc.islimage = islimage;
						p.pic_adm[p.pic_idx].osrc.wdwidth = (pic->mfdb.fd_h + 15) >> 4;
						if (!src[3])
						{
							val = (hyp->line_width - (pic->mfdb.fd_w / hyp->char_width)) >> 1;

							val = val > 0 ? val : 0;
						} else
						{
							val = src[3] - 1;
						}
						p.pic_adm[p.pic_idx].orig.g_x = val;

						p.pic_adm[p.pic_idx].orig.g_w = (_WORD)(pic->mfdb.fd_w / hyp->char_width);

						p.pic_adm[p.pic_idx].orig.g_y = y_offset;
						p.pic_adm[p.pic_idx].orig.g_h = y_height;

						tmp = pic->mfdb.fd_h;
						if ((tmp % hyp->line_height))
							tmp += hyp->line_height - (tmp % hyp->line_height);
						p.pic_adm[p.pic_idx].trans.g_h = (_WORD)tmp;

						tmp = (long) ((unsigned short) y_offset) * 16;
						tmp += ((tmp % hyp->line_height) ? hyp->line_height - (tmp % hyp->line_height) : 0);
						p.pic_adm[p.pic_idx].trans.g_y = (_WORD)tmp;

						if (islimage)
						{
							p.line += p.pic_adm[p.pic_idx].orig.g_h;
							p.limage_add += p.pic_adm[p.pic_idx].orig.g_h;
							p.pic_adm[p.pic_idx].flags = 1;
						}

						/*      @limage ?       */
						if (islimage)
						{
							p.line += y_height;
							p.limage_add += y_height;
						} else
						{
							p.min_lines = max(p.min_lines, (short) (p.limage_add + y_offset) + y_height);
						}
						p.width = max(p.width, src[3] * hyp->char_width + pic->mfdb.fd_w);
					}
					src += 8;
					p.pic_idx++;
				}
				break;

			case HYP_ESC_LINE:
				{
					GRECT r;
					_WORD y_offset;
					_WORD width;
					_WORD height;
					
					p.pic_adm[p.pic_idx].osrc.x_offset = src[1];
					p.pic_adm[p.pic_idx].osrc.y_offset = y_offset = DEC_255(&src[2]);
					p.pic_adm[p.pic_idx].osrc.width = width = (src[4] - 128);
					p.pic_adm[p.pic_idx].osrc.height = height = src[5];
					p.pic_adm[p.pic_idx].osrc.attr = src[6];
					
					r.g_x = p.pic_adm[p.pic_idx].osrc.x_offset;
					r.g_y = y_offset;
					r.g_w = width;
					r.g_h = height;

					p.min_lines = max(p.min_lines, r.g_y + r.g_h);
					p.width = max(p.width, r.g_x + r.g_w);

					p.pic_adm[p.pic_idx].type = *src;
					p.pic_adm[p.pic_idx].orig = r;

					p.pic_adm[p.pic_idx].trans.g_y = y_offset * 16;
					p.pic_adm[p.pic_idx].trans.g_h = height;

					src += 7;
					p.pic_idx++;
				}
				break;
			
			case HYP_ESC_BOX:
			case HYP_ESC_RBOX:
				{
					GRECT r;
					_WORD y_offset;
					_WORD width;
					_WORD height;

					p.pic_adm[p.pic_idx].osrc.x_offset = src[1];
					p.pic_adm[p.pic_idx].osrc.y_offset = y_offset = DEC_255(&src[2]);
					p.pic_adm[p.pic_idx].osrc.width = width = (src[4] - 128);
					p.pic_adm[p.pic_idx].osrc.height = height = src[5];
					p.pic_adm[p.pic_idx].osrc.attr = src[6];
					
					r.g_x = p.pic_adm[p.pic_idx].osrc.x_offset;
					r.g_y = p.limage_add + y_offset;
					r.g_w = width;
					r.g_h = height;

					p.min_lines = max(p.min_lines, r.g_y + r.g_h);
					p.width = max(p.width, r.g_x + r.g_w);

					p.pic_adm[p.pic_idx].type = *src;
					p.pic_adm[p.pic_idx].orig = r;

					p.pic_adm[p.pic_idx].trans.g_y = y_offset * 16;
					p.pic_adm[p.pic_idx].trans.g_h = height;

					src += 7;
					p.pic_idx++;
				}
				break;
			
			default:
				gfx_bloc = FALSE;
				src--;
				break;
			}
		} else
		{
			gfx_bloc = FALSE;
		}
	}

	/*      Beginn der ersten Zeile merken  */
	line_start = src;

	/*      Anzahl Zeilen Anhand der Nullbytes zaehlen      */
	while (src < end)
	{
		if (!*src++)					/*      Nullbyte? => Zeilenende */
			p.line++;
	}
	p.line += 1;

	node->lines = max(p.line, p.min_lines);

	/*      Speicher fuer die Zeilenanfang-Tabelle anlegen  */
	p.line_ptr = g_new(LINEPTR, node->lines);
	node->line_ptr = p.line_ptr;
	
	if (p.line_ptr == NULL)
	{
		HYP_DBG(("ERROR: Out of memory while creating line buffer"));
		goto error;
	}

	/*      Tabelle leeren  */
	memset(p.line_ptr, 0, sizeof(LINEPTR) * node->lines);

	/*      <src> auf den Anfang der Textdaten zuruecksetzen        */
	src = line_start;

	p.line = 0;
	p.limage_add = 0;
	p.last_line = -1;

	{
		_WORD ext[8];
		_WORD x = 0;
		_WORD curr_txt_effect = 0;
		char line_buffer[1024];
		char *dst = line_buffer;

		p.start_y = -1;
		p.start_idx = -1;
		p.h = hyp->line_height;
		p.line_ptr[0].txt = src;

		/*      Standard Text-Effekt    */
		vst_effects(vdi_handle, curr_txt_effect);

		while (p.line < node->lines)
		{
			if (src != NULL && src >= end)
				src = NULL;

			if (src != NULL && *src == HYP_ESC)		/*      ESC-Codes       */
			{
				src++;					/*      ESC ueberspringen       */

				*dst = '\0';			/*      Pufferende schreiben    */
				dst = line_buffer;		/*      ... und zuruecksetzen   */

				/*      Zeilenpuffer enthaelt Daten?    */
				if (*line_buffer)
				{
					vqt_extent(vdi_handle, line_buffer, ext);
					x += (ext[2] + ext[4]) >> 1;
				}

				switch (*src)			/*      Was fuer ein Code?      */
				{
				case HYP_ESC_ESC:		/*      ESC Zeichen     */
					*dst++ = HYP_ESC_ESC;
					src++;
					break;
				case HYP_ESC_LINK:
				case HYP_ESC_LINK_LINE:
				case HYP_ESC_ALINK:
				case HYP_ESC_ALINK_LINE:
					{
						hyp_nodenr dest_page;

						if (*src == HYP_ESC_LINK_LINE || *src == HYP_ESC_ALINK_LINE)	/*      Zeilennummer ueberspringen      */
							src += 2;

						dest_page = DEC_255(&src[1]);
						src += 3;

						/*      Verknuepfungstext ermitteln     */
						if (*src <= HYP_STRLEN_OFFSET)
						{
							if (hypnode_valid(hyp, dest_page))
							{
								dst = (char *)hyp->indextable[dest_page]->name;
							} else
							{
								dst = line_buffer;
								*dst = '\0';
							}
						} else
						{
							size_t len = *src - HYP_STRLEN_OFFSET;
							memcpy(dst, src + 1, len);
							dst[len] = 0;
							src += len;
						}

						/*      Verknuepfungstext mit entsprechendem Texteffekt ausgeben        */
						vst_effects(vdi_handle, gl_profile.viewer.link_effect);

						vqt_extent(vdi_handle, dst, ext);
						x += (ext[2] + ext[4]) >> 1;

						vst_effects(vdi_handle, curr_txt_effect);

						dst = line_buffer;
						*dst = 0;
						src++;
					}
					break;

				case HYP_ESC_CASE_TEXTATTR:
					curr_txt_effect = *(src) - HYP_ESC_TEXTATTR_FIRST;
					vst_effects(vdi_handle, curr_txt_effect);
					src++;
					break;
				
				default:
					HYP_DBG(("unknown Tag: %u", *src));
					break;
				}
			} else if (src != NULL && *src)		/*      Beliebiger Text */
			{
				*dst++ = *src++;
			} else						/*      Zeilenende      */
			{
				if (src != NULL)
				{
					*dst = 0;			/*      Pufferende schreiben    */
					dst = line_buffer;
				}						/*      ... und zuruecksetzen   */
				if (src == NULL || src == line_start)
				{
				  again_e:
					if (p.start_y == -1)
						set_start(&p, FALSE);
					else
					{
						if (check_end(&p, 0))
							goto again_e;
					}
					line_start = NULL;
					if (!p.empty_lines)
						p.empty_start = p.line;
					p.empty_lines++;
				} else
				{
				  again:
					if (p.start_y == -1)
						set_start(&p, FALSE);
					else
					{
						if (check_end(&p, 0))
							goto again;
					}
					if (p.start_line == -1)
					{
						p.start_line = p.line;
						p.start_y = p.line;
						p.y_start = p.y;
					}
					p.empty_lines = 0;
					vqt_extent(vdi_handle, line_buffer, ext);
					x += (ext[2] + ext[4]) >> 1;
					p.width = max(p.width, x);
					x = 0;
				}
				if (line_start || p.start_y != -1)
				{
					p.last_y = p.y;
					p.last_line = p.line;
					p.last_width = p.width;
				}
				p.y += p.h;

				p.line_ptr[p.line].w = p.width;
				p.line_ptr[p.line].h = p.h;
				p.line_ptr[p.line].txt = line_start;

				real_height += (p.line_ptr[p.line].y + p.line_ptr[p.line].h);

				p.line++;

				line_start = src ? ++src : NULL;
			}
		}
		(void) curr_txt_effect; /* FIXME */
	}

	node->columns = p.last_width / hyp->char_width + 2;
	node->height = p.last_y + p.h;
	node->lines = p.line;

	g_free(p.pic_adm);

	return TRUE;

  error:
	g_free(node->line_ptr);
	node->line_ptr = NULL;
	g_free(p.pic_adm);
	return FALSE;
}
